---
layout: post
title: YOLOv4 Optimal Speed and Accuracy of Object Detection
author: kozistr
categories: deep-learning
tags: DeepLearning, vision, object-detection, yolo
use_math: true
---

posted by [kozistr](http://kozistr.tech)

## tl;dr

이번에 리뷰할 논문은 오랜만에 나온 YOLO 4번째 버전인 YOLOv4 논문입니다.

이번 버전은 이야기가 있는(?) 버전인데, YOLO 원 저자인 Joe Redmon 님 께서 올해 2월 쯤에 twit으로 CV 연구를 그만하겠다고 선언하셨는데 (~~정말 YOLO 하러 가셨을까~~),
과연 이번 버전엔 저자에 포함될지, darknet page에는 YOLOv4 가 올라갈지 이야기가 있었는데, 이번 저자로는 빠지셨고 ㅠㅠ darknet 에는 올라갔더라고요.

쨋든, 요약하면 현재 SOTA 인 EfficientDet 과 비슷한 AP를 달성하면서 높은 FPS를 달성했네요.

paper : [arXiv](https://arxiv.org/pdf/2004.10934.pdf)
code : [github](https://github.com/pjreddie/darknet)

## Related Work

YOLO 시리즈

* YOLO v1 : [arXiv](https://arxiv.org/pdf/1506.02640.pdf)
* YOLO v2 : [arXiv](https://arxiv.org/pdf/1612.08242.pdf)
* YOLO v3 : [arXiv](https://pjreddie.com/media/files/papers/YOLOv3.pdf)

## Introduction

이번에도 논문에서는 speed 를 추구한다고 강조를 하면서 

0. 누구나 저렴한 GPU 장비로 학습 가능
1. 빠른 operation 사용
2. parallel computing 최적화 등등 

여러가지들을 고려했다고 합니다.

총 2가지의 production serving 환경을 옵션을 들면서 설명하는데,

### GPU

convolution layer 에서 작은 group 들 (1 ~ 8) 을 사용했다고 카네요. CSPResNeXt50 / CSPDarknet53 

### VPU

grouped-convolution 을 사용하고, SE Module 을 사용하지 않는다고 하네요.

또한 BoF (Bag of Freebies), BoS (Bag of Specials)

## Architecture

크게 아키텍쳐를 설계하고 튜닝하는 것을 논문에선 3 부분으로 나눠서 설명합니다.

1. 아키텍쳐 선정
2. BoF, BoS (여러가지 augmentation, activation, layer)
3. 기타 튜닝

### Selection of Architecture

이 논문에선 optimal 한 architecture 를 설계하기 위해 총 3 가지의 balance 를 고려하는데요,

1. resolution of input image
2. num of layers
3. num of parameters

Backbone 으로 사용할 network 가 ImageNet classification task 에선 좋은 성능을 보일진 몰라도
Object Detection task 에선 고려해야 할 점이 또 다르기 때문에, 띵킹을 해야 한다라는 점을 언급해요.

예로는 CSPResNeXt50 가 CSPDarknet53 보다 ImageNet 에선 성능이 좋아도, MS COCO dataset 에서 Object Detection 에선
반대라고 합니다.

결론적으로 CSPResNeXt50 vs CSPDarknet53 vs EfficientNet-B3 을 backbone 으로 benchmark 결과
CSPDarknet53 이 detector backbone 으로 사용하기 optimal 하다는 결론을 내립니다.

![img](/assets/YOLOv4/backbone-benchmark.png)

또한 SSP Module 을 추가적으로 사용하고 (receptive field 때문에), PANet 을 feature aggregation 을 위해 사용한다고 합니다. (YOLOv3 에서 쓰던 FPN 대신 사용하는 거)

최종적으로 아래와 같은 architecture 를 사용합니다.

* `backbone` : CSPDarknet53 w/ SSP 
* `neck` : PANet (path-aggregation)
* `head` : YOLOv3 (anchor-based)

### Selection of BoF and BoS

### Additional improvements


## Experiment Result


## Conclusion

이번 논문은 정말 모든 case 들을 하나하나 고려하려는 게 보였고, 설명도 최대한 low-level(?) 하게 하나하나 스킾하지 않고
다 짚고 넘어가서 뭔가 투머치 같지만 좋았어요 

결론 : 굳
